# typed: strong

module Orb
  module Models
    class PlanCreateParams < Orb::BaseModel
      extend Orb::RequestParameters::Converter
      include Orb::RequestParameters

      # An ISO 4217 currency string for invoices generated by subscriptions on this
      #   plan.
      sig { returns(String) }
      attr_accessor :currency

      sig { returns(String) }
      attr_accessor :name

      # Prices for this plan. If the plan has phases, this includes prices across all
      #   phases of the plan.
      sig do
        returns(
          T::Array[
          T.any(
            Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice
          )
          ]
        )
      end
      attr_accessor :prices

      # Free-form text which is available on the invoice PDF and the Orb invoice portal.
      sig { returns(T.nilable(String)) }
      attr_accessor :default_invoice_memo

      sig { returns(T.nilable(String)) }
      attr_accessor :external_plan_id

      # User-specified key/value pairs for the resource. Individual keys can be removed
      #   by setting the value to `null`, and the entire metadata mapping can be cleared
      #   by setting `metadata` to `null`.
      sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
      attr_accessor :metadata

      # The net terms determines the difference between the invoice date and the issue
      #   date for the invoice. If you intend the invoice to be due on issue, set this
      #   to 0.
      sig { returns(T.nilable(Integer)) }
      attr_accessor :net_terms

      # The status of the plan to create (either active or draft). If not specified,
      #   this defaults to active.
      sig { returns(T.nilable(Orb::Models::PlanCreateParams::Status::OrSymbol)) }
      attr_reader :status

      sig { params(status: Orb::Models::PlanCreateParams::Status::OrSymbol).void }
      attr_writer :status

      sig do
        params(
          currency: String,
          name: String,
          prices: T::Array[
          T.any(
            Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice,
            Orb::Util::AnyHash,
            Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice,
            Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice,
            Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice
          )
          ],
          default_invoice_memo: T.nilable(String),
          external_plan_id: T.nilable(String),
          metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
          net_terms: T.nilable(Integer),
          status: Orb::Models::PlanCreateParams::Status::OrSymbol,
          request_options: T.any(Orb::RequestOptions, Orb::Util::AnyHash)
        )
          .returns(T.attached_class)
      end
      def self.new(
        currency:,
        name:,
        prices:,
        default_invoice_memo: nil,
        external_plan_id: nil,
        metadata: nil,
        net_terms: nil,
        status: nil,
        request_options: {}
      )
      end

      sig do
        override
          .returns(
            {
              currency: String,
              name: String,
              prices: T::Array[
              T.any(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice
              )
              ],
              default_invoice_memo: T.nilable(String),
              external_plan_id: T.nilable(String),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              net_terms: T.nilable(Integer),
              status: Orb::Models::PlanCreateParams::Status::OrSymbol,
              request_options: Orb::RequestOptions
            }
          )
      end
      def to_hash
      end

      module Price
        extend Orb::Union

        Variants =
          type_template(:out) do
            {
              fixed: T.any(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice
              )
            }
          end

        class NewPlanUnitPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::UnitConfig) }
          attr_reader :unit_config

          sig do
            params(
              unit_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::UnitConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :unit_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              unit_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::UnitConfig, Orb::Util::AnyHash),
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            unit_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :unit
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  unit_config: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::UnitConfig,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol)
            MONTHLY = T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol)

            class << self
              sig { override.returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::Cadence::TaggedSymbol]) }
              def values
              end
            end
          end

          class UnitConfig < Orb::BaseModel
            # Rate per unit of usage
            sig { returns(String) }
            attr_accessor :unit_amount

            sig { params(unit_amount: String).returns(T.attached_class) }
            def self.new(unit_amount:)
            end

            sig { override.returns({unit_amount: String}) }
            def to_hash
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanPackagePrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::PackageConfig) }
          attr_reader :package_config

          sig do
            params(
              package_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::PackageConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :package_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              package_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::PackageConfig, Orb::Util::AnyHash),
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            package_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :package
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  package_config: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::PackageConfig,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol)
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::Cadence::TaggedSymbol])
              end
              def values
              end
            end
          end

          class PackageConfig < Orb::BaseModel
            # A currency amount to rate usage by
            sig { returns(String) }
            attr_accessor :package_amount

            # An integer amount to represent package size. For example, 1000 here would divide
            #   usage by 1000 before multiplying by package_amount in rating
            sig { returns(Integer) }
            attr_accessor :package_size

            sig { params(package_amount: String, package_size: Integer).returns(T.attached_class) }
            def self.new(package_amount:, package_size:)
            end

            sig { override.returns({package_amount: String, package_size: Integer}) }
            def to_hash
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanMatrixPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig) }
          attr_reader :matrix_config

          sig do
            params(
              matrix_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :matrix_config

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::OrSymbol,
              item_id: String,
              matrix_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig, Orb::Util::AnyHash),
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            matrix_config:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :matrix
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::OrSymbol,
                  item_id: String,
                  matrix_config: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol)
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override.returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::Cadence::TaggedSymbol])
              end
              def values
              end
            end
          end

          class MatrixConfig < Orb::BaseModel
            # Default per unit rate for any usage not bucketed into a specified matrix_value
            sig { returns(String) }
            attr_accessor :default_unit_amount

            # One or two event property values to evaluate matrix groups by
            sig { returns(T::Array[T.nilable(String)]) }
            attr_accessor :dimensions

            # Matrix values for specified matrix grouping keys
            sig { returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig::MatrixValue]) }
            attr_accessor :matrix_values

            sig do
              params(
                default_unit_amount: String,
                dimensions: T::Array[T.nilable(String)],
                matrix_values: T::Array[
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig::MatrixValue,
                  Orb::Util::AnyHash
                )
                ]
              )
                .returns(T.attached_class)
            end
            def self.new(default_unit_amount:, dimensions:, matrix_values:)
            end

            sig do
              override
                .returns(
                  {
                    default_unit_amount: String,
                    dimensions: T::Array[T.nilable(String)],
                    matrix_values: T::Array[Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::MatrixConfig::MatrixValue]
                  }
                )
            end
            def to_hash
            end

            class MatrixValue < Orb::BaseModel
              # One or two matrix keys to filter usage to this Matrix value by. For example,
              #   ["region", "tier"] could be used to filter cloud usage by a cloud region and an
              #   instance tier.
              sig { returns(T::Array[T.nilable(String)]) }
              attr_accessor :dimension_values

              # Unit price for the specified dimension_values
              sig { returns(String) }
              attr_accessor :unit_amount

              sig do
                params(
                  dimension_values: T::Array[T.nilable(String)],
                  unit_amount: String
                ).returns(T.attached_class)
              end
              def self.new(dimension_values:, unit_amount:)
              end

              sig { override.returns({dimension_values: T::Array[T.nilable(String)], unit_amount: String}) }
              def to_hash
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanTieredPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig) }
          attr_reader :tiered_config

          sig do
            params(
              tiered_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :tiered_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              tiered_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig, Orb::Util::AnyHash),
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            tiered_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :tiered
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  tiered_config: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol)
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override.returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::Cadence::TaggedSymbol])
              end
              def values
              end
            end
          end

          class TieredConfig < Orb::BaseModel
            # Tiers for rating based on total usage quantities into the specified tier
            sig { returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig::Tier]) }
            attr_accessor :tiers

            sig do
              params(
                tiers: T::Array[T.any(Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig::Tier, Orb::Util::AnyHash)]
              )
                .returns(T.attached_class)
            end
            def self.new(tiers:)
            end

            sig do
              override
                .returns({tiers: T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::TieredConfig::Tier]})
            end
            def to_hash
            end

            class Tier < Orb::BaseModel
              # Inclusive tier starting value
              sig { returns(Float) }
              attr_accessor :first_unit

              # Amount per unit
              sig { returns(String) }
              attr_accessor :unit_amount

              # Exclusive tier ending value. If null, this is treated as the last tier
              sig { returns(T.nilable(Float)) }
              attr_accessor :last_unit

              sig do
                params(
                  first_unit: Float,
                  unit_amount: String,
                  last_unit: T.nilable(Float)
                ).returns(T.attached_class)
              end
              def self.new(first_unit:, unit_amount:, last_unit: nil)
              end

              sig { override.returns({first_unit: Float, unit_amount: String, last_unit: T.nilable(Float)}) }
              def to_hash
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanTieredBpsPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig) }
          attr_reader :tiered_bps_config

          sig do
            params(
              tiered_bps_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :tiered_bps_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration)
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              tiered_bps_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig, Orb::Util::AnyHash),
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            tiered_bps_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :tiered_bps
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  tiered_bps_config: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol)
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol)
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::Cadence::TaggedSymbol])
              end
              def values
              end
            end
          end

          class TieredBpsConfig < Orb::BaseModel
            # Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
            #   tiers
            sig { returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig::Tier]) }
            attr_accessor :tiers

            sig do
              params(
                tiers: T::Array[
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig::Tier,
                  Orb::Util::AnyHash
                )
                ]
              )
                .returns(T.attached_class)
            end
            def self.new(tiers:)
            end

            sig do
              override
                .returns(
                  {tiers: T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::TieredBpsConfig::Tier]}
                )
            end
            def to_hash
            end

            class Tier < Orb::BaseModel
              # Per-event basis point rate
              sig { returns(Float) }
              attr_accessor :bps

              # Inclusive tier starting value
              sig { returns(String) }
              attr_accessor :minimum_amount

              # Exclusive tier ending value
              sig { returns(T.nilable(String)) }
              attr_accessor :maximum_amount

              # Per unit maximum to charge
              sig { returns(T.nilable(String)) }
              attr_accessor :per_unit_maximum

              sig do
                params(
                  bps: Float,
                  minimum_amount: String,
                  maximum_amount: T.nilable(String),
                  per_unit_maximum: T.nilable(String)
                )
                  .returns(T.attached_class)
              end
              def self.new(bps:, minimum_amount:, maximum_amount: nil, per_unit_maximum: nil)
              end

              sig do
                override
                  .returns(
                    {
                      bps: Float,
                      minimum_amount: String,
                      maximum_amount: T.nilable(String),
                      per_unit_maximum: T.nilable(String)
                    }
                  )
              end
              def to_hash
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanBpsPrice < Orb::BaseModel
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BpsConfig) }
          attr_reader :bps_config

          sig do
            params(
              bps_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BpsConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :bps_config

          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              bps_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BpsConfig, Orb::Util::AnyHash),
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            bps_config:,
            cadence:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :bps
          )
          end

          sig do
            override
              .returns(
                {
                  bps_config: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BpsConfig,
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          class BpsConfig < Orb::BaseModel
            # Basis point take rate per event
            sig { returns(Float) }
            attr_accessor :bps

            # Optional currency amount maximum to cap spend per event
            sig { returns(T.nilable(String)) }
            attr_accessor :per_unit_maximum

            sig { params(bps: Float, per_unit_maximum: T.nilable(String)).returns(T.attached_class) }
            def self.new(bps:, per_unit_maximum: nil)
            end

            sig { override.returns({bps: Float, per_unit_maximum: T.nilable(String)}) }
            def to_hash
            end
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol)
            MONTHLY = T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol)
            ONE_TIME = T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol)

            class << self
              sig { override.returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::Cadence::TaggedSymbol]) }
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanBulkBpsPrice < Orb::BaseModel
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig) }
          attr_reader :bulk_bps_config

          sig do
            params(
              bulk_bps_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :bulk_bps_config

          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              bulk_bps_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig, Orb::Util::AnyHash),
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            bulk_bps_config:,
            cadence:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :bulk_bps
          )
          end

          sig do
            override
              .returns(
                {
                  bulk_bps_config: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig,
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          class BulkBpsConfig < Orb::BaseModel
            # Tiers for a bulk BPS pricing model where all usage is aggregated to a single
            #   tier based on total volume
            sig { returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig::Tier]) }
            attr_accessor :tiers

            sig do
              params(
                tiers: T::Array[T.any(Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig::Tier, Orb::Util::AnyHash)]
              )
                .returns(T.attached_class)
            end
            def self.new(tiers:)
            end

            sig do
              override
                .returns({tiers: T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BulkBpsConfig::Tier]})
            end
            def to_hash
            end

            class Tier < Orb::BaseModel
              # Basis points to rate on
              sig { returns(Float) }
              attr_accessor :bps

              # Upper bound for tier
              sig { returns(T.nilable(String)) }
              attr_accessor :maximum_amount

              # The maximum amount to charge for any one event
              sig { returns(T.nilable(String)) }
              attr_accessor :per_unit_maximum

              sig do
                params(bps: Float, maximum_amount: T.nilable(String), per_unit_maximum: T.nilable(String))
                  .returns(T.attached_class)
              end
              def self.new(bps:, maximum_amount: nil, per_unit_maximum: nil)
              end

              sig do
                override.returns(
                  {
                    bps: Float,
                    maximum_amount: T.nilable(String),
                    per_unit_maximum: T.nilable(String)
                  }
                )
              end
              def to_hash
              end
            end
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol)
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::Cadence::TaggedSymbol])
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanBulkPrice < Orb::BaseModel
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig) }
          attr_reader :bulk_config

          sig do
            params(
              bulk_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig, Orb::Util::AnyHash)
            )
              .void
          end
          attr_writer :bulk_config

          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration)) }
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig { returns(T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration)) }
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              bulk_config: T.any(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig, Orb::Util::AnyHash),
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            bulk_config:,
            cadence:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :bulk
          )
          end

          sig do
            override
              .returns(
                {
                  bulk_config: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig,
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          class BulkConfig < Orb::BaseModel
            # Bulk tiers for rating based on total usage volume
            sig { returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig::Tier]) }
            attr_accessor :tiers

            sig do
              params(
                tiers: T::Array[T.any(Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig::Tier, Orb::Util::AnyHash)]
              )
                .returns(T.attached_class)
            end
            def self.new(tiers:)
            end

            sig do
              override
                .returns({tiers: T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BulkConfig::Tier]})
            end
            def to_hash
            end

            class Tier < Orb::BaseModel
              # Amount per unit
              sig { returns(String) }
              attr_accessor :unit_amount

              # Upper bound for this tier
              sig { returns(T.nilable(Float)) }
              attr_accessor :maximum_units

              sig { params(unit_amount: String, maximum_units: T.nilable(Float)).returns(T.attached_class) }
              def self.new(unit_amount:, maximum_units: nil)
              end

              sig { override.returns({unit_amount: String, maximum_units: T.nilable(Float)}) }
              def to_hash
              end
            end
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol) }

            ANNUAL = T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(:semi_annual, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol)
            MONTHLY = T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol)
            CUSTOM = T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol)

            class << self
              sig { override.returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::Cadence::TaggedSymbol]) }
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanThresholdTotalAmountPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :threshold_total_amount_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              threshold_total_amount_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            threshold_total_amount_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :threshold_total_amount
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  threshold_total_amount_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanTieredPackagePrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :tiered_package_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration)
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              tiered_package_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            tiered_package_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :tiered_package
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  tiered_package_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(:quarterly, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol)
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol)
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::Cadence::TaggedSymbol])
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanTieredWithMinimumPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :tiered_with_minimum_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              tiered_with_minimum_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            tiered_with_minimum_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :tiered_with_minimum
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  tiered_with_minimum_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanUnitWithPercentPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :unit_with_percent_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration)
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              unit_with_percent_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            unit_with_percent_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :unit_with_percent
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  unit_with_percent_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(:monthly, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol)
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(:one_time, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol)
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanPackageWithAllocationPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :package_with_allocation_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              package_with_allocation_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            package_with_allocation_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :package_with_allocation
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  package_with_allocation_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanTierWithProrationPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :tiered_with_proration_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              tiered_with_proration_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            tiered_with_proration_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :tiered_with_proration
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  tiered_with_proration_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanUnitWithProrationPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :unit_with_proration_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              unit_with_proration_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            unit_with_proration_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :unit_with_proration
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  unit_with_proration_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanGroupedAllocationPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :grouped_allocation_config

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::OrSymbol,
              grouped_allocation_config: T::Hash[Symbol, T.anything],
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            grouped_allocation_config:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :grouped_allocation
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::OrSymbol,
                  grouped_allocation_config: T::Hash[Symbol, T.anything],
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanGroupedWithProratedMinimumPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :grouped_with_prorated_minimum_config

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::OrSymbol,
              grouped_with_prorated_minimum_config: T::Hash[Symbol, T.anything],
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            grouped_with_prorated_minimum_config:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :grouped_with_prorated_minimum
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::OrSymbol,
                  grouped_with_prorated_minimum_config: T::Hash[Symbol, T.anything],
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanGroupedWithMeteredMinimumPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :grouped_with_metered_minimum_config

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::OrSymbol,
              grouped_with_metered_minimum_config: T::Hash[Symbol, T.anything],
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            grouped_with_metered_minimum_config:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :grouped_with_metered_minimum
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::OrSymbol,
                  grouped_with_metered_minimum_config: T::Hash[Symbol, T.anything],
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanMatrixWithDisplayNamePrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :matrix_with_display_name_config

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::OrSymbol,
              item_id: String,
              matrix_with_display_name_config: T::Hash[Symbol, T.anything],
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            matrix_with_display_name_config:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :matrix_with_display_name
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::OrSymbol,
                  item_id: String,
                  matrix_with_display_name_config: T::Hash[Symbol, T.anything],
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanBulkWithProrationPrice < Orb::BaseModel
          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :bulk_with_proration_config

          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration)
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              bulk_with_proration_config: T::Hash[Symbol, T.anything],
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            bulk_with_proration_config:,
            cadence:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :bulk_with_proration
          )
          end

          sig do
            override
              .returns(
                {
                  bulk_with_proration_config: T::Hash[Symbol, T.anything],
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence) }
            OrSymbol =
              T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol) }

            ANNUAL =
              T.let(:annual, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol)
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(:custom, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol)

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanGroupedTieredPackagePrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :grouped_tiered_package_config

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::OrSymbol,
              grouped_tiered_package_config: T::Hash[Symbol, T.anything],
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            grouped_tiered_package_config:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :grouped_tiered_package
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::OrSymbol,
                  grouped_tiered_package_config: T::Hash[Symbol, T.anything],
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanMaxGroupTieredPackagePrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :max_group_tiered_package_config

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::OrSymbol,
              item_id: String,
              max_group_tiered_package_config: T::Hash[Symbol, T.anything],
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            max_group_tiered_package_config:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :max_group_tiered_package
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::OrSymbol,
                  item_id: String,
                  max_group_tiered_package_config: T::Hash[Symbol, T.anything],
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanScalableMatrixWithUnitPricingPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig do
            returns(
              Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::OrSymbol
            )
          end
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :scalable_matrix_with_unit_pricing_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              scalable_matrix_with_unit_pricing_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            scalable_matrix_with_unit_pricing_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :scalable_matrix_with_unit_pricing
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  scalable_matrix_with_unit_pricing_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanScalableMatrixWithTieredPricingPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig do
            returns(
              Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::OrSymbol
            )
          end
          attr_accessor :cadence

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :scalable_matrix_with_tiered_pricing_config

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::OrSymbol,
              item_id: String,
              name: String,
              scalable_matrix_with_tiered_pricing_config: T::Hash[Symbol, T.anything],
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            item_id:,
            name:,
            scalable_matrix_with_tiered_pricing_config:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :scalable_matrix_with_tiered_pricing
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::OrSymbol,
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  scalable_matrix_with_tiered_pricing_config: T::Hash[Symbol, T.anything],
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class NewPlanCumulativeGroupedBulkPrice < Orb::BaseModel
          # The cadence to bill for this price on.
          sig { returns(Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::OrSymbol) }
          attr_accessor :cadence

          sig { returns(T::Hash[Symbol, T.anything]) }
          attr_accessor :cumulative_grouped_bulk_config

          # The id of the item the price will be associated with.
          sig { returns(String) }
          attr_accessor :item_id

          sig { returns(Symbol) }
          attr_accessor :model_type

          # The name of the price.
          sig { returns(String) }
          attr_accessor :name

          # The id of the billable metric for the price. Only needed if the price is
          #   usage-based.
          sig { returns(T.nilable(String)) }
          attr_accessor :billable_metric_id

          # If the Price represents a fixed cost, the price will be billed in-advance if
          #   this is true, and in-arrears if this is false.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :billed_in_advance

          # For custom cadence: specifies the duration of the billing period in days or
          #   months.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration
              )
            )
          end
          attr_reader :billing_cycle_configuration

          sig do
            params(
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :billing_cycle_configuration

          # The per unit conversion rate of the price currency to the invoicing currency.
          sig { returns(T.nilable(Float)) }
          attr_accessor :conversion_rate

          # An ISO 4217 currency string, or custom pricing unit identifier, in which this
          #   price is billed.
          sig { returns(T.nilable(String)) }
          attr_accessor :currency

          # An alias for the price.
          sig { returns(T.nilable(String)) }
          attr_accessor :external_price_id

          # If the Price represents a fixed cost, this represents the quantity of units
          #   applied.
          sig { returns(T.nilable(Float)) }
          attr_accessor :fixed_price_quantity

          # The property used to group this price on an invoice
          sig { returns(T.nilable(String)) }
          attr_accessor :invoice_grouping_key

          # Within each billing cycle, specifies the cadence at which invoices are produced.
          #   If unspecified, a single invoice is produced per billing cycle.
          sig do
            returns(
              T.nilable(
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration
              )
            )
          end
          attr_reader :invoicing_cycle_configuration

          sig do
            params(
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              )
            )
              .void
          end
          attr_writer :invoicing_cycle_configuration

          # User-specified key/value pairs for the resource. Individual keys can be removed
          #   by setting the value to `null`, and the entire metadata mapping can be cleared
          #   by setting `metadata` to `null`.
          sig { returns(T.nilable(T::Hash[Symbol, T.nilable(String)])) }
          attr_accessor :metadata

          sig do
            params(
              cadence: Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::OrSymbol,
              cumulative_grouped_bulk_config: T::Hash[Symbol, T.anything],
              item_id: String,
              name: String,
              billable_metric_id: T.nilable(String),
              billed_in_advance: T.nilable(T::Boolean),
              billing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              conversion_rate: T.nilable(Float),
              currency: T.nilable(String),
              external_price_id: T.nilable(String),
              fixed_price_quantity: T.nilable(Float),
              invoice_grouping_key: T.nilable(String),
              invoicing_cycle_configuration: T.nilable(
                T.any(
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration,
                  Orb::Util::AnyHash
                )
              ),
              metadata: T.nilable(T::Hash[Symbol, T.nilable(String)]),
              model_type: Symbol
            )
              .returns(T.attached_class)
          end
          def self.new(
            cadence:,
            cumulative_grouped_bulk_config:,
            item_id:,
            name:,
            billable_metric_id: nil,
            billed_in_advance: nil,
            billing_cycle_configuration: nil,
            conversion_rate: nil,
            currency: nil,
            external_price_id: nil,
            fixed_price_quantity: nil,
            invoice_grouping_key: nil,
            invoicing_cycle_configuration: nil,
            metadata: nil,
            model_type: :cumulative_grouped_bulk
          )
          end

          sig do
            override
              .returns(
                {
                  cadence: Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::OrSymbol,
                  cumulative_grouped_bulk_config: T::Hash[Symbol, T.anything],
                  item_id: String,
                  model_type: Symbol,
                  name: String,
                  billable_metric_id: T.nilable(String),
                  billed_in_advance: T.nilable(T::Boolean),
                  billing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration
                  ),
                  conversion_rate: T.nilable(Float),
                  currency: T.nilable(String),
                  external_price_id: T.nilable(String),
                  fixed_price_quantity: T.nilable(Float),
                  invoice_grouping_key: T.nilable(String),
                  invoicing_cycle_configuration: T.nilable(
                    Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration
                  ),
                  metadata: T.nilable(T::Hash[Symbol, T.nilable(String)])
                }
              )
          end
          def to_hash
          end

          # The cadence to bill for this price on.
          module Cadence
            extend Orb::Enum

            TaggedSymbol =
              T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence) }
            OrSymbol =
              T.type_alias do
                T.any(
                  Symbol,
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
                )
              end

            ANNUAL =
              T.let(
                :annual,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
              )
            SEMI_ANNUAL =
              T.let(
                :semi_annual,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
              )
            MONTHLY =
              T.let(
                :monthly,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
              )
            QUARTERLY =
              T.let(
                :quarterly,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
              )
            ONE_TIME =
              T.let(
                :one_time,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
              )
            CUSTOM =
              T.let(
                :custom,
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol
              )

            class << self
              sig do
                override
                  .returns(
                    T::Array[Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::Cadence::TaggedSymbol]
                  )
              end
              def values
              end
            end
          end

          class BillingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # For custom cadence: specifies the duration of the billing period in days or
            #   months.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::BillingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end

          class InvoicingCycleConfiguration < Orb::BaseModel
            # The duration of the billing period.
            sig { returns(Integer) }
            attr_accessor :duration

            # The unit of billing period duration.
            sig do
              returns(
                Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
            end
            attr_accessor :duration_unit

            # Within each billing cycle, specifies the cadence at which invoices are produced.
            #   If unspecified, a single invoice is produced per billing cycle.
            sig do
              params(
                duration: Integer,
                duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
              )
                .returns(T.attached_class)
            end
            def self.new(duration:, duration_unit:)
            end

            sig do
              override
                .returns(
                  {
                    duration: Integer,
                    duration_unit: Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::OrSymbol
                  }
                )
            end
            def to_hash
            end

            # The unit of billing period duration.
            module DurationUnit
              extend Orb::Enum

              TaggedSymbol =
                T.type_alias do
                  T.all(Symbol, Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit)
                end
              OrSymbol =
                T.type_alias do
                  T.any(
                    Symbol,
                    Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                  )
                end

              DAY =
                T.let(
                  :day,
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )
              MONTH =
                T.let(
                  :month,
                  Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                )

              class << self
                sig do
                  override
                    .returns(
                      T::Array[
                      Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice::InvoicingCycleConfiguration::DurationUnit::TaggedSymbol
                      ]
                    )
                end
                def values
                end
              end
            end
          end
        end

        class << self
          sig do
            override
              .returns(
                [Orb::Models::PlanCreateParams::Price::NewPlanUnitPrice, Orb::Models::PlanCreateParams::Price::NewPlanPackagePrice, Orb::Models::PlanCreateParams::Price::NewPlanMatrixPrice, Orb::Models::PlanCreateParams::Price::NewPlanTieredPrice, Orb::Models::PlanCreateParams::Price::NewPlanTieredBpsPrice, Orb::Models::PlanCreateParams::Price::NewPlanBpsPrice, Orb::Models::PlanCreateParams::Price::NewPlanBulkBpsPrice, Orb::Models::PlanCreateParams::Price::NewPlanBulkPrice, Orb::Models::PlanCreateParams::Price::NewPlanThresholdTotalAmountPrice, Orb::Models::PlanCreateParams::Price::NewPlanTieredPackagePrice, Orb::Models::PlanCreateParams::Price::NewPlanTieredWithMinimumPrice, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithPercentPrice, Orb::Models::PlanCreateParams::Price::NewPlanPackageWithAllocationPrice, Orb::Models::PlanCreateParams::Price::NewPlanTierWithProrationPrice, Orb::Models::PlanCreateParams::Price::NewPlanUnitWithProrationPrice, Orb::Models::PlanCreateParams::Price::NewPlanGroupedAllocationPrice, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithProratedMinimumPrice, Orb::Models::PlanCreateParams::Price::NewPlanGroupedWithMeteredMinimumPrice, Orb::Models::PlanCreateParams::Price::NewPlanMatrixWithDisplayNamePrice, Orb::Models::PlanCreateParams::Price::NewPlanBulkWithProrationPrice, Orb::Models::PlanCreateParams::Price::NewPlanGroupedTieredPackagePrice, Orb::Models::PlanCreateParams::Price::NewPlanMaxGroupTieredPackagePrice, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithUnitPricingPrice, Orb::Models::PlanCreateParams::Price::NewPlanScalableMatrixWithTieredPricingPrice, Orb::Models::PlanCreateParams::Price::NewPlanCumulativeGroupedBulkPrice]
              )
          end
          def variants
          end
        end
      end

      # The status of the plan to create (either active or draft). If not specified,
      #   this defaults to active.
      module Status
        extend Orb::Enum

        TaggedSymbol = T.type_alias { T.all(Symbol, Orb::Models::PlanCreateParams::Status) }
        OrSymbol = T.type_alias { T.any(Symbol, Orb::Models::PlanCreateParams::Status::TaggedSymbol) }

        ACTIVE = T.let(:active, Orb::Models::PlanCreateParams::Status::TaggedSymbol)
        DRAFT = T.let(:draft, Orb::Models::PlanCreateParams::Status::TaggedSymbol)

        class << self
          sig { override.returns(T::Array[Orb::Models::PlanCreateParams::Status::TaggedSymbol]) }
          def values
          end
        end
      end
    end
  end
end
