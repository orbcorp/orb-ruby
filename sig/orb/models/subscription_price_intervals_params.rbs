module Orb
  module Models
    type subscription_price_intervals_params =
      {
        add: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add],
        add_adjustments: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment],
        edit: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit],
        edit_adjustments: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment]
      }
      & Orb::request_parameters

    class SubscriptionPriceIntervalsParams < Orb::BaseModel
      extend Orb::RequestParameters::Converter
      include Orb::RequestParameters

      attr_reader add: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add]?

      def add=: (
        ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add]
      ) -> void

      attr_reader add_adjustments: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment]?

      def add_adjustments=: (
        ::Array[Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment]
      ) -> void

      attr_reader edit: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit]?

      def edit=: (
        ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit]
      ) -> void

      attr_reader edit_adjustments: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment]?

      def edit_adjustments=: (
        ::Array[Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment]
      ) -> void

      def initialize:
        (
          add: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add],
          add_adjustments: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment],
          edit: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit],
          edit_adjustments: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment],
          request_options: Orb::request_opts
        ) -> void
        | (
          ?Orb::Models::subscription_price_intervals_params
          | Orb::BaseModel data
        ) -> void

      def to_hash: -> Orb::Models::subscription_price_intervals_params

      type add =
        {
          start_date: Orb::Models::SubscriptionPriceIntervalsParams::Add::start_date,
          allocation_price: Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice?,
          discounts: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::discount]?,
          end_date: Orb::Models::SubscriptionPriceIntervalsParams::Add::end_date?,
          external_price_id: String?,
          fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::FixedFeeQuantityTransition]?,
          maximum_amount: Float?,
          minimum_amount: Float?,
          price: Orb::Models::SubscriptionPriceIntervalsParams::Add::price?,
          price_id: String?
        }

      class Add < Orb::BaseModel
        attr_accessor start_date: Orb::Models::SubscriptionPriceIntervalsParams::Add::start_date

        attr_accessor allocation_price: Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice?

        attr_accessor discounts: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::discount]?

        attr_accessor end_date: Orb::Models::SubscriptionPriceIntervalsParams::Add::end_date?

        attr_accessor external_price_id: String?

        attr_accessor fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::FixedFeeQuantityTransition]?

        attr_accessor maximum_amount: Float?

        attr_accessor minimum_amount: Float?

        attr_accessor price: Orb::Models::SubscriptionPriceIntervalsParams::Add::price?

        attr_accessor price_id: String?

        def initialize:
          (
            start_date: Orb::Models::SubscriptionPriceIntervalsParams::Add::start_date,
            allocation_price: Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice?,
            discounts: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::discount]?,
            end_date: Orb::Models::SubscriptionPriceIntervalsParams::Add::end_date?,
            external_price_id: String?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::FixedFeeQuantityTransition]?,
            maximum_amount: Float?,
            minimum_amount: Float?,
            price: Orb::Models::SubscriptionPriceIntervalsParams::Add::price?,
            price_id: String?
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsParams::add
            | Orb::BaseModel data
          ) -> void

        def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::add

        type start_date = Time | Orb::Models::billing_cycle_relative_date

        class StartDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end

        type allocation_price =
          {
            amount: String,
            cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice::cadence,
            currency: String,
            expires_at_end_of_cadence: bool
          }

        class AllocationPrice < Orb::BaseModel
          attr_accessor amount: String

          attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice::cadence

          attr_accessor currency: String

          attr_accessor expires_at_end_of_cadence: bool

          def initialize:
            (
              amount: String,
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice::cadence,
              currency: String,
              expires_at_end_of_cadence: bool
            ) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsParams::Add::allocation_price
              | Orb::BaseModel data
            ) -> void

          def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::allocation_price

          type cadence =
            :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

          class Cadence < Orb::Enum
            ONE_TIME: :one_time
            MONTHLY: :monthly
            QUARTERLY: :quarterly
            SEMI_ANNUAL: :semi_annual
            ANNUAL: :annual
            CUSTOM: :custom

            def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::AllocationPrice::cadence]
          end
        end

        type discount =
          Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::AmountDiscountCreationParams
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::PercentageDiscountCreationParams
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::UsageDiscountCreationParams

        class Discount < Orb::Union
          type amount_discount_creation_params =
            { amount_discount: Float, discount_type: :amount }

          class AmountDiscountCreationParams < Orb::BaseModel
            attr_accessor amount_discount: Float

            attr_accessor discount_type: :amount

            def initialize:
              (amount_discount: Float, discount_type: :amount) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::amount_discount_creation_params
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::amount_discount_creation_params
          end

          type percentage_discount_creation_params =
            { discount_type: :percentage, percentage_discount: Float }

          class PercentageDiscountCreationParams < Orb::BaseModel
            attr_accessor discount_type: :percentage

            attr_accessor percentage_discount: Float

            def initialize:
              (percentage_discount: Float, discount_type: :percentage) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::percentage_discount_creation_params
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::percentage_discount_creation_params
          end

          type usage_discount_creation_params =
            { discount_type: :usage, usage_discount: Float }

          class UsageDiscountCreationParams < Orb::BaseModel
            attr_accessor discount_type: :usage

            attr_accessor usage_discount: Float

            def initialize:
              (usage_discount: Float, discount_type: :usage) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::usage_discount_creation_params
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::usage_discount_creation_params
          end

          private def self.variants: -> [[:amount, Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::AmountDiscountCreationParams], [:percentage, Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::PercentageDiscountCreationParams], [:usage, Orb::Models::SubscriptionPriceIntervalsParams::Add::Discount::UsageDiscountCreationParams]]
        end

        type end_date = Time | Orb::Models::billing_cycle_relative_date

        class EndDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end

        type fixed_fee_quantity_transition =
          { effective_date: Time, quantity: Integer }

        class FixedFeeQuantityTransition < Orb::BaseModel
          attr_accessor effective_date: Time

          attr_accessor quantity: Integer

          def initialize:
            (effective_date: Time, quantity: Integer) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsParams::Add::fixed_fee_quantity_transition
              | Orb::BaseModel data
            ) -> void

          def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::fixed_fee_quantity_transition
        end

        type price =
          Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice
          | Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice

        class Price < Orb::Union
          type new_floating_unit_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :unit,
              name: String,
              unit_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::UnitConfig,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingUnitPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :unit

            attr_accessor name: String

            attr_accessor unit_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::UnitConfig

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                unit_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::UnitConfig,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :unit
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_unit_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_unit_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::cadence]
            end

            type unit_config = { unit_amount: String }

            class UnitConfig < Orb::BaseModel
              attr_accessor unit_amount: String

              def initialize:
                (unit_amount: String) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::unit_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::unit_config
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_package_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::cadence,
              currency: String,
              item_id: String,
              model_type: :package,
              name: String,
              package_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::PackageConfig,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingPackagePrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :package

            attr_accessor name: String

            attr_accessor package_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::PackageConfig

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                package_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::PackageConfig,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :package
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_package_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_package_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::cadence]
            end

            type package_config =
              { package_amount: String, package_size: Integer }

            class PackageConfig < Orb::BaseModel
              attr_accessor package_amount: String

              attr_accessor package_size: Integer

              def initialize:
                (package_amount: String, package_size: Integer) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::package_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::package_config
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_matrix_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::cadence,
              currency: String,
              item_id: String,
              matrix_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig,
              model_type: :matrix,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingMatrixPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor matrix_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig

            attr_accessor model_type: :matrix

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::cadence,
                currency: String,
                item_id: String,
                matrix_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :matrix
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_matrix_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_matrix_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::cadence]
            end

            type matrix_config =
              {
                default_unit_amount: String,
                dimensions: ::Array[String?],
                matrix_values: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig::MatrixValue]
              }

            class MatrixConfig < Orb::BaseModel
              attr_accessor default_unit_amount: String

              attr_accessor dimensions: ::Array[String?]

              attr_accessor matrix_values: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig::MatrixValue]

              def initialize:
                (
                  default_unit_amount: String,
                  dimensions: ::Array[String?],
                  matrix_values: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig::MatrixValue]
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::matrix_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::matrix_config

              type matrix_value =
                { dimension_values: ::Array[String?], unit_amount: String }

              class MatrixValue < Orb::BaseModel
                attr_accessor dimension_values: ::Array[String?]

                attr_accessor unit_amount: String

                def initialize:
                  (
                    dimension_values: ::Array[String?],
                    unit_amount: String
                  ) -> void
                  | (
                    ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig::matrix_value
                    | Orb::BaseModel data
                  ) -> void

                def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::MatrixConfig::matrix_value
              end
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_matrix_with_allocation_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::cadence,
              currency: String,
              item_id: String,
              matrix_with_allocation_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig,
              model_type: :matrix_with_allocation,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingMatrixWithAllocationPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor matrix_with_allocation_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig

            attr_accessor model_type: :matrix_with_allocation

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::cadence,
                currency: String,
                item_id: String,
                matrix_with_allocation_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :matrix_with_allocation
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_matrix_with_allocation_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_matrix_with_allocation_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::cadence]
            end

            type matrix_with_allocation_config =
              {
                allocation: Float,
                default_unit_amount: String,
                dimensions: ::Array[String?],
                matrix_values: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig::MatrixValue]
              }

            class MatrixWithAllocationConfig < Orb::BaseModel
              attr_accessor allocation: Float

              attr_accessor default_unit_amount: String

              attr_accessor dimensions: ::Array[String?]

              attr_accessor matrix_values: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig::MatrixValue]

              def initialize:
                (
                  allocation: Float,
                  default_unit_amount: String,
                  dimensions: ::Array[String?],
                  matrix_values: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig::MatrixValue]
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::matrix_with_allocation_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::matrix_with_allocation_config

              type matrix_value =
                { dimension_values: ::Array[String?], unit_amount: String }

              class MatrixValue < Orb::BaseModel
                attr_accessor dimension_values: ::Array[String?]

                attr_accessor unit_amount: String

                def initialize:
                  (
                    dimension_values: ::Array[String?],
                    unit_amount: String
                  ) -> void
                  | (
                    ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig::matrix_value
                    | Orb::BaseModel data
                  ) -> void

                def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::MatrixWithAllocationConfig::matrix_value
              end
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_tiered_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :tiered,
              name: String,
              tiered_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingTieredPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :tiered

            attr_accessor name: String

            attr_accessor tiered_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                tiered_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :tiered
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::cadence]
            end

            type tiered_config =
              {
                tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig::Tier]
              }

            class TieredConfig < Orb::BaseModel
              attr_accessor tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig::Tier]

              def initialize:
                (
                  tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig::Tier]
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::tiered_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::tiered_config

              type tier =
                { first_unit: Float, unit_amount: String, last_unit: Float? }

              class Tier < Orb::BaseModel
                attr_accessor first_unit: Float

                attr_accessor unit_amount: String

                attr_accessor last_unit: Float?

                def initialize:
                  (
                    first_unit: Float,
                    unit_amount: String,
                    last_unit: Float?
                  ) -> void
                  | (
                    ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig::tier
                    | Orb::BaseModel data
                  ) -> void

                def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::TieredConfig::tier
              end
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_tiered_bps_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :tiered_bps,
              name: String,
              tiered_bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingTieredBpsPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :tiered_bps

            attr_accessor name: String

            attr_accessor tiered_bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                tiered_bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :tiered_bps
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_bps_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_bps_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::cadence]
            end

            type tiered_bps_config =
              {
                tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig::Tier]
              }

            class TieredBpsConfig < Orb::BaseModel
              attr_accessor tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig::Tier]

              def initialize:
                (
                  tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig::Tier]
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::tiered_bps_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::tiered_bps_config

              type tier =
                {
                  bps: Float,
                  minimum_amount: String,
                  maximum_amount: String?,
                  per_unit_maximum: String?
                }

              class Tier < Orb::BaseModel
                attr_accessor bps: Float

                attr_accessor minimum_amount: String

                attr_accessor maximum_amount: String?

                attr_accessor per_unit_maximum: String?

                def initialize:
                  (
                    bps: Float,
                    minimum_amount: String,
                    maximum_amount: String?,
                    per_unit_maximum: String?
                  ) -> void
                  | (
                    ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig::tier
                    | Orb::BaseModel data
                  ) -> void

                def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::TieredBpsConfig::tier
              end
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_bps_price =
            {
              bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BpsConfig,
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :bps,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingBpsPrice < Orb::BaseModel
            attr_accessor bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BpsConfig

            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :bps

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BpsConfig,
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :bps
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bps_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bps_price

            type bps_config = { bps: Float, per_unit_maximum: String? }

            class BpsConfig < Orb::BaseModel
              attr_accessor bps: Float

              attr_accessor per_unit_maximum: String?

              def initialize:
                (bps: Float, per_unit_maximum: String?) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::bps_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::bps_config
            end

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_bulk_bps_price =
            {
              bulk_bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig,
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :bulk_bps,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingBulkBpsPrice < Orb::BaseModel
            attr_accessor bulk_bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig

            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :bulk_bps

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                bulk_bps_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig,
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :bulk_bps
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bulk_bps_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bulk_bps_price

            type bulk_bps_config =
              {
                tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig::Tier]
              }

            class BulkBpsConfig < Orb::BaseModel
              attr_accessor tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig::Tier]

              def initialize:
                (
                  tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig::Tier]
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::bulk_bps_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::bulk_bps_config

              type tier =
                {
                  bps: Float,
                  maximum_amount: String?,
                  per_unit_maximum: String?
                }

              class Tier < Orb::BaseModel
                attr_accessor bps: Float

                attr_accessor maximum_amount: String?

                attr_accessor per_unit_maximum: String?

                def initialize:
                  (
                    bps: Float,
                    maximum_amount: String?,
                    per_unit_maximum: String?
                  ) -> void
                  | (
                    ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig::tier
                    | Orb::BaseModel data
                  ) -> void

                def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BulkBpsConfig::tier
              end
            end

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_bulk_price =
            {
              bulk_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig,
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :bulk,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingBulkPrice < Orb::BaseModel
            attr_accessor bulk_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig

            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :bulk

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                bulk_config: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig,
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :bulk
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bulk_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bulk_price

            type bulk_config =
              {
                tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig::Tier]
              }

            class BulkConfig < Orb::BaseModel
              attr_accessor tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig::Tier]

              def initialize:
                (
                  tiers: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig::Tier]
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::bulk_config
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::bulk_config

              type tier = { unit_amount: String, maximum_units: Float? }

              class Tier < Orb::BaseModel
                attr_accessor unit_amount: String

                attr_accessor maximum_units: Float?

                def initialize:
                  (unit_amount: String, maximum_units: Float?) -> void
                  | (
                    ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig::tier
                    | Orb::BaseModel data
                  ) -> void

                def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BulkConfig::tier
              end
            end

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_threshold_total_amount_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :threshold_total_amount,
              name: String,
              threshold_total_amount_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingThresholdTotalAmountPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :threshold_total_amount

            attr_accessor name: String

            attr_accessor threshold_total_amount_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                threshold_total_amount_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :threshold_total_amount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_threshold_total_amount_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_threshold_total_amount_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_tiered_package_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::cadence,
              currency: String,
              item_id: String,
              model_type: :tiered_package,
              name: String,
              tiered_package_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingTieredPackagePrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :tiered_package

            attr_accessor name: String

            attr_accessor tiered_package_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                tiered_package_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :tiered_package
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_package_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_package_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_grouped_tiered_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::cadence,
              currency: String,
              grouped_tiered_config: ::Hash[Symbol, top],
              item_id: String,
              model_type: :grouped_tiered,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingGroupedTieredPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::cadence

            attr_accessor currency: String

            attr_accessor grouped_tiered_config: ::Hash[Symbol, top]

            attr_accessor item_id: String

            attr_accessor model_type: :grouped_tiered

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::cadence,
                currency: String,
                grouped_tiered_config: ::Hash[Symbol, top],
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :grouped_tiered
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_tiered_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_tiered_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_max_group_tiered_package_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::cadence,
              currency: String,
              item_id: String,
              max_group_tiered_package_config: ::Hash[Symbol, top],
              model_type: :max_group_tiered_package,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingMaxGroupTieredPackagePrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor max_group_tiered_package_config: ::Hash[Symbol, top]

            attr_accessor model_type: :max_group_tiered_package

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::cadence,
                currency: String,
                item_id: String,
                max_group_tiered_package_config: ::Hash[Symbol, top],
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :max_group_tiered_package
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_max_group_tiered_package_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_max_group_tiered_package_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_tiered_with_minimum_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :tiered_with_minimum,
              name: String,
              tiered_with_minimum_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingTieredWithMinimumPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :tiered_with_minimum

            attr_accessor name: String

            attr_accessor tiered_with_minimum_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                tiered_with_minimum_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :tiered_with_minimum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_with_minimum_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_with_minimum_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_package_with_allocation_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :package_with_allocation,
              name: String,
              package_with_allocation_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingPackageWithAllocationPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :package_with_allocation

            attr_accessor name: String

            attr_accessor package_with_allocation_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                package_with_allocation_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :package_with_allocation
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_package_with_allocation_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_package_with_allocation_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_tiered_package_with_minimum_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :tiered_package_with_minimum,
              name: String,
              tiered_package_with_minimum_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingTieredPackageWithMinimumPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :tiered_package_with_minimum

            attr_accessor name: String

            attr_accessor tiered_package_with_minimum_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                tiered_package_with_minimum_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :tiered_package_with_minimum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_package_with_minimum_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_package_with_minimum_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_unit_with_percent_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :unit_with_percent,
              name: String,
              unit_with_percent_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingUnitWithPercentPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :unit_with_percent

            attr_accessor name: String

            attr_accessor unit_with_percent_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                unit_with_percent_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :unit_with_percent
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_unit_with_percent_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_unit_with_percent_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_tiered_with_proration_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :tiered_with_proration,
              name: String,
              tiered_with_proration_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingTieredWithProrationPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :tiered_with_proration

            attr_accessor name: String

            attr_accessor tiered_with_proration_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                tiered_with_proration_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :tiered_with_proration
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_with_proration_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_tiered_with_proration_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_unit_with_proration_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :unit_with_proration,
              name: String,
              unit_with_proration_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingUnitWithProrationPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :unit_with_proration

            attr_accessor name: String

            attr_accessor unit_with_proration_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                unit_with_proration_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :unit_with_proration
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_unit_with_proration_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_unit_with_proration_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_grouped_allocation_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::cadence,
              currency: String,
              grouped_allocation_config: ::Hash[Symbol, top],
              item_id: String,
              model_type: :grouped_allocation,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingGroupedAllocationPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::cadence

            attr_accessor currency: String

            attr_accessor grouped_allocation_config: ::Hash[Symbol, top]

            attr_accessor item_id: String

            attr_accessor model_type: :grouped_allocation

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::cadence,
                currency: String,
                grouped_allocation_config: ::Hash[Symbol, top],
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :grouped_allocation
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_allocation_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_allocation_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_grouped_with_prorated_minimum_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::cadence,
              currency: String,
              grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
              item_id: String,
              model_type: :grouped_with_prorated_minimum,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingGroupedWithProratedMinimumPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::cadence

            attr_accessor currency: String

            attr_accessor grouped_with_prorated_minimum_config: ::Hash[Symbol, top]

            attr_accessor item_id: String

            attr_accessor model_type: :grouped_with_prorated_minimum

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::cadence,
                currency: String,
                grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :grouped_with_prorated_minimum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_with_prorated_minimum_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_with_prorated_minimum_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_grouped_with_metered_minimum_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::cadence,
              currency: String,
              grouped_with_metered_minimum_config: ::Hash[Symbol, top],
              item_id: String,
              model_type: :grouped_with_metered_minimum,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingGroupedWithMeteredMinimumPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::cadence

            attr_accessor currency: String

            attr_accessor grouped_with_metered_minimum_config: ::Hash[Symbol, top]

            attr_accessor item_id: String

            attr_accessor model_type: :grouped_with_metered_minimum

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::cadence,
                currency: String,
                grouped_with_metered_minimum_config: ::Hash[Symbol, top],
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :grouped_with_metered_minimum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_with_metered_minimum_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_with_metered_minimum_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_matrix_with_display_name_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::cadence,
              currency: String,
              item_id: String,
              matrix_with_display_name_config: ::Hash[Symbol, top],
              model_type: :matrix_with_display_name,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingMatrixWithDisplayNamePrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor matrix_with_display_name_config: ::Hash[Symbol, top]

            attr_accessor model_type: :matrix_with_display_name

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::cadence,
                currency: String,
                item_id: String,
                matrix_with_display_name_config: ::Hash[Symbol, top],
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :matrix_with_display_name
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_matrix_with_display_name_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_matrix_with_display_name_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_bulk_with_proration_price =
            {
              bulk_with_proration_config: ::Hash[Symbol, top],
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :bulk_with_proration,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingBulkWithProrationPrice < Orb::BaseModel
            attr_accessor bulk_with_proration_config: ::Hash[Symbol, top]

            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :bulk_with_proration

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                bulk_with_proration_config: ::Hash[Symbol, top],
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :bulk_with_proration
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bulk_with_proration_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_bulk_with_proration_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_grouped_tiered_package_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::cadence,
              currency: String,
              grouped_tiered_package_config: ::Hash[Symbol, top],
              item_id: String,
              model_type: :grouped_tiered_package,
              name: String,
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingGroupedTieredPackagePrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::cadence

            attr_accessor currency: String

            attr_accessor grouped_tiered_package_config: ::Hash[Symbol, top]

            attr_accessor item_id: String

            attr_accessor model_type: :grouped_tiered_package

            attr_accessor name: String

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::cadence,
                currency: String,
                grouped_tiered_package_config: ::Hash[Symbol, top],
                item_id: String,
                name: String,
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :grouped_tiered_package
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_tiered_package_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_grouped_tiered_package_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_scalable_matrix_with_unit_pricing_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :scalable_matrix_with_unit_pricing,
              name: String,
              scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingScalableMatrixWithUnitPricingPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :scalable_matrix_with_unit_pricing

            attr_accessor name: String

            attr_accessor scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :scalable_matrix_with_unit_pricing
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_scalable_matrix_with_unit_pricing_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_scalable_matrix_with_unit_pricing_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          type new_floating_scalable_matrix_with_tiered_pricing_price =
            {
              cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::cadence,
              currency: String,
              item_id: String,
              model_type: :scalable_matrix_with_tiered_pricing,
              name: String,
              scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
              billable_metric_id: String?,
              billed_in_advance: bool?,
              billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration?,
              conversion_rate: Float?,
              external_price_id: String?,
              fixed_price_quantity: Float?,
              invoice_grouping_key: String?,
              invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration?,
              metadata: ::Hash[Symbol, String?]?
            }

          class NewFloatingScalableMatrixWithTieredPricingPrice < Orb::BaseModel
            attr_accessor cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::cadence

            attr_accessor currency: String

            attr_accessor item_id: String

            attr_accessor model_type: :scalable_matrix_with_tiered_pricing

            attr_accessor name: String

            attr_accessor scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top]

            attr_accessor billable_metric_id: String?

            attr_accessor billed_in_advance: bool?

            attr_accessor billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration?

            attr_accessor conversion_rate: Float?

            attr_accessor external_price_id: String?

            attr_accessor fixed_price_quantity: Float?

            attr_accessor invoice_grouping_key: String?

            attr_accessor invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration?

            attr_accessor metadata: ::Hash[Symbol, String?]?

            def initialize:
              (
                cadence: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::cadence,
                currency: String,
                item_id: String,
                name: String,
                scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
                billable_metric_id: String?,
                billed_in_advance: bool?,
                billing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration?,
                conversion_rate: Float?,
                external_price_id: String?,
                fixed_price_quantity: Float?,
                invoice_grouping_key: String?,
                invoicing_cycle_configuration: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration?,
                metadata: ::Hash[Symbol, String?]?,
                model_type: :scalable_matrix_with_tiered_pricing
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_scalable_matrix_with_tiered_pricing_price
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::new_floating_scalable_matrix_with_tiered_pricing_price

            type cadence =
              :annual
              | :semi_annual
              | :monthly
              | :quarterly
              | :one_time
              | :custom

            class Cadence < Orb::Enum
              ANNUAL: :annual
              SEMI_ANNUAL: :semi_annual
              MONTHLY: :monthly
              QUARTERLY: :quarterly
              ONE_TIME: :one_time
              CUSTOM: :custom

              def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::cadence]
            end

            type billing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit
              }

            class BillingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::billing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::billing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit]
              end
            end

            type invoicing_cycle_configuration =
              {
                duration: Integer,
                duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit
              }

            class InvoicingCycleConfiguration < Orb::BaseModel
              attr_accessor duration: Integer

              attr_accessor duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit

              def initialize:
                (
                  duration: Integer,
                  duration_unit: Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit
                ) -> void
                | (
                  ?Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::invoicing_cycle_configuration
                  | Orb::BaseModel data
                ) -> void

              def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::invoicing_cycle_configuration

              type duration_unit = :day | :month

              class DurationUnit < Orb::Enum
                DAY: :day
                MONTH: :month

                def self.values: -> ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit]
              end
            end
          end

          private def self.variants: -> [[:unit, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitPrice], [:package, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackagePrice], [:matrix, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixPrice], [:matrix_with_allocation, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithAllocationPrice], [:tiered, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPrice], [:tiered_bps, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredBpsPrice], [:bps, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBpsPrice], [:bulk_bps, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkBpsPrice], [:bulk, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkPrice], [:threshold_total_amount, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingThresholdTotalAmountPrice], [:tiered_package, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackagePrice], [:grouped_tiered, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPrice], [:max_group_tiered_package, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMaxGroupTieredPackagePrice], [:tiered_with_minimum, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithMinimumPrice], [:package_with_allocation, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingPackageWithAllocationPrice], [:tiered_package_with_minimum, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredPackageWithMinimumPrice], [:unit_with_percent, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithPercentPrice], [:tiered_with_proration, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingTieredWithProrationPrice], [:unit_with_proration, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingUnitWithProrationPrice], [:grouped_allocation, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedAllocationPrice], [:grouped_with_prorated_minimum, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithProratedMinimumPrice], [:grouped_with_metered_minimum, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedWithMeteredMinimumPrice], [:matrix_with_display_name, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingMatrixWithDisplayNamePrice], [:bulk_with_proration, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingBulkWithProrationPrice], [:grouped_tiered_package, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingGroupedTieredPackagePrice], [:scalable_matrix_with_unit_pricing, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithUnitPricingPrice], [:scalable_matrix_with_tiered_pricing, Orb::Models::SubscriptionPriceIntervalsParams::Add::Price::NewFloatingScalableMatrixWithTieredPricingPrice]]
        end
      end

      type add_adjustment =
        {
          adjustment: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::adjustment,
          start_date: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::start_date,
          end_date: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::end_date?
        }

      class AddAdjustment < Orb::BaseModel
        attr_accessor adjustment: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::adjustment

        attr_accessor start_date: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::start_date

        attr_accessor end_date: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::end_date?

        def initialize:
          (
            adjustment: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::adjustment,
            start_date: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::start_date,
            end_date: Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::end_date?
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsParams::add_adjustment
            | Orb::BaseModel data
          ) -> void

        def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::add_adjustment

        type adjustment =
          Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewPercentageDiscount
          | Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewUsageDiscount
          | Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewAmountDiscount
          | Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewMinimum
          | Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewMaximum

        class Adjustment < Orb::Union
          type new_percentage_discount =
            {
              adjustment_type: :percentage_discount,
              applies_to_price_ids: ::Array[String],
              percentage_discount: Float,
              is_invoice_level: bool
            }

          class NewPercentageDiscount < Orb::BaseModel
            attr_accessor adjustment_type: :percentage_discount

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor percentage_discount: Float

            attr_reader is_invoice_level: bool?

            def is_invoice_level=: (bool) -> void

            def initialize:
              (
                applies_to_price_ids: ::Array[String],
                percentage_discount: Float,
                is_invoice_level: bool,
                adjustment_type: :percentage_discount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_percentage_discount
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_percentage_discount
          end

          type new_usage_discount =
            {
              adjustment_type: :usage_discount,
              applies_to_price_ids: ::Array[String],
              usage_discount: Float,
              is_invoice_level: bool
            }

          class NewUsageDiscount < Orb::BaseModel
            attr_accessor adjustment_type: :usage_discount

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor usage_discount: Float

            attr_reader is_invoice_level: bool?

            def is_invoice_level=: (bool) -> void

            def initialize:
              (
                applies_to_price_ids: ::Array[String],
                usage_discount: Float,
                is_invoice_level: bool,
                adjustment_type: :usage_discount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_usage_discount
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_usage_discount
          end

          type new_amount_discount =
            {
              adjustment_type: :amount_discount,
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool
            }

          class NewAmountDiscount < Orb::BaseModel
            attr_accessor adjustment_type: :amount_discount

            attr_accessor amount_discount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_reader is_invoice_level: bool?

            def is_invoice_level=: (bool) -> void

            def initialize:
              (
                amount_discount: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                adjustment_type: :amount_discount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_amount_discount
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_amount_discount
          end

          type new_minimum =
            {
              adjustment_type: :minimum,
              applies_to_price_ids: ::Array[String],
              item_id: String,
              minimum_amount: String,
              is_invoice_level: bool
            }

          class NewMinimum < Orb::BaseModel
            attr_accessor adjustment_type: :minimum

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor item_id: String

            attr_accessor minimum_amount: String

            attr_reader is_invoice_level: bool?

            def is_invoice_level=: (bool) -> void

            def initialize:
              (
                applies_to_price_ids: ::Array[String],
                item_id: String,
                minimum_amount: String,
                is_invoice_level: bool,
                adjustment_type: :minimum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_minimum
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_minimum
          end

          type new_maximum =
            {
              adjustment_type: :maximum,
              applies_to_price_ids: ::Array[String],
              maximum_amount: String,
              is_invoice_level: bool
            }

          class NewMaximum < Orb::BaseModel
            attr_accessor adjustment_type: :maximum

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor maximum_amount: String

            attr_reader is_invoice_level: bool?

            def is_invoice_level=: (bool) -> void

            def initialize:
              (
                applies_to_price_ids: ::Array[String],
                maximum_amount: String,
                is_invoice_level: bool,
                adjustment_type: :maximum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_maximum
                | Orb::BaseModel data
              ) -> void

            def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::new_maximum
          end

          private def self.variants: -> [[:percentage_discount, Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewPercentageDiscount], [:usage_discount, Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewUsageDiscount], [:amount_discount, Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewAmountDiscount], [:minimum, Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewMinimum], [:maximum, Orb::Models::SubscriptionPriceIntervalsParams::AddAdjustment::Adjustment::NewMaximum]]
        end

        type start_date = Time | Orb::Models::billing_cycle_relative_date

        class StartDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end

        type end_date = Time | Orb::Models::billing_cycle_relative_date

        class EndDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end
      end

      type edit =
        {
          price_interval_id: String,
          billing_cycle_day: Integer?,
          end_date: Orb::Models::SubscriptionPriceIntervalsParams::Edit::end_date?,
          fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit::FixedFeeQuantityTransition]?,
          start_date: Orb::Models::SubscriptionPriceIntervalsParams::Edit::start_date
        }

      class Edit < Orb::BaseModel
        attr_accessor price_interval_id: String

        attr_accessor billing_cycle_day: Integer?

        attr_accessor end_date: Orb::Models::SubscriptionPriceIntervalsParams::Edit::end_date?

        attr_accessor fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit::FixedFeeQuantityTransition]?

        attr_reader start_date: Orb::Models::SubscriptionPriceIntervalsParams::Edit::start_date?

        def start_date=: (
          Orb::Models::SubscriptionPriceIntervalsParams::Edit::start_date
        ) -> void

        def initialize:
          (
            price_interval_id: String,
            billing_cycle_day: Integer?,
            end_date: Orb::Models::SubscriptionPriceIntervalsParams::Edit::end_date?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionPriceIntervalsParams::Edit::FixedFeeQuantityTransition]?,
            start_date: Orb::Models::SubscriptionPriceIntervalsParams::Edit::start_date
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsParams::edit
            | Orb::BaseModel data
          ) -> void

        def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::edit

        type end_date = Time | Orb::Models::billing_cycle_relative_date

        class EndDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end

        type fixed_fee_quantity_transition =
          { effective_date: Time, quantity: Integer }

        class FixedFeeQuantityTransition < Orb::BaseModel
          attr_accessor effective_date: Time

          attr_accessor quantity: Integer

          def initialize:
            (effective_date: Time, quantity: Integer) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsParams::Edit::fixed_fee_quantity_transition
              | Orb::BaseModel data
            ) -> void

          def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::Edit::fixed_fee_quantity_transition
        end

        type start_date = Time | Orb::Models::billing_cycle_relative_date

        class StartDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end
      end

      type edit_adjustment =
        {
          adjustment_interval_id: String,
          end_date: Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::end_date?,
          start_date: Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::start_date
        }

      class EditAdjustment < Orb::BaseModel
        attr_accessor adjustment_interval_id: String

        attr_accessor end_date: Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::end_date?

        attr_reader start_date: Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::start_date?

        def start_date=: (
          Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::start_date
        ) -> void

        def initialize:
          (
            adjustment_interval_id: String,
            end_date: Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::end_date?,
            start_date: Orb::Models::SubscriptionPriceIntervalsParams::EditAdjustment::start_date
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsParams::edit_adjustment
            | Orb::BaseModel data
          ) -> void

        def to_hash: -> Orb::Models::SubscriptionPriceIntervalsParams::edit_adjustment

        type end_date = Time | Orb::Models::billing_cycle_relative_date

        class EndDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end

        type start_date = Time | Orb::Models::billing_cycle_relative_date

        class StartDate < Orb::Union
          private def self.variants: -> [[nil, Time], [nil, Orb::Models::billing_cycle_relative_date]]
        end
      end
    end
  end
end
