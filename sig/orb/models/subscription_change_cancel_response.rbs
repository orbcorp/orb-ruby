module Orb
  module Models
    type subscription_change_cancel_response =
      {
        id: String,
        expiration_time: Time,
        status: Orb::Models::SubscriptionChangeCancelResponse::status,
        subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?,
        applied_at: Time?,
        cancelled_at: Time?
      }

    class SubscriptionChangeCancelResponse < Orb::Internal::Type::BaseModel
      attr_accessor id: String

      attr_accessor expiration_time: Time

      attr_accessor status: Orb::Models::SubscriptionChangeCancelResponse::status

      attr_accessor subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?

      attr_accessor applied_at: Time?

      attr_accessor cancelled_at: Time?

      def initialize: (
        id: String,
        expiration_time: Time,
        status: Orb::Models::SubscriptionChangeCancelResponse::status,
        subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?,
        ?applied_at: Time?,
        ?cancelled_at: Time?
      ) -> void

      def to_hash: -> {
        id: String,
        expiration_time: Time,
        status: Orb::Models::SubscriptionChangeCancelResponse::status,
        subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?,
        applied_at: Time?,
        cancelled_at: Time?
      }

      type status = :pending | :applied | :cancelled

      module Status
        extend Orb::Internal::Type::Enum

        PENDING: :pending
        APPLIED: :applied
        CANCELLED: :cancelled

        def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::status]
      end

      type subscription =
        {
          id: String,
          active_plan_phase_order: Integer?,
          adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval],
          auto_collection: bool?,
          billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration,
          billing_cycle_day: Integer,
          created_at: Time,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          customer: Orb::Customer,
          default_invoice_memo: String?,
          discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval],
          end_date: Time?,
          fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule],
          invoicing_threshold: String?,
          maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval],
          metadata: ::Hash[Symbol, String],
          minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval],
          name: String,
          net_terms: Integer,
          pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?,
          plan: Orb::Plan?,
          price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval],
          redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?,
          start_date: Time,
          status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status,
          trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo,
          changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?
        }

      class Subscription < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor active_plan_phase_order: Integer?

        attr_accessor adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval]

        attr_accessor auto_collection: bool?

        attr_accessor billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration

        attr_accessor billing_cycle_day: Integer

        attr_accessor created_at: Time

        attr_accessor current_billing_period_end_date: Time?

        attr_accessor current_billing_period_start_date: Time?

        attr_accessor customer: Orb::Customer

        attr_accessor default_invoice_memo: String?

        attr_accessor discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval]

        attr_accessor end_date: Time?

        attr_accessor fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule]

        attr_accessor invoicing_threshold: String?

        attr_accessor maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval]

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval]

        attr_accessor name: String

        attr_accessor net_terms: Integer

        attr_accessor pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?

        attr_accessor plan: Orb::Plan?

        attr_accessor price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval]

        attr_accessor redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?

        attr_accessor start_date: Time

        attr_accessor status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status

        attr_accessor trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo

        attr_accessor changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?

        def initialize: (
          id: String,
          active_plan_phase_order: Integer?,
          adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval],
          auto_collection: bool?,
          billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration,
          billing_cycle_day: Integer,
          created_at: Time,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          customer: Orb::Customer,
          default_invoice_memo: String?,
          discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval],
          end_date: Time?,
          fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule],
          invoicing_threshold: String?,
          maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval],
          metadata: ::Hash[Symbol, String],
          minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval],
          name: String,
          net_terms: Integer,
          pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?,
          plan: Orb::Plan?,
          price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval],
          redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?,
          start_date: Time,
          status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status,
          trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo,
          ?changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?
        ) -> void

        def to_hash: -> {
          id: String,
          active_plan_phase_order: Integer?,
          adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval],
          auto_collection: bool?,
          billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration,
          billing_cycle_day: Integer,
          created_at: Time,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          customer: Orb::Customer,
          default_invoice_memo: String?,
          discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval],
          end_date: Time?,
          fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule],
          invoicing_threshold: String?,
          maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval],
          metadata: ::Hash[Symbol, String],
          minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval],
          name: String,
          net_terms: Integer,
          pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?,
          plan: Orb::Plan?,
          price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval],
          redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?,
          start_date: Time,
          status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status,
          trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo,
          changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?
        }

        type adjustment_interval =
          {
            id: String,
            adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment,
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time
          }

        class AdjustmentInterval < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          def initialize: (
            id: String,
            adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment,
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time
          ) -> void

          def to_hash: -> {
            id: String,
            adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment,
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time
          }

          type adjustment =
            Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum

          module Adjustment
            extend Orb::Internal::Type::Union

            type usage_discount =
              {
                id: String,
                adjustment_type: :usage_discount,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                usage_discount: Float
              }

            class UsageDiscount < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :usage_discount

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter]

              attr_accessor is_invoice_level: bool

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              attr_accessor usage_discount: Float

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                usage_discount: Float,
                ?adjustment_type: :usage_discount
              ) -> void

              def to_hash: -> {
                id: String,
                adjustment_type: :usage_discount,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                usage_discount: Float
              }

              type filter =
                {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::operator,
                  values: ::Array[String]
                }

              class Filter < Orb::Internal::Type::BaseModel
                attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::field

                attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::operator

                attr_accessor values: ::Array[String]

                def initialize: (
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::operator,
                  values: ::Array[String]
                ) -> void

                def to_hash: -> {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::operator,
                  values: ::Array[String]
                }

                type field =
                  :price_id
                  | :item_id
                  | :price_type
                  | :currency
                  | :pricing_unit_id

                module Field
                  extend Orb::Internal::Type::Enum

                  PRICE_ID: :price_id
                  ITEM_ID: :item_id
                  PRICE_TYPE: :price_type
                  CURRENCY: :currency
                  PRICING_UNIT_ID: :pricing_unit_id

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::field]
                end

                type operator = :includes | :excludes

                module Operator
                  extend Orb::Internal::Type::Enum

                  INCLUDES: :includes
                  EXCLUDES: :excludes

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::UsageDiscount::Filter::operator]
                end
              end
            end

            type amount_discount =
              {
                id: String,
                adjustment_type: :amount_discount,
                amount_discount: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?
              }

            class AmountDiscount < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :amount_discount

              attr_accessor amount_discount: String

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter]

              attr_accessor is_invoice_level: bool

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                amount_discount: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :amount_discount
              ) -> void

              def to_hash: -> {
                id: String,
                adjustment_type: :amount_discount,
                amount_discount: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?
              }

              type filter =
                {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::operator,
                  values: ::Array[String]
                }

              class Filter < Orb::Internal::Type::BaseModel
                attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::field

                attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::operator

                attr_accessor values: ::Array[String]

                def initialize: (
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::operator,
                  values: ::Array[String]
                ) -> void

                def to_hash: -> {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::operator,
                  values: ::Array[String]
                }

                type field =
                  :price_id
                  | :item_id
                  | :price_type
                  | :currency
                  | :pricing_unit_id

                module Field
                  extend Orb::Internal::Type::Enum

                  PRICE_ID: :price_id
                  ITEM_ID: :item_id
                  PRICE_TYPE: :price_type
                  CURRENCY: :currency
                  PRICING_UNIT_ID: :pricing_unit_id

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::field]
                end

                type operator = :includes | :excludes

                module Operator
                  extend Orb::Internal::Type::Enum

                  INCLUDES: :includes
                  EXCLUDES: :excludes

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::AmountDiscount::Filter::operator]
                end
              end
            end

            type percentage_discount =
              {
                id: String,
                adjustment_type: :percentage_discount,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter],
                is_invoice_level: bool,
                percentage_discount: Float,
                plan_phase_order: Integer?,
                reason: String?
              }

            class PercentageDiscount < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :percentage_discount

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter]

              attr_accessor is_invoice_level: bool

              attr_accessor percentage_discount: Float

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter],
                is_invoice_level: bool,
                percentage_discount: Float,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :percentage_discount
              ) -> void

              def to_hash: -> {
                id: String,
                adjustment_type: :percentage_discount,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter],
                is_invoice_level: bool,
                percentage_discount: Float,
                plan_phase_order: Integer?,
                reason: String?
              }

              type filter =
                {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::operator,
                  values: ::Array[String]
                }

              class Filter < Orb::Internal::Type::BaseModel
                attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::field

                attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::operator

                attr_accessor values: ::Array[String]

                def initialize: (
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::operator,
                  values: ::Array[String]
                ) -> void

                def to_hash: -> {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::operator,
                  values: ::Array[String]
                }

                type field =
                  :price_id
                  | :item_id
                  | :price_type
                  | :currency
                  | :pricing_unit_id

                module Field
                  extend Orb::Internal::Type::Enum

                  PRICE_ID: :price_id
                  ITEM_ID: :item_id
                  PRICE_TYPE: :price_type
                  CURRENCY: :currency
                  PRICING_UNIT_ID: :pricing_unit_id

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::field]
                end

                type operator = :includes | :excludes

                module Operator
                  extend Orb::Internal::Type::Enum

                  INCLUDES: :includes
                  EXCLUDES: :excludes

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PercentageDiscount::Filter::operator]
                end
              end
            end

            type minimum =
              {
                id: String,
                adjustment_type: :minimum,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter],
                is_invoice_level: bool,
                item_id: String,
                minimum_amount: String,
                plan_phase_order: Integer?,
                reason: String?
              }

            class Minimum < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :minimum

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter]

              attr_accessor is_invoice_level: bool

              attr_accessor item_id: String

              attr_accessor minimum_amount: String

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter],
                is_invoice_level: bool,
                item_id: String,
                minimum_amount: String,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :minimum
              ) -> void

              def to_hash: -> {
                id: String,
                adjustment_type: :minimum,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter],
                is_invoice_level: bool,
                item_id: String,
                minimum_amount: String,
                plan_phase_order: Integer?,
                reason: String?
              }

              type filter =
                {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::operator,
                  values: ::Array[String]
                }

              class Filter < Orb::Internal::Type::BaseModel
                attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::field

                attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::operator

                attr_accessor values: ::Array[String]

                def initialize: (
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::operator,
                  values: ::Array[String]
                ) -> void

                def to_hash: -> {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::operator,
                  values: ::Array[String]
                }

                type field =
                  :price_id
                  | :item_id
                  | :price_type
                  | :currency
                  | :pricing_unit_id

                module Field
                  extend Orb::Internal::Type::Enum

                  PRICE_ID: :price_id
                  ITEM_ID: :item_id
                  PRICE_TYPE: :price_type
                  CURRENCY: :currency
                  PRICING_UNIT_ID: :pricing_unit_id

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::field]
                end

                type operator = :includes | :excludes

                module Operator
                  extend Orb::Internal::Type::Enum

                  INCLUDES: :includes
                  EXCLUDES: :excludes

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Minimum::Filter::operator]
                end
              end
            end

            type maximum =
              {
                id: String,
                adjustment_type: :maximum,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter],
                is_invoice_level: bool,
                maximum_amount: String,
                plan_phase_order: Integer?,
                reason: String?
              }

            class Maximum < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :maximum

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter]

              attr_accessor is_invoice_level: bool

              attr_accessor maximum_amount: String

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter],
                is_invoice_level: bool,
                maximum_amount: String,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :maximum
              ) -> void

              def to_hash: -> {
                id: String,
                adjustment_type: :maximum,
                applies_to_price_ids: ::Array[String],
                filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter],
                is_invoice_level: bool,
                maximum_amount: String,
                plan_phase_order: Integer?,
                reason: String?
              }

              type filter =
                {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::operator,
                  values: ::Array[String]
                }

              class Filter < Orb::Internal::Type::BaseModel
                attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::field

                attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::operator

                attr_accessor values: ::Array[String]

                def initialize: (
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::operator,
                  values: ::Array[String]
                ) -> void

                def to_hash: -> {
                  field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::field,
                  operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::operator,
                  values: ::Array[String]
                }

                type field =
                  :price_id
                  | :item_id
                  | :price_type
                  | :currency
                  | :pricing_unit_id

                module Field
                  extend Orb::Internal::Type::Enum

                  PRICE_ID: :price_id
                  ITEM_ID: :item_id
                  PRICE_TYPE: :price_type
                  CURRENCY: :currency
                  PRICING_UNIT_ID: :pricing_unit_id

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::field]
                end

                type operator = :includes | :excludes

                module Operator
                  extend Orb::Internal::Type::Enum

                  INCLUDES: :includes
                  EXCLUDES: :excludes

                  def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::Maximum::Filter::operator]
                end
              end
            end

            def self?.variants: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment]
          end
        end

        type billing_cycle_anchor_configuration =
          { day: Integer, month: Integer?, year: Integer? }

        class BillingCycleAnchorConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor day: Integer

          attr_accessor month: Integer?

          attr_accessor year: Integer?

          def initialize: (
            day: Integer,
            ?month: Integer?,
            ?year: Integer?
          ) -> void

          def to_hash: -> { day: Integer, month: Integer?, year: Integer? }
        end

        type discount_interval =
          Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount
          | Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage
          | Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage

        module DiscountInterval
          extend Orb::Internal::Type::Union

          type amount =
            {
              amount_discount: String,
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :amount,
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter],
              start_date: Time
            }

          class Amount < Orb::Internal::Type::BaseModel
            attr_accessor amount_discount: String

            attr_accessor applies_to_price_interval_ids: ::Array[String]

            attr_accessor discount_type: :amount

            attr_accessor end_date: Time?

            attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter]

            attr_accessor start_date: Time

            def initialize: (
              amount_discount: String,
              applies_to_price_interval_ids: ::Array[String],
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter],
              start_date: Time,
              ?discount_type: :amount
            ) -> void

            def to_hash: -> {
              amount_discount: String,
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :amount,
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter],
              start_date: Time
            }

            type filter =
              {
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::field

              attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Amount::Filter::operator]
              end
            end
          end

          type percentage =
            {
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :percentage,
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter],
              percentage_discount: Float,
              start_date: Time
            }

          class Percentage < Orb::Internal::Type::BaseModel
            attr_accessor applies_to_price_interval_ids: ::Array[String]

            attr_accessor discount_type: :percentage

            attr_accessor end_date: Time?

            attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter]

            attr_accessor percentage_discount: Float

            attr_accessor start_date: Time

            def initialize: (
              applies_to_price_interval_ids: ::Array[String],
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter],
              percentage_discount: Float,
              start_date: Time,
              ?discount_type: :percentage
            ) -> void

            def to_hash: -> {
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :percentage,
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter],
              percentage_discount: Float,
              start_date: Time
            }

            type filter =
              {
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::field

              attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Percentage::Filter::operator]
              end
            end
          end

          type usage =
            {
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :usage,
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter],
              start_date: Time,
              usage_discount: Float
            }

          class Usage < Orb::Internal::Type::BaseModel
            attr_accessor applies_to_price_interval_ids: ::Array[String]

            attr_accessor discount_type: :usage

            attr_accessor end_date: Time?

            attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter]

            attr_accessor start_date: Time

            attr_accessor usage_discount: Float

            def initialize: (
              applies_to_price_interval_ids: ::Array[String],
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter],
              start_date: Time,
              usage_discount: Float,
              ?discount_type: :usage
            ) -> void

            def to_hash: -> {
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :usage,
              end_date: Time?,
              filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter],
              start_date: Time,
              usage_discount: Float
            }

            type filter =
              {
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::field

              attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::field,
                operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::Usage::Filter::operator]
              end
            end
          end

          def self?.variants: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval]
        end

        type fixed_fee_quantity_schedule =
          {
            end_date: Time?,
            price_id: String,
            quantity: Float,
            start_date: Time
          }

        class FixedFeeQuantitySchedule < Orb::Internal::Type::BaseModel
          attr_accessor end_date: Time?

          attr_accessor price_id: String

          attr_accessor quantity: Float

          attr_accessor start_date: Time

          def initialize: (
            end_date: Time?,
            price_id: String,
            quantity: Float,
            start_date: Time
          ) -> void

          def to_hash: -> {
            end_date: Time?,
            price_id: String,
            quantity: Float,
            start_date: Time
          }
        end

        type maximum_interval =
          {
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter],
            maximum_amount: String,
            start_date: Time
          }

        class MaximumInterval < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor end_date: Time?

          attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter]

          attr_accessor maximum_amount: String

          attr_accessor start_date: Time

          def initialize: (
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter],
            maximum_amount: String,
            start_date: Time
          ) -> void

          def to_hash: -> {
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter],
            maximum_amount: String,
            start_date: Time
          }

          type filter =
            {
              field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::field,
              operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::field

            attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::field,
              operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::field,
              operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval::Filter::operator]
            end
          end
        end

        type minimum_interval =
          {
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter],
            minimum_amount: String,
            start_date: Time
          }

        class MinimumInterval < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor end_date: Time?

          attr_accessor filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter]

          attr_accessor minimum_amount: String

          attr_accessor start_date: Time

          def initialize: (
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter],
            minimum_amount: String,
            start_date: Time
          ) -> void

          def to_hash: -> {
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            filters: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter],
            minimum_amount: String,
            start_date: Time
          }

          type filter =
            {
              field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::field,
              operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::field

            attr_accessor operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::field,
              operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::field,
              operator: Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval::Filter::operator]
            end
          end
        end

        type pending_subscription_change = { id: String }

        class PendingSubscriptionChange < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type price_interval =
          {
            id: String,
            billing_cycle_day: Integer,
            current_billing_period_end_date: Time?,
            current_billing_period_start_date: Time?,
            end_date: Time?,
            filter: String?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?,
            price: Orb::Models::price,
            start_date: Time,
            usage_customer_ids: ::Array[String]?
          }

        class PriceInterval < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor billing_cycle_day: Integer

          attr_accessor current_billing_period_end_date: Time?

          attr_accessor current_billing_period_start_date: Time?

          attr_accessor end_date: Time?

          attr_accessor filter: String?

          attr_accessor fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?

          attr_accessor price: Orb::Models::price

          attr_accessor start_date: Time

          attr_accessor usage_customer_ids: ::Array[String]?

          def initialize: (
            id: String,
            billing_cycle_day: Integer,
            current_billing_period_end_date: Time?,
            current_billing_period_start_date: Time?,
            end_date: Time?,
            filter: String?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?,
            price: Orb::Models::price,
            start_date: Time,
            usage_customer_ids: ::Array[String]?
          ) -> void

          def to_hash: -> {
            id: String,
            billing_cycle_day: Integer,
            current_billing_period_end_date: Time?,
            current_billing_period_start_date: Time?,
            end_date: Time?,
            filter: String?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?,
            price: Orb::Models::price,
            start_date: Time,
            usage_customer_ids: ::Array[String]?
          }

          type fixed_fee_quantity_transition =
            { effective_date: Time, price_id: String, quantity: Integer }

          class FixedFeeQuantityTransition < Orb::Internal::Type::BaseModel
            attr_accessor effective_date: Time

            attr_accessor price_id: String

            attr_accessor quantity: Integer

            def initialize: (
              effective_date: Time,
              price_id: String,
              quantity: Integer
            ) -> void

            def to_hash: -> {
              effective_date: Time,
              price_id: String,
              quantity: Integer
            }
          end
        end

        type redeemed_coupon =
          { coupon_id: String, end_date: Time?, start_date: Time }

        class RedeemedCoupon < Orb::Internal::Type::BaseModel
          attr_accessor coupon_id: String

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          def initialize: (
            coupon_id: String,
            end_date: Time?,
            start_date: Time
          ) -> void

          def to_hash: -> {
            coupon_id: String,
            end_date: Time?,
            start_date: Time
          }
        end

        type status = :active | :ended | :upcoming

        module Status
          extend Orb::Internal::Type::Enum

          ACTIVE: :active
          ENDED: :ended
          UPCOMING: :upcoming

          def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::status]
        end

        type trial_info = { end_date: Time? }

        class TrialInfo < Orb::Internal::Type::BaseModel
          attr_accessor end_date: Time?

          def initialize: (end_date: Time?) -> void

          def to_hash: -> { end_date: Time? }
        end

        type changed_resources =
          {
            created_credit_notes: ::Array[Orb::CreditNote],
            created_invoices: ::Array[Orb::Invoice],
            voided_credit_notes: ::Array[Orb::CreditNote],
            voided_invoices: ::Array[Orb::Invoice]
          }

        class ChangedResources < Orb::Internal::Type::BaseModel
          attr_accessor created_credit_notes: ::Array[Orb::CreditNote]

          attr_accessor created_invoices: ::Array[Orb::Invoice]

          attr_accessor voided_credit_notes: ::Array[Orb::CreditNote]

          attr_accessor voided_invoices: ::Array[Orb::Invoice]

          def initialize: (
            created_credit_notes: ::Array[Orb::CreditNote],
            created_invoices: ::Array[Orb::Invoice],
            voided_credit_notes: ::Array[Orb::CreditNote],
            voided_invoices: ::Array[Orb::Invoice]
          ) -> void

          def to_hash: -> {
            created_credit_notes: ::Array[Orb::CreditNote],
            created_invoices: ::Array[Orb::Invoice],
            voided_credit_notes: ::Array[Orb::CreditNote],
            voided_invoices: ::Array[Orb::Invoice]
          }
        end
      end
    end
  end
end
