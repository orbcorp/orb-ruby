module Orb
  module Models
    type subscription_change_cancel_response =
      {
        id: String,
        expiration_time: Time,
        status: Orb::Models::SubscriptionChangeCancelResponse::status,
        subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?,
        applied_at: Time?,
        cancelled_at: Time?
      }

    class SubscriptionChangeCancelResponse < Orb::Internal::Type::BaseModel
      attr_accessor id: String

      attr_accessor expiration_time: Time

      attr_accessor status: Orb::Models::SubscriptionChangeCancelResponse::status

      attr_accessor subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?

      attr_accessor applied_at: Time?

      attr_accessor cancelled_at: Time?

      def initialize: (
        id: String,
        expiration_time: Time,
        status: Orb::Models::SubscriptionChangeCancelResponse::status,
        subscription: Orb::Models::SubscriptionChangeCancelResponse::Subscription?,
        ?applied_at: Time?,
        ?cancelled_at: Time?
      ) -> void

      def to_hash: -> Orb::Models::subscription_change_cancel_response

      type status = :pending | :applied | :cancelled

      module Status
        extend Orb::Internal::Type::Enum

        PENDING: :pending
        APPLIED: :applied
        CANCELLED: :cancelled

        def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::status]
      end

      type subscription =
        {
          id: String,
          active_plan_phase_order: Integer?,
          adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval],
          auto_collection: bool?,
          billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration,
          billing_cycle_day: Integer,
          created_at: Time,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          customer: Orb::Models::Customer,
          default_invoice_memo: String?,
          discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval],
          end_date: Time?,
          fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule],
          invoicing_threshold: String?,
          maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval],
          metadata: ::Hash[Symbol, String],
          minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval],
          net_terms: Integer,
          pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?,
          plan: Orb::Models::Plan,
          price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval],
          redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?,
          start_date: Time,
          status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status,
          trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo,
          changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?
        }

      class Subscription < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor active_plan_phase_order: Integer?

        attr_accessor adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval]

        attr_accessor auto_collection: bool?

        attr_accessor billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration

        attr_accessor billing_cycle_day: Integer

        attr_accessor created_at: Time

        attr_accessor current_billing_period_end_date: Time?

        attr_accessor current_billing_period_start_date: Time?

        attr_accessor customer: Orb::Models::Customer

        attr_accessor default_invoice_memo: String?

        attr_accessor discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval]

        attr_accessor end_date: Time?

        attr_accessor fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule]

        attr_accessor invoicing_threshold: String?

        attr_accessor maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval]

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval]

        attr_accessor net_terms: Integer

        attr_accessor pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?

        attr_accessor plan: Orb::Models::Plan

        attr_accessor price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval]

        attr_accessor redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?

        attr_accessor start_date: Time

        attr_accessor status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status

        attr_accessor trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo

        attr_accessor changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?

        def initialize: (
          id: String,
          active_plan_phase_order: Integer?,
          adjustment_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval],
          auto_collection: bool?,
          billing_cycle_anchor_configuration: Orb::Models::SubscriptionChangeCancelResponse::Subscription::BillingCycleAnchorConfiguration,
          billing_cycle_day: Integer,
          created_at: Time,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          customer: Orb::Models::Customer,
          default_invoice_memo: String?,
          discount_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::discount_interval],
          end_date: Time?,
          fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::FixedFeeQuantitySchedule],
          invoicing_threshold: String?,
          maximum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MaximumInterval],
          metadata: ::Hash[Symbol, String],
          minimum_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::MinimumInterval],
          net_terms: Integer,
          pending_subscription_change: Orb::Models::SubscriptionChangeCancelResponse::Subscription::PendingSubscriptionChange?,
          plan: Orb::Models::Plan,
          price_intervals: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval],
          redeemed_coupon: Orb::Models::SubscriptionChangeCancelResponse::Subscription::RedeemedCoupon?,
          start_date: Time,
          status: Orb::Models::SubscriptionChangeCancelResponse::Subscription::status,
          trial_info: Orb::Models::SubscriptionChangeCancelResponse::Subscription::TrialInfo,
          ?changed_resources: Orb::Models::SubscriptionChangeCancelResponse::Subscription::ChangedResources?
        ) -> void

        def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::subscription

        type adjustment_interval =
          {
            id: String,
            adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment,
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time
          }

        class AdjustmentInterval < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          def initialize: (
            id: String,
            adjustment: Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::adjustment,
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::adjustment_interval

          type adjustment =
            Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseUsageDiscountAdjustment
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseAmountDiscountAdjustment
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhasePercentageDiscountAdjustment
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseMinimumAdjustment
            | Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseMaximumAdjustment

          module Adjustment
            extend Orb::Internal::Type::Union

            type plan_phase_usage_discount_adjustment =
              {
                id: String,
                adjustment_type: :usage_discount,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                usage_discount: Float
              }

            class PlanPhaseUsageDiscountAdjustment < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :usage_discount

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor is_invoice_level: bool

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              attr_accessor usage_discount: Float

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                usage_discount: Float,
                ?adjustment_type: :usage_discount
              ) -> void

              def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::plan_phase_usage_discount_adjustment
            end

            type plan_phase_amount_discount_adjustment =
              {
                id: String,
                adjustment_type: :amount_discount,
                amount_discount: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?
              }

            class PlanPhaseAmountDiscountAdjustment < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :amount_discount

              attr_accessor amount_discount: String

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor is_invoice_level: bool

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                amount_discount: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :amount_discount
              ) -> void

              def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::plan_phase_amount_discount_adjustment
            end

            type plan_phase_percentage_discount_adjustment =
              {
                id: String,
                adjustment_type: :percentage_discount,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                percentage_discount: Float,
                plan_phase_order: Integer?,
                reason: String?
              }

            class PlanPhasePercentageDiscountAdjustment < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :percentage_discount

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor is_invoice_level: bool

              attr_accessor percentage_discount: Float

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                percentage_discount: Float,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :percentage_discount
              ) -> void

              def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::plan_phase_percentage_discount_adjustment
            end

            type plan_phase_minimum_adjustment =
              {
                id: String,
                adjustment_type: :minimum,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                item_id: String,
                minimum_amount: String,
                plan_phase_order: Integer?,
                reason: String?
              }

            class PlanPhaseMinimumAdjustment < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :minimum

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor is_invoice_level: bool

              attr_accessor item_id: String

              attr_accessor minimum_amount: String

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                item_id: String,
                minimum_amount: String,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :minimum
              ) -> void

              def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::plan_phase_minimum_adjustment
            end

            type plan_phase_maximum_adjustment =
              {
                id: String,
                adjustment_type: :maximum,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                maximum_amount: String,
                plan_phase_order: Integer?,
                reason: String?
              }

            class PlanPhaseMaximumAdjustment < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor adjustment_type: :maximum

              attr_accessor applies_to_price_ids: ::Array[String]

              attr_accessor is_invoice_level: bool

              attr_accessor maximum_amount: String

              attr_accessor plan_phase_order: Integer?

              attr_accessor reason: String?

              def initialize: (
                id: String,
                applies_to_price_ids: ::Array[String],
                is_invoice_level: bool,
                maximum_amount: String,
                plan_phase_order: Integer?,
                reason: String?,
                ?adjustment_type: :maximum
              ) -> void

              def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::plan_phase_maximum_adjustment
            end

            def self?.variants: -> [Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseUsageDiscountAdjustment, Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseAmountDiscountAdjustment, Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhasePercentageDiscountAdjustment, Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseMinimumAdjustment, Orb::Models::SubscriptionChangeCancelResponse::Subscription::AdjustmentInterval::Adjustment::PlanPhaseMaximumAdjustment]
          end
        end

        type billing_cycle_anchor_configuration =
          { day: Integer, month: Integer?, year: Integer? }

        class BillingCycleAnchorConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor day: Integer

          attr_accessor month: Integer?

          attr_accessor year: Integer?

          def initialize: (
            day: Integer,
            ?month: Integer?,
            ?year: Integer?
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::billing_cycle_anchor_configuration
        end

        type discount_interval =
          Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::AmountDiscountInterval
          | Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::PercentageDiscountInterval
          | Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::UsageDiscountInterval

        module DiscountInterval
          extend Orb::Internal::Type::Union

          type amount_discount_interval =
            {
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :amount,
              end_date: Time?,
              start_date: Time
            }

          class AmountDiscountInterval < Orb::Internal::Type::BaseModel
            attr_accessor amount_discount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor applies_to_price_interval_ids: ::Array[String]

            attr_accessor discount_type: :amount

            attr_accessor end_date: Time?

            attr_accessor start_date: Time

            def initialize: (
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              applies_to_price_interval_ids: ::Array[String],
              end_date: Time?,
              start_date: Time,
              ?discount_type: :amount
            ) -> void

            def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::amount_discount_interval
          end

          type percentage_discount_interval =
            {
              applies_to_price_ids: ::Array[String],
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :percentage,
              end_date: Time?,
              percentage_discount: Float,
              start_date: Time
            }

          class PercentageDiscountInterval < Orb::Internal::Type::BaseModel
            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor applies_to_price_interval_ids: ::Array[String]

            attr_accessor discount_type: :percentage

            attr_accessor end_date: Time?

            attr_accessor percentage_discount: Float

            attr_accessor start_date: Time

            def initialize: (
              applies_to_price_ids: ::Array[String],
              applies_to_price_interval_ids: ::Array[String],
              end_date: Time?,
              percentage_discount: Float,
              start_date: Time,
              ?discount_type: :percentage
            ) -> void

            def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::percentage_discount_interval
          end

          type usage_discount_interval =
            {
              applies_to_price_ids: ::Array[String],
              applies_to_price_interval_ids: ::Array[String],
              discount_type: :usage,
              end_date: Time?,
              start_date: Time,
              usage_discount: Float
            }

          class UsageDiscountInterval < Orb::Internal::Type::BaseModel
            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor applies_to_price_interval_ids: ::Array[String]

            attr_accessor discount_type: :usage

            attr_accessor end_date: Time?

            attr_accessor start_date: Time

            attr_accessor usage_discount: Float

            def initialize: (
              applies_to_price_ids: ::Array[String],
              applies_to_price_interval_ids: ::Array[String],
              end_date: Time?,
              start_date: Time,
              usage_discount: Float,
              ?discount_type: :usage
            ) -> void

            def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::usage_discount_interval
          end

          def self?.variants: -> [Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::AmountDiscountInterval, Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::PercentageDiscountInterval, Orb::Models::SubscriptionChangeCancelResponse::Subscription::DiscountInterval::UsageDiscountInterval]
        end

        type fixed_fee_quantity_schedule =
          {
            end_date: Time?,
            price_id: String,
            quantity: Float,
            start_date: Time
          }

        class FixedFeeQuantitySchedule < Orb::Internal::Type::BaseModel
          attr_accessor end_date: Time?

          attr_accessor price_id: String

          attr_accessor quantity: Float

          attr_accessor start_date: Time

          def initialize: (
            end_date: Time?,
            price_id: String,
            quantity: Float,
            start_date: Time
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::fixed_fee_quantity_schedule
        end

        type maximum_interval =
          {
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            maximum_amount: String,
            start_date: Time
          }

        class MaximumInterval < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor end_date: Time?

          attr_accessor maximum_amount: String

          attr_accessor start_date: Time

          def initialize: (
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            maximum_amount: String,
            start_date: Time
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::maximum_interval
        end

        type minimum_interval =
          {
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            minimum_amount: String,
            start_date: Time
          }

        class MinimumInterval < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor end_date: Time?

          attr_accessor minimum_amount: String

          attr_accessor start_date: Time

          def initialize: (
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            minimum_amount: String,
            start_date: Time
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::minimum_interval
        end

        type pending_subscription_change = { id: String }

        class PendingSubscriptionChange < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::pending_subscription_change
        end

        type price_interval =
          {
            id: String,
            billing_cycle_day: Integer,
            current_billing_period_end_date: Time?,
            current_billing_period_start_date: Time?,
            end_date: Time?,
            filter: String?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?,
            price: Orb::Models::price,
            start_date: Time,
            usage_customer_ids: ::Array[String]?
          }

        class PriceInterval < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor billing_cycle_day: Integer

          attr_accessor current_billing_period_end_date: Time?

          attr_accessor current_billing_period_start_date: Time?

          attr_accessor end_date: Time?

          attr_accessor filter: String?

          attr_accessor fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?

          attr_accessor price: Orb::Models::price

          attr_accessor start_date: Time

          attr_accessor usage_customer_ids: ::Array[String]?

          def initialize: (
            id: String,
            billing_cycle_day: Integer,
            current_billing_period_end_date: Time?,
            current_billing_period_start_date: Time?,
            end_date: Time?,
            filter: String?,
            fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::FixedFeeQuantityTransition]?,
            price: Orb::Models::price,
            start_date: Time,
            usage_customer_ids: ::Array[String]?
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::price_interval

          type fixed_fee_quantity_transition =
            { effective_date: Time, price_id: String, quantity: Integer }

          class FixedFeeQuantityTransition < Orb::Internal::Type::BaseModel
            attr_accessor effective_date: Time

            attr_accessor price_id: String

            attr_accessor quantity: Integer

            def initialize: (
              effective_date: Time,
              price_id: String,
              quantity: Integer
            ) -> void

            def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::PriceInterval::fixed_fee_quantity_transition
          end
        end

        type redeemed_coupon =
          { coupon_id: String, end_date: Time?, start_date: Time }

        class RedeemedCoupon < Orb::Internal::Type::BaseModel
          attr_accessor coupon_id: String

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          def initialize: (
            coupon_id: String,
            end_date: Time?,
            start_date: Time
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::redeemed_coupon
        end

        type status = :active | :ended | :upcoming

        module Status
          extend Orb::Internal::Type::Enum

          ACTIVE: :active
          ENDED: :ended
          UPCOMING: :upcoming

          def self?.values: -> ::Array[Orb::Models::SubscriptionChangeCancelResponse::Subscription::status]
        end

        type trial_info = { end_date: Time? }

        class TrialInfo < Orb::Internal::Type::BaseModel
          attr_accessor end_date: Time?

          def initialize: (end_date: Time?) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::trial_info
        end

        type changed_resources =
          {
            created_credit_notes: ::Array[Orb::Models::CreditNote],
            created_invoices: ::Array[Orb::Models::Invoice],
            voided_credit_notes: ::Array[Orb::Models::CreditNote],
            voided_invoices: ::Array[Orb::Models::Invoice]
          }

        class ChangedResources < Orb::Internal::Type::BaseModel
          attr_accessor created_credit_notes: ::Array[Orb::Models::CreditNote]

          attr_accessor created_invoices: ::Array[Orb::Models::Invoice]

          attr_accessor voided_credit_notes: ::Array[Orb::Models::CreditNote]

          attr_accessor voided_invoices: ::Array[Orb::Models::Invoice]

          def initialize: (
            created_credit_notes: ::Array[Orb::Models::CreditNote],
            created_invoices: ::Array[Orb::Models::Invoice],
            voided_credit_notes: ::Array[Orb::Models::CreditNote],
            voided_invoices: ::Array[Orb::Models::Invoice]
          ) -> void

          def to_hash: -> Orb::Models::SubscriptionChangeCancelResponse::Subscription::changed_resources
        end
      end
    end
  end
end
