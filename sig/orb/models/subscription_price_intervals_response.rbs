module Orb
  module Models
    type subscription_price_intervals_response =
      {
        id: String,
        active_plan_phase_order: Integer?,
        adjustment_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval],
        auto_collection: bool?,
        billing_cycle_anchor_configuration: Orb::Models::SubscriptionPriceIntervalsResponse::BillingCycleAnchorConfiguration,
        billing_cycle_day: Integer,
        created_at: Time,
        current_billing_period_end_date: Time?,
        current_billing_period_start_date: Time?,
        customer: Orb::Models::Customer,
        default_invoice_memo: String?,
        discount_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::discount_interval],
        end_date: Time?,
        fixed_fee_quantity_schedule: Array[Orb::Models::SubscriptionPriceIntervalsResponse::FixedFeeQuantitySchedule],
        invoicing_threshold: String?,
        maximum_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::MaximumInterval],
        metadata: Hash[Symbol, String],
        minimum_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::MinimumInterval],
        net_terms: Integer,
        plan: Orb::Models::Plan,
        price_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval],
        redeemed_coupon: Orb::Models::SubscriptionPriceIntervalsResponse::RedeemedCoupon?,
        start_date: Time,
        status: Orb::Models::SubscriptionPriceIntervalsResponse::status,
        trial_info: Orb::Models::SubscriptionPriceIntervalsResponse::TrialInfo
      }

    class SubscriptionPriceIntervalsResponse < Orb::BaseModel
      attr_accessor id: String

      attr_accessor active_plan_phase_order: Integer?

      attr_accessor adjustment_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval]

      attr_accessor auto_collection: bool?

      attr_accessor billing_cycle_anchor_configuration: Orb::Models::SubscriptionPriceIntervalsResponse::BillingCycleAnchorConfiguration

      attr_accessor billing_cycle_day: Integer

      attr_accessor created_at: Time

      attr_accessor current_billing_period_end_date: Time?

      attr_accessor current_billing_period_start_date: Time?

      attr_accessor customer: Orb::Models::Customer

      attr_accessor default_invoice_memo: String?

      attr_accessor discount_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::discount_interval]

      attr_accessor end_date: Time?

      attr_accessor fixed_fee_quantity_schedule: Array[Orb::Models::SubscriptionPriceIntervalsResponse::FixedFeeQuantitySchedule]

      attr_accessor invoicing_threshold: String?

      attr_accessor maximum_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::MaximumInterval]

      attr_accessor metadata: Hash[Symbol, String]

      attr_accessor minimum_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::MinimumInterval]

      attr_accessor net_terms: Integer

      attr_accessor plan: Orb::Models::Plan

      attr_accessor price_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval]

      attr_accessor redeemed_coupon: Orb::Models::SubscriptionPriceIntervalsResponse::RedeemedCoupon?

      attr_accessor start_date: Time

      attr_accessor status: Orb::Models::SubscriptionPriceIntervalsResponse::status

      attr_accessor trial_info: Orb::Models::SubscriptionPriceIntervalsResponse::TrialInfo

      def initialize:
        (
          id: String,
          active_plan_phase_order: Integer?,
          adjustment_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval],
          auto_collection: bool?,
          billing_cycle_anchor_configuration: Orb::Models::SubscriptionPriceIntervalsResponse::BillingCycleAnchorConfiguration,
          billing_cycle_day: Integer,
          created_at: Time,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          customer: Orb::Models::Customer,
          default_invoice_memo: String?,
          discount_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::discount_interval],
          end_date: Time?,
          fixed_fee_quantity_schedule: Array[Orb::Models::SubscriptionPriceIntervalsResponse::FixedFeeQuantitySchedule],
          invoicing_threshold: String?,
          maximum_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::MaximumInterval],
          metadata: Hash[Symbol, String],
          minimum_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::MinimumInterval],
          net_terms: Integer,
          plan: Orb::Models::Plan,
          price_intervals: Array[Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval],
          redeemed_coupon: Orb::Models::SubscriptionPriceIntervalsResponse::RedeemedCoupon?,
          start_date: Time,
          status: Orb::Models::SubscriptionPriceIntervalsResponse::status,
          trial_info: Orb::Models::SubscriptionPriceIntervalsResponse::TrialInfo
        ) -> void
        | (
          ?Orb::Models::subscription_price_intervals_response
          | Orb::BaseModel data
        ) -> void

      def to_h: -> Orb::Models::subscription_price_intervals_response

      type adjustment_interval =
        {
          id: String,
          adjustment: Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::adjustment,
          applies_to_price_interval_ids: Array[String],
          end_date: Time?,
          start_date: Time
        }

      class AdjustmentInterval < Orb::BaseModel
        attr_accessor id: String

        attr_accessor adjustment: Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::adjustment

        attr_accessor applies_to_price_interval_ids: Array[String]

        attr_accessor end_date: Time?

        attr_accessor start_date: Time

        def initialize:
          (
            id: String,
            adjustment: Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::adjustment,
            applies_to_price_interval_ids: Array[String],
            end_date: Time?,
            start_date: Time
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::adjustment_interval
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::adjustment_interval

        type adjustment =
          Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::AmountDiscountAdjustment
          | Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::PercentageDiscountAdjustment
          | Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::UsageDiscountAdjustment
          | Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::MinimumAdjustment
          | Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::MaximumAdjustment

        class Adjustment < Orb::Union
          type amount_discount_adjustment =
            {
              id: String,
              adjustment_type: :amount_discount,
              amount_discount: String,
              applies_to_price_ids: Array[String],
              is_invoice_level: bool,
              plan_phase_order: Integer?,
              reason: String?
            }

          class AmountDiscountAdjustment < Orb::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :amount_discount

            attr_accessor amount_discount: String

            attr_accessor applies_to_price_ids: Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize:
              (
                id: String,
                amount_discount: String,
                applies_to_price_ids: Array[String],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                adjustment_type: :amount_discount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::amount_discount_adjustment
                | Orb::BaseModel data
              ) -> void

            def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::amount_discount_adjustment
          end

          type percentage_discount_adjustment =
            {
              id: String,
              adjustment_type: :percentage_discount,
              applies_to_price_ids: Array[String],
              is_invoice_level: bool,
              percentage_discount: Float,
              plan_phase_order: Integer?,
              reason: String?
            }

          class PercentageDiscountAdjustment < Orb::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :percentage_discount

            attr_accessor applies_to_price_ids: Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor percentage_discount: Float

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize:
              (
                id: String,
                applies_to_price_ids: Array[String],
                is_invoice_level: bool,
                percentage_discount: Float,
                plan_phase_order: Integer?,
                reason: String?,
                adjustment_type: :percentage_discount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::percentage_discount_adjustment
                | Orb::BaseModel data
              ) -> void

            def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::percentage_discount_adjustment
          end

          type usage_discount_adjustment =
            {
              id: String,
              adjustment_type: :usage_discount,
              applies_to_price_ids: Array[String],
              is_invoice_level: bool,
              plan_phase_order: Integer?,
              reason: String?,
              usage_discount: Float
            }

          class UsageDiscountAdjustment < Orb::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :usage_discount

            attr_accessor applies_to_price_ids: Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            attr_accessor usage_discount: Float

            def initialize:
              (
                id: String,
                applies_to_price_ids: Array[String],
                is_invoice_level: bool,
                plan_phase_order: Integer?,
                reason: String?,
                usage_discount: Float,
                adjustment_type: :usage_discount
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::usage_discount_adjustment
                | Orb::BaseModel data
              ) -> void

            def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::usage_discount_adjustment
          end

          type minimum_adjustment =
            {
              id: String,
              adjustment_type: :minimum,
              applies_to_price_ids: Array[String],
              is_invoice_level: bool,
              item_id: String,
              minimum_amount: String,
              plan_phase_order: Integer?,
              reason: String?
            }

          class MinimumAdjustment < Orb::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :minimum

            attr_accessor applies_to_price_ids: Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor item_id: String

            attr_accessor minimum_amount: String

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize:
              (
                id: String,
                applies_to_price_ids: Array[String],
                is_invoice_level: bool,
                item_id: String,
                minimum_amount: String,
                plan_phase_order: Integer?,
                reason: String?,
                adjustment_type: :minimum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::minimum_adjustment
                | Orb::BaseModel data
              ) -> void

            def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::minimum_adjustment
          end

          type maximum_adjustment =
            {
              id: String,
              adjustment_type: :maximum,
              applies_to_price_ids: Array[String],
              is_invoice_level: bool,
              maximum_amount: String,
              plan_phase_order: Integer?,
              reason: String?
            }

          class MaximumAdjustment < Orb::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :maximum

            attr_accessor applies_to_price_ids: Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor maximum_amount: String

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize:
              (
                id: String,
                applies_to_price_ids: Array[String],
                is_invoice_level: bool,
                maximum_amount: String,
                plan_phase_order: Integer?,
                reason: String?,
                adjustment_type: :maximum
              ) -> void
              | (
                ?Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::maximum_adjustment
                | Orb::BaseModel data
              ) -> void

            def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::maximum_adjustment
          end

          private def self.variants: -> [[:amount_discount, Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::AmountDiscountAdjustment], [:percentage_discount, Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::PercentageDiscountAdjustment], [:usage_discount, Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::UsageDiscountAdjustment], [:minimum, Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::MinimumAdjustment], [:maximum, Orb::Models::SubscriptionPriceIntervalsResponse::AdjustmentInterval::Adjustment::MaximumAdjustment]]
        end
      end

      type billing_cycle_anchor_configuration =
        { day: Integer, month: Integer?, year: Integer? }

      class BillingCycleAnchorConfiguration < Orb::BaseModel
        attr_accessor day: Integer

        attr_accessor month: Integer?

        attr_accessor year: Integer?

        def initialize:
          (day: Integer, month: Integer?, year: Integer?) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::billing_cycle_anchor_configuration
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::billing_cycle_anchor_configuration
      end

      type discount_interval =
        Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::AmountDiscountInterval
        | Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::PercentageDiscountInterval
        | Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::UsageDiscountInterval

      class DiscountInterval < Orb::Union
        type amount_discount_interval =
          {
            amount_discount: String,
            applies_to_price_ids: Array[String],
            applies_to_price_interval_ids: Array[String],
            discount_type: :amount,
            end_date: Time?,
            start_date: Time
          }

        class AmountDiscountInterval < Orb::BaseModel
          attr_accessor amount_discount: String

          attr_accessor applies_to_price_ids: Array[String]

          attr_accessor applies_to_price_interval_ids: Array[String]

          attr_accessor discount_type: :amount

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          def initialize:
            (
              amount_discount: String,
              applies_to_price_ids: Array[String],
              applies_to_price_interval_ids: Array[String],
              end_date: Time?,
              start_date: Time,
              discount_type: :amount
            ) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::amount_discount_interval
              | Orb::BaseModel data
            ) -> void

          def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::amount_discount_interval
        end

        type percentage_discount_interval =
          {
            applies_to_price_ids: Array[String],
            applies_to_price_interval_ids: Array[String],
            discount_type: :percentage,
            end_date: Time?,
            percentage_discount: Float,
            start_date: Time
          }

        class PercentageDiscountInterval < Orb::BaseModel
          attr_accessor applies_to_price_ids: Array[String]

          attr_accessor applies_to_price_interval_ids: Array[String]

          attr_accessor discount_type: :percentage

          attr_accessor end_date: Time?

          attr_accessor percentage_discount: Float

          attr_accessor start_date: Time

          def initialize:
            (
              applies_to_price_ids: Array[String],
              applies_to_price_interval_ids: Array[String],
              end_date: Time?,
              percentage_discount: Float,
              start_date: Time,
              discount_type: :percentage
            ) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::percentage_discount_interval
              | Orb::BaseModel data
            ) -> void

          def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::percentage_discount_interval
        end

        type usage_discount_interval =
          {
            applies_to_price_ids: Array[String],
            applies_to_price_interval_ids: Array[String],
            discount_type: :usage,
            end_date: Time?,
            start_date: Time,
            usage_discount: Float
          }

        class UsageDiscountInterval < Orb::BaseModel
          attr_accessor applies_to_price_ids: Array[String]

          attr_accessor applies_to_price_interval_ids: Array[String]

          attr_accessor discount_type: :usage

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          attr_accessor usage_discount: Float

          def initialize:
            (
              applies_to_price_ids: Array[String],
              applies_to_price_interval_ids: Array[String],
              end_date: Time?,
              start_date: Time,
              usage_discount: Float,
              discount_type: :usage
            ) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::usage_discount_interval
              | Orb::BaseModel data
            ) -> void

          def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::usage_discount_interval
        end

        private def self.variants: -> [[:amount, Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::AmountDiscountInterval], [:percentage, Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::PercentageDiscountInterval], [:usage, Orb::Models::SubscriptionPriceIntervalsResponse::DiscountInterval::UsageDiscountInterval]]
      end

      type fixed_fee_quantity_schedule =
        { end_date: Time?, price_id: String, quantity: Float, start_date: Time }

      class FixedFeeQuantitySchedule < Orb::BaseModel
        attr_accessor end_date: Time?

        attr_accessor price_id: String

        attr_accessor quantity: Float

        attr_accessor start_date: Time

        def initialize:
          (
            end_date: Time?,
            price_id: String,
            quantity: Float,
            start_date: Time
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::fixed_fee_quantity_schedule
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::fixed_fee_quantity_schedule
      end

      type maximum_interval =
        {
          applies_to_price_ids: Array[String],
          applies_to_price_interval_ids: Array[String],
          end_date: Time?,
          maximum_amount: String,
          start_date: Time
        }

      class MaximumInterval < Orb::BaseModel
        attr_accessor applies_to_price_ids: Array[String]

        attr_accessor applies_to_price_interval_ids: Array[String]

        attr_accessor end_date: Time?

        attr_accessor maximum_amount: String

        attr_accessor start_date: Time

        def initialize:
          (
            applies_to_price_ids: Array[String],
            applies_to_price_interval_ids: Array[String],
            end_date: Time?,
            maximum_amount: String,
            start_date: Time
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::maximum_interval
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::maximum_interval
      end

      type minimum_interval =
        {
          applies_to_price_ids: Array[String],
          applies_to_price_interval_ids: Array[String],
          end_date: Time?,
          minimum_amount: String,
          start_date: Time
        }

      class MinimumInterval < Orb::BaseModel
        attr_accessor applies_to_price_ids: Array[String]

        attr_accessor applies_to_price_interval_ids: Array[String]

        attr_accessor end_date: Time?

        attr_accessor minimum_amount: String

        attr_accessor start_date: Time

        def initialize:
          (
            applies_to_price_ids: Array[String],
            applies_to_price_interval_ids: Array[String],
            end_date: Time?,
            minimum_amount: String,
            start_date: Time
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::minimum_interval
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::minimum_interval
      end

      type price_interval =
        {
          id: String,
          billing_cycle_day: Integer,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          end_date: Time?,
          fixed_fee_quantity_transitions: Array[Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval::FixedFeeQuantityTransition]?,
          price: Orb::Models::price,
          start_date: Time
        }

      class PriceInterval < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billing_cycle_day: Integer

        attr_accessor current_billing_period_end_date: Time?

        attr_accessor current_billing_period_start_date: Time?

        attr_accessor end_date: Time?

        attr_accessor fixed_fee_quantity_transitions: Array[Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval::FixedFeeQuantityTransition]?

        attr_accessor price: Orb::Models::price

        attr_accessor start_date: Time

        def initialize:
          (
            id: String,
            billing_cycle_day: Integer,
            current_billing_period_end_date: Time?,
            current_billing_period_start_date: Time?,
            end_date: Time?,
            fixed_fee_quantity_transitions: Array[Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval::FixedFeeQuantityTransition]?,
            price: Orb::Models::price,
            start_date: Time
          ) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::price_interval
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::price_interval

        type fixed_fee_quantity_transition =
          { effective_date: Time, price_id: String, quantity: Integer }

        class FixedFeeQuantityTransition < Orb::BaseModel
          attr_accessor effective_date: Time

          attr_accessor price_id: String

          attr_accessor quantity: Integer

          def initialize:
            (effective_date: Time, price_id: String, quantity: Integer) -> void
            | (
              ?Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval::fixed_fee_quantity_transition
              | Orb::BaseModel data
            ) -> void

          def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::PriceInterval::fixed_fee_quantity_transition
        end
      end

      type redeemed_coupon =
        { coupon_id: String, end_date: Time?, start_date: Time }

      class RedeemedCoupon < Orb::BaseModel
        attr_accessor coupon_id: String

        attr_accessor end_date: Time?

        attr_accessor start_date: Time

        def initialize:
          (coupon_id: String, end_date: Time?, start_date: Time) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::redeemed_coupon
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::redeemed_coupon
      end

      type status = :active | :ended | :upcoming

      class Status < Orb::Enum
        ACTIVE: :active
        ENDED: :ended
        UPCOMING: :upcoming

        def self.values: -> Array[Orb::Models::SubscriptionPriceIntervalsResponse::status]
      end

      type trial_info = { end_date: Time? }

      class TrialInfo < Orb::BaseModel
        attr_accessor end_date: Time?

        def initialize:
          (end_date: Time?) -> void
          | (
            ?Orb::Models::SubscriptionPriceIntervalsResponse::trial_info
            | Orb::BaseModel data
          ) -> void

        def to_h: -> Orb::Models::SubscriptionPriceIntervalsResponse::trial_info
      end
    end
  end
end
