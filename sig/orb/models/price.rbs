module Orb
  module Models
    type price =
      Orb::Price::Unit
      | Orb::Price::Package
      | Orb::Price::Matrix
      | Orb::Price::Tiered
      | Orb::Price::TieredBPS
      | Orb::Price::BPS
      | Orb::Price::BulkBPS
      | Orb::Price::Bulk
      | Orb::Price::ThresholdTotalAmount
      | Orb::Price::TieredPackage
      | Orb::Price::GroupedTiered
      | Orb::Price::TieredWithMinimum
      | Orb::Price::TieredPackageWithMinimum
      | Orb::Price::PackageWithAllocation
      | Orb::Price::UnitWithPercent
      | Orb::Price::MatrixWithAllocation
      | Orb::Price::TieredWithProration
      | Orb::Price::UnitWithProration
      | Orb::Price::GroupedAllocation
      | Orb::Price::GroupedWithProratedMinimum
      | Orb::Price::GroupedWithMeteredMinimum
      | Orb::Price::MatrixWithDisplayName
      | Orb::Price::BulkWithProration
      | Orb::Price::GroupedTieredPackage
      | Orb::Price::MaxGroupTieredPackage
      | Orb::Price::ScalableMatrixWithUnitPricing
      | Orb::Price::ScalableMatrixWithTieredPricing
      | Orb::Price::CumulativeGroupedBulk

    module Price
      extend Orb::Internal::Type::Union

      type unit =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Unit::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :unit,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Unit::price_type,
          unit_config: Orb::UnitConfig,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class Unit < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Unit::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Unit::price_type

        attr_accessor unit_config: Orb::UnitConfig

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Unit::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Unit::price_type,
          unit_config: Orb::UnitConfig,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :unit
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Unit::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :unit,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Unit::price_type,
          unit_config: Orb::UnitConfig,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Unit::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Unit::price_type]
        end
      end

      type package =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Package::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :package,
          name: String,
          package_config: Orb::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Package::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class Package < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Package::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :package

        attr_accessor name: String

        attr_accessor package_config: Orb::PackageConfig

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Package::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Package::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          package_config: Orb::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Package::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Package::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :package,
          name: String,
          package_config: Orb::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Package::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Package::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Package::price_type]
        end
      end

      type matrix =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Matrix::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_config: Orb::MatrixConfig,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :matrix,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Matrix::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class Matrix < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Matrix::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor matrix_config: Orb::MatrixConfig

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Matrix::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Matrix::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_config: Orb::MatrixConfig,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Matrix::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :matrix
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Matrix::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_config: Orb::MatrixConfig,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :matrix,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Matrix::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Matrix::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Matrix::price_type]
        end
      end

      type tiered =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Tiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Tiered::price_type,
          tiered_config: Orb::TieredConfig,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class Tiered < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Tiered::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Tiered::price_type

        attr_accessor tiered_config: Orb::TieredConfig

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Tiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Tiered::price_type,
          tiered_config: Orb::TieredConfig,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :tiered
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Tiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Tiered::price_type,
          tiered_config: Orb::TieredConfig,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Tiered::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Tiered::price_type]
        end
      end

      type tiered_bps =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBPS::price_type,
          tiered_bps_config: Orb::TieredBPSConfig,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class TieredBPS < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredBPS::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredBPS::price_type

        attr_accessor tiered_bps_config: Orb::TieredBPSConfig

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBPS::price_type,
          tiered_bps_config: Orb::TieredBPSConfig,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :tiered_bps
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBPS::price_type,
          tiered_bps_config: Orb::TieredBPSConfig,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredBPS::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredBPS::price_type]
        end
      end

      type bps =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bps_config: Orb::BPSConfig,
          cadence: Orb::Models::Price::BPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BPS::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class BPS < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor bps_config: Orb::BPSConfig

        attr_accessor cadence: Orb::Models::Price::BPS::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BPS::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bps_config: Orb::BPSConfig,
          cadence: Orb::Models::Price::BPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BPS::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :bps
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bps_config: Orb::BPSConfig,
          cadence: Orb::Models::Price::BPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BPS::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BPS::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BPS::price_type]
        end
      end

      type bulk_bps =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_bps_config: Orb::BulkBPSConfig,
          cadence: Orb::Models::Price::BulkBPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBPS::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class BulkBPS < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor bulk_bps_config: Orb::BulkBPSConfig

        attr_accessor cadence: Orb::Models::Price::BulkBPS::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk_bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkBPS::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_bps_config: Orb::BulkBPSConfig,
          cadence: Orb::Models::Price::BulkBPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBPS::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :bulk_bps
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_bps_config: Orb::BulkBPSConfig,
          cadence: Orb::Models::Price::BulkBPS::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBPS::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkBPS::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkBPS::price_type]
        end
      end

      type bulk =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_config: Orb::BulkConfig,
          cadence: Orb::Models::Price::Bulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bulk::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class Bulk < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor bulk_config: Orb::BulkConfig

        attr_accessor cadence: Orb::Models::Price::Bulk::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Bulk::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_config: Orb::BulkConfig,
          cadence: Orb::Models::Price::Bulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bulk::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :bulk
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_config: Orb::BulkConfig,
          cadence: Orb::Models::Price::Bulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bulk::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Bulk::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Bulk::price_type]
        end
      end

      type threshold_total_amount =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmount::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :threshold_total_amount,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmount::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class ThresholdTotalAmount < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ThresholdTotalAmount::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :threshold_total_amount

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ThresholdTotalAmount::price_type

        attr_accessor threshold_total_amount_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmount::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmount::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :threshold_total_amount
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmount::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :threshold_total_amount,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmount::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::price_type]
        end
      end

      type tiered_package =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackage::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class TieredPackage < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPackage::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPackage::price_type

        attr_accessor tiered_package_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackage::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :tiered_package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackage::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::price_type]
        end
      end

      type grouped_tiered =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTiered::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class GroupedTiered < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedTiered::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_tiered_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_tiered

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedTiered::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTiered::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :grouped_tiered
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTiered::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::price_type]
        end
      end

      type tiered_with_minimum =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimum::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class TieredWithMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredWithMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_with_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredWithMinimum::price_type

        attr_accessor tiered_with_minimum_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimum::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :tiered_with_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimum::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::price_type]
        end
      end

      type tiered_package_with_minimum =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class TieredPackageWithMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_package_with_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type

        attr_accessor tiered_package_with_minimum_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :tiered_package_with_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::price_type]
        end
      end

      type package_with_allocation =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :package_with_allocation,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocation::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class PackageWithAllocation < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::PackageWithAllocation::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :package_with_allocation

        attr_accessor name: String

        attr_accessor package_with_allocation_config: ::Hash[Symbol, top]

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::PackageWithAllocation::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocation::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :package_with_allocation
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :package_with_allocation,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocation::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::price_type]
        end
      end

      type unit_with_percent =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercent::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_percent,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercent::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class UnitWithPercent < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitWithPercent::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit_with_percent

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitWithPercent::price_type

        attr_accessor unit_with_percent_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercent::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercent::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :unit_with_percent
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercent::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_percent,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercent::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::price_type]
        end
      end

      type matrix_with_allocation =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_with_allocation_config: Orb::MatrixWithAllocationConfig,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocation::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class MatrixWithAllocation < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixWithAllocation::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor matrix_with_allocation_config: Orb::MatrixWithAllocationConfig

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix_with_allocation

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixWithAllocation::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_with_allocation_config: Orb::MatrixWithAllocationConfig,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocation::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :matrix_with_allocation
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_with_allocation_config: Orb::MatrixWithAllocationConfig,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocation::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::price_type]
        end
      end

      type tiered_with_proration =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProration::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class TieredWithProration < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredWithProration::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredWithProration::price_type

        attr_accessor tiered_with_proration_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProration::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :tiered_with_proration
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProration::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::price_type]
        end
      end

      type unit_with_proration =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProration::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class UnitWithProration < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitWithProration::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitWithProration::price_type

        attr_accessor unit_with_proration_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProration::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :unit_with_proration
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProration::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::price_type]
        end
      end

      type grouped_allocation =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocation::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class GroupedAllocation < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedAllocation::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_allocation_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_allocation

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedAllocation::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocation::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :grouped_allocation
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocation::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::price_type]
        end
      end

      type grouped_with_prorated_minimum =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_prorated_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class GroupedWithProratedMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_with_prorated_minimum_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_with_prorated_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :grouped_with_prorated_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_prorated_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::price_type]
        end
      end

      type grouped_with_metered_minimum =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_metered_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class GroupedWithMeteredMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_with_metered_minimum_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_with_metered_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :grouped_with_metered_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_metered_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::price_type]
        end
      end

      type matrix_with_display_name =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayName::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_display_name,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayName::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class MatrixWithDisplayName < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixWithDisplayName::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor matrix_with_display_name_config: ::Hash[Symbol, top]

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix_with_display_name

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixWithDisplayName::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayName::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayName::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :matrix_with_display_name
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayName::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_display_name,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayName::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::price_type]
        end
      end

      type bulk_with_proration =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProration::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class BulkWithProration < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor bulk_with_proration_config: ::Hash[Symbol, top]

        attr_accessor cadence: Orb::Models::Price::BulkWithProration::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkWithProration::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProration::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :bulk_with_proration
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProration::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::price_type]
        end
      end

      type grouped_tiered_package =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackage::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class GroupedTieredPackage < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedTieredPackage::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_tiered_package_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedTieredPackage::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackage::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :grouped_tiered_package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackage::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::price_type]
        end
      end

      type max_group_tiered_package =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :max_group_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class MaxGroupTieredPackage < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor max_group_tiered_package_config: ::Hash[Symbol, top]

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :max_group_tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :max_group_tiered_package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :max_group_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::price_type]
        end
      end

      type scalable_matrix_with_unit_pricing =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_unit_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class ScalableMatrixWithUnitPricing < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :scalable_matrix_with_unit_pricing

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type

        attr_accessor scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :scalable_matrix_with_unit_pricing
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_unit_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type]
        end
      end

      type scalable_matrix_with_tiered_pricing =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_tiered_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class ScalableMatrixWithTieredPricing < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :scalable_matrix_with_tiered_pricing

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type

        attr_accessor scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :scalable_matrix_with_tiered_pricing
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_tiered_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type]
        end
      end

      type cumulative_grouped_bulk =
        {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :cumulative_grouped_bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

      class CumulativeGroupedBulk < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::BillableMetricTiny?

        attr_accessor billing_cycle_configuration: Orb::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Allocation?

        attr_accessor cumulative_grouped_bulk_config: ::Hash[Symbol, top]

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::BillingCycleConfiguration?

        attr_accessor item: Orb::ItemSlim

        attr_accessor maximum: Orb::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :cumulative_grouped_bulk

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type

        attr_accessor dimensional_price_configuration: Orb::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type,
          ?dimensional_price_configuration: Orb::DimensionalPriceConfiguration?,
          ?model_type: :cumulative_grouped_bulk
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::BillableMetricTiny?,
          billing_cycle_configuration: Orb::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Allocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::BillingCycleConfiguration?,
          item: Orb::ItemSlim,
          maximum: Orb::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Minimum?,
          minimum_amount: String?,
          model_type: :cumulative_grouped_bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type,
          dimensional_price_configuration: Orb::DimensionalPriceConfiguration?
        }

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::cadence]
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::price_type]
        end
      end

      def self?.variants: -> ::Array[Orb::Models::price]
    end
  end
end
