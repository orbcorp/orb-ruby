module Orb
  module Models
    type price =
      Orb::Models::Price::UnitPrice
      | Orb::Models::Price::PackagePrice
      | Orb::Models::Price::MatrixPrice
      | Orb::Models::Price::TieredPrice
      | Orb::Models::Price::TieredBpsPrice
      | Orb::Models::Price::BpsPrice
      | Orb::Models::Price::BulkBpsPrice
      | Orb::Models::Price::BulkPrice
      | Orb::Models::Price::ThresholdTotalAmountPrice
      | Orb::Models::Price::TieredPackagePrice
      | Orb::Models::Price::GroupedTieredPrice
      | Orb::Models::Price::TieredWithMinimumPrice
      | Orb::Models::Price::TieredPackageWithMinimumPrice
      | Orb::Models::Price::PackageWithAllocationPrice
      | Orb::Models::Price::UnitWithPercentPrice
      | Orb::Models::Price::MatrixWithAllocationPrice
      | Orb::Models::Price::TieredWithProrationPrice
      | Orb::Models::Price::UnitWithProrationPrice
      | Orb::Models::Price::GroupedAllocationPrice
      | Orb::Models::Price::GroupedWithProratedMinimumPrice
      | Orb::Models::Price::GroupedWithMeteredMinimumPrice
      | Orb::Models::Price::MatrixWithDisplayNamePrice
      | Orb::Models::Price::BulkWithProrationPrice
      | Orb::Models::Price::GroupedTieredPackagePrice
      | Orb::Models::Price::MaxGroupTieredPackagePrice
      | Orb::Models::Price::ScalableMatrixWithUnitPricingPrice
      | Orb::Models::Price::ScalableMatrixWithTieredPricingPrice
      | Orb::Models::Price::CumulativeGroupedBulkPrice

    module Price
      extend Orb::Union

      type unit_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::UnitPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::UnitPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::UnitPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::UnitPrice::Item,
          maximum: Orb::Models::Price::UnitPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::UnitPrice::Minimum?,
          minimum_amount: String?,
          model_type: :unit,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitPrice::price_type,
          unit_config: Orb::Models::Price::UnitPrice::UnitConfig,
          dimensional_price_configuration: Orb::Models::Price::UnitPrice::DimensionalPriceConfiguration?
        }

      class UnitPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::UnitPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::UnitPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::UnitPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::UnitPrice::Item

        attr_accessor maximum: Orb::Models::Price::UnitPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::UnitPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitPrice::price_type

        attr_accessor unit_config: Orb::Models::Price::UnitPrice::UnitConfig

        attr_accessor dimensional_price_configuration: Orb::Models::Price::UnitPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::UnitPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::UnitPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::UnitPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::UnitPrice::Item,
          maximum: Orb::Models::Price::UnitPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::UnitPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitPrice::price_type,
          unit_config: Orb::Models::Price::UnitPrice::UnitConfig,
          ?dimensional_price_configuration: Orb::Models::Price::UnitPrice::DimensionalPriceConfiguration?,
          ?model_type: :unit
        ) -> void

        def to_hash: -> Orb::Models::Price::unit_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitPrice::price_type]
        end

        type unit_config = { unit_amount: String }

        class UnitConfig < Orb::BaseModel
          attr_accessor unit_amount: String

          def initialize: (unit_amount: String) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::unit_config
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitPrice::dimensional_price_configuration
        end
      end

      type package_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::PackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::PackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::PackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::PackagePrice::Item,
          maximum: Orb::Models::Price::PackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::PackagePrice::Minimum?,
          minimum_amount: String?,
          model_type: :package,
          name: String,
          package_config: Orb::Models::Price::PackagePrice::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackagePrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::PackagePrice::DimensionalPriceConfiguration?
        }

      class PackagePrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::PackagePrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::PackagePrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::PackagePrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::PackagePrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::PackagePrice::Item

        attr_accessor maximum: Orb::Models::Price::PackagePrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::PackagePrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :package

        attr_accessor name: String

        attr_accessor package_config: Orb::Models::Price::PackagePrice::PackageConfig

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::PackagePrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::PackagePrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::PackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::PackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::PackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::PackagePrice::Item,
          maximum: Orb::Models::Price::PackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::PackagePrice::Minimum?,
          minimum_amount: String?,
          name: String,
          package_config: Orb::Models::Price::PackagePrice::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackagePrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::PackagePrice::DimensionalPriceConfiguration?,
          ?model_type: :package
        ) -> void

        def to_hash: -> Orb::Models::Price::package_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackagePrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::PackagePrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::PackagePrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::PackagePrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::PackagePrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::PackagePrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::minimum
        end

        type package_config = { package_amount: String, package_size: Integer }

        class PackageConfig < Orb::BaseModel
          attr_accessor package_amount: String

          attr_accessor package_size: Integer

          def initialize: (
            package_amount: String,
            package_size: Integer
          ) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::package_config
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::PackagePrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::PackagePrice::dimensional_price_configuration
        end
      end

      type matrix_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::MatrixPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MatrixPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MatrixPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MatrixPrice::Item,
          matrix_config: Orb::Models::Price::MatrixPrice::MatrixConfig,
          maximum: Orb::Models::Price::MatrixPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MatrixPrice::Minimum?,
          minimum_amount: String?,
          model_type: :matrix,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::MatrixPrice::DimensionalPriceConfiguration?
        }

      class MatrixPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::MatrixPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::MatrixPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::MatrixPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::MatrixPrice::Item

        attr_accessor matrix_config: Orb::Models::Price::MatrixPrice::MatrixConfig

        attr_accessor maximum: Orb::Models::Price::MatrixPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::MatrixPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::MatrixPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::MatrixPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MatrixPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MatrixPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MatrixPrice::Item,
          matrix_config: Orb::Models::Price::MatrixPrice::MatrixConfig,
          maximum: Orb::Models::Price::MatrixPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MatrixPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::MatrixPrice::DimensionalPriceConfiguration?,
          ?model_type: :matrix
        ) -> void

        def to_hash: -> Orb::Models::Price::matrix_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::item
        end

        type matrix_config =
          {
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Models::Price::MatrixPrice::MatrixConfig::MatrixValue]
          }

        class MatrixConfig < Orb::BaseModel
          attr_accessor default_unit_amount: String

          attr_accessor dimensions: ::Array[String?]

          attr_accessor matrix_values: ::Array[Orb::Models::Price::MatrixPrice::MatrixConfig::MatrixValue]

          def initialize: (
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Models::Price::MatrixPrice::MatrixConfig::MatrixValue]
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::matrix_config

          type matrix_value =
            { dimension_values: ::Array[String?], unit_amount: String }

          class MatrixValue < Orb::BaseModel
            attr_accessor dimension_values: ::Array[String?]

            attr_accessor unit_amount: String

            def initialize: (
              dimension_values: ::Array[String?],
              unit_amount: String
            ) -> void

            def to_hash: -> Orb::Models::Price::MatrixPrice::MatrixConfig::matrix_value
          end
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixPrice::dimensional_price_configuration
        end
      end

      type tiered_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::TieredPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredPrice::Item,
          maximum: Orb::Models::Price::TieredPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredPrice::Minimum?,
          minimum_amount: String?,
          model_type: :tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPrice::price_type,
          tiered_config: Orb::Models::Price::TieredPrice::TieredConfig,
          dimensional_price_configuration: Orb::Models::Price::TieredPrice::DimensionalPriceConfiguration?
        }

      class TieredPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::TieredPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::TieredPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::TieredPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::TieredPrice::Item

        attr_accessor maximum: Orb::Models::Price::TieredPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::TieredPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPrice::price_type

        attr_accessor tiered_config: Orb::Models::Price::TieredPrice::TieredConfig

        attr_accessor dimensional_price_configuration: Orb::Models::Price::TieredPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::TieredPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredPrice::Item,
          maximum: Orb::Models::Price::TieredPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPrice::price_type,
          tiered_config: Orb::Models::Price::TieredPrice::TieredConfig,
          ?dimensional_price_configuration: Orb::Models::Price::TieredPrice::DimensionalPriceConfiguration?,
          ?model_type: :tiered
        ) -> void

        def to_hash: -> Orb::Models::Price::tiered_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPrice::price_type]
        end

        type tiered_config =
          {
            tiers: ::Array[Orb::Models::Price::TieredPrice::TieredConfig::Tier]
          }

        class TieredConfig < Orb::BaseModel
          attr_accessor tiers: ::Array[Orb::Models::Price::TieredPrice::TieredConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Models::Price::TieredPrice::TieredConfig::Tier]
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::tiered_config

          type tier =
            { first_unit: Float, unit_amount: String, last_unit: Float? }

          class Tier < Orb::BaseModel
            attr_accessor first_unit: Float

            attr_accessor unit_amount: String

            attr_accessor last_unit: Float?

            def initialize: (
              first_unit: Float,
              unit_amount: String,
              ?last_unit: Float?
            ) -> void

            def to_hash: -> Orb::Models::Price::TieredPrice::TieredConfig::tier
          end
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPrice::dimensional_price_configuration
        end
      end

      type tiered_bps_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::TieredBpsPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBpsPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredBpsPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredBpsPrice::Item,
          maximum: Orb::Models::Price::TieredBpsPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredBpsPrice::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBpsPrice::price_type,
          tiered_bps_config: Orb::Models::Price::TieredBpsPrice::TieredBpsConfig,
          dimensional_price_configuration: Orb::Models::Price::TieredBpsPrice::DimensionalPriceConfiguration?
        }

      class TieredBpsPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::TieredBpsPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredBpsPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::TieredBpsPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::TieredBpsPrice::Item

        attr_accessor maximum: Orb::Models::Price::TieredBpsPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::TieredBpsPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredBpsPrice::price_type

        attr_accessor tiered_bps_config: Orb::Models::Price::TieredBpsPrice::TieredBpsConfig

        attr_accessor dimensional_price_configuration: Orb::Models::Price::TieredBpsPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::TieredBpsPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBpsPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredBpsPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredBpsPrice::Item,
          maximum: Orb::Models::Price::TieredBpsPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredBpsPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBpsPrice::price_type,
          tiered_bps_config: Orb::Models::Price::TieredBpsPrice::TieredBpsConfig,
          ?dimensional_price_configuration: Orb::Models::Price::TieredBpsPrice::DimensionalPriceConfiguration?,
          ?model_type: :tiered_bps
        ) -> void

        def to_hash: -> Orb::Models::Price::tiered_bps_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredBpsPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredBpsPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredBpsPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredBpsPrice::price_type]
        end

        type tiered_bps_config =
          {
            tiers: ::Array[Orb::Models::Price::TieredBpsPrice::TieredBpsConfig::Tier]
          }

        class TieredBpsConfig < Orb::BaseModel
          attr_accessor tiers: ::Array[Orb::Models::Price::TieredBpsPrice::TieredBpsConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Models::Price::TieredBpsPrice::TieredBpsConfig::Tier]
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::tiered_bps_config

          type tier =
            {
              bps: Float,
              minimum_amount: String,
              maximum_amount: String?,
              per_unit_maximum: String?
            }

          class Tier < Orb::BaseModel
            attr_accessor bps: Float

            attr_accessor minimum_amount: String

            attr_accessor maximum_amount: String?

            attr_accessor per_unit_maximum: String?

            def initialize: (
              bps: Float,
              minimum_amount: String,
              ?maximum_amount: String?,
              ?per_unit_maximum: String?
            ) -> void

            def to_hash: -> Orb::Models::Price::TieredBpsPrice::TieredBpsConfig::tier
          end
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredBpsPrice::dimensional_price_configuration
        end
      end

      type bps_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::BpsPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BpsPrice::BillingCycleConfiguration,
          bps_config: Orb::Models::Price::BpsPrice::BpsConfig,
          cadence: Orb::Models::Price::BpsPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BpsPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BpsPrice::Item,
          maximum: Orb::Models::Price::BpsPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BpsPrice::Minimum?,
          minimum_amount: String?,
          model_type: :bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BpsPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::BpsPrice::DimensionalPriceConfiguration?
        }

      class BpsPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::BpsPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::BpsPrice::BillingCycleConfiguration

        attr_accessor bps_config: Orb::Models::Price::BpsPrice::BpsConfig

        attr_accessor cadence: Orb::Models::Price::BpsPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::BpsPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::BpsPrice::Item

        attr_accessor maximum: Orb::Models::Price::BpsPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::BpsPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BpsPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::BpsPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::BpsPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BpsPrice::BillingCycleConfiguration,
          bps_config: Orb::Models::Price::BpsPrice::BpsConfig,
          cadence: Orb::Models::Price::BpsPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BpsPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BpsPrice::Item,
          maximum: Orb::Models::Price::BpsPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BpsPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BpsPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::BpsPrice::DimensionalPriceConfiguration?,
          ?model_type: :bps
        ) -> void

        def to_hash: -> Orb::Models::Price::bps_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BpsPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BpsPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BpsPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BpsPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type bps_config = { bps: Float, per_unit_maximum: String? }

        class BpsConfig < Orb::BaseModel
          attr_accessor bps: Float

          attr_accessor per_unit_maximum: String?

          def initialize: (bps: Float, ?per_unit_maximum: String?) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::bps_config
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BpsPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BpsPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BpsPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BpsPrice::dimensional_price_configuration
        end
      end

      type bulk_bps_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::BulkBpsPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration,
          bulk_bps_config: Orb::Models::Price::BulkBpsPrice::BulkBpsConfig,
          cadence: Orb::Models::Price::BulkBpsPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BulkBpsPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BulkBpsPrice::Item,
          maximum: Orb::Models::Price::BulkBpsPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BulkBpsPrice::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBpsPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::BulkBpsPrice::DimensionalPriceConfiguration?
        }

      class BulkBpsPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::BulkBpsPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration

        attr_accessor bulk_bps_config: Orb::Models::Price::BulkBpsPrice::BulkBpsConfig

        attr_accessor cadence: Orb::Models::Price::BulkBpsPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::BulkBpsPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::BulkBpsPrice::Item

        attr_accessor maximum: Orb::Models::Price::BulkBpsPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::BulkBpsPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk_bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkBpsPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::BulkBpsPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::BulkBpsPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration,
          bulk_bps_config: Orb::Models::Price::BulkBpsPrice::BulkBpsConfig,
          cadence: Orb::Models::Price::BulkBpsPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BulkBpsPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BulkBpsPrice::Item,
          maximum: Orb::Models::Price::BulkBpsPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BulkBpsPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBpsPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::BulkBpsPrice::DimensionalPriceConfiguration?,
          ?model_type: :bulk_bps
        ) -> void

        def to_hash: -> Orb::Models::Price::bulk_bps_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkBpsPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type bulk_bps_config =
          {
            tiers: ::Array[Orb::Models::Price::BulkBpsPrice::BulkBpsConfig::Tier]
          }

        class BulkBpsConfig < Orb::BaseModel
          attr_accessor tiers: ::Array[Orb::Models::Price::BulkBpsPrice::BulkBpsConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Models::Price::BulkBpsPrice::BulkBpsConfig::Tier]
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::bulk_bps_config

          type tier =
            { bps: Float, maximum_amount: String?, per_unit_maximum: String? }

          class Tier < Orb::BaseModel
            attr_accessor bps: Float

            attr_accessor maximum_amount: String?

            attr_accessor per_unit_maximum: String?

            def initialize: (
              bps: Float,
              ?maximum_amount: String?,
              ?per_unit_maximum: String?
            ) -> void

            def to_hash: -> Orb::Models::Price::BulkBpsPrice::BulkBpsConfig::tier
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkBpsPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkBpsPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkBpsPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkBpsPrice::dimensional_price_configuration
        end
      end

      type bulk_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::BulkPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BulkPrice::BillingCycleConfiguration,
          bulk_config: Orb::Models::Price::BulkPrice::BulkConfig,
          cadence: Orb::Models::Price::BulkPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BulkPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BulkPrice::Item,
          maximum: Orb::Models::Price::BulkPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BulkPrice::Minimum?,
          minimum_amount: String?,
          model_type: :bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::BulkPrice::DimensionalPriceConfiguration?
        }

      class BulkPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::BulkPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::BulkPrice::BillingCycleConfiguration

        attr_accessor bulk_config: Orb::Models::Price::BulkPrice::BulkConfig

        attr_accessor cadence: Orb::Models::Price::BulkPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::BulkPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::BulkPrice::Item

        attr_accessor maximum: Orb::Models::Price::BulkPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::BulkPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::BulkPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::BulkPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BulkPrice::BillingCycleConfiguration,
          bulk_config: Orb::Models::Price::BulkPrice::BulkConfig,
          cadence: Orb::Models::Price::BulkPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BulkPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BulkPrice::Item,
          maximum: Orb::Models::Price::BulkPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BulkPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::BulkPrice::DimensionalPriceConfiguration?,
          ?model_type: :bulk
        ) -> void

        def to_hash: -> Orb::Models::Price::bulk_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type bulk_config =
          { tiers: ::Array[Orb::Models::Price::BulkPrice::BulkConfig::Tier] }

        class BulkConfig < Orb::BaseModel
          attr_accessor tiers: ::Array[Orb::Models::Price::BulkPrice::BulkConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Models::Price::BulkPrice::BulkConfig::Tier]
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::bulk_config

          type tier = { unit_amount: String, maximum_units: Float? }

          class Tier < Orb::BaseModel
            attr_accessor unit_amount: String

            attr_accessor maximum_units: Float?

            def initialize: (
              unit_amount: String,
              ?maximum_units: Float?
            ) -> void

            def to_hash: -> Orb::Models::Price::BulkPrice::BulkConfig::tier
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkPrice::dimensional_price_configuration
        end
      end

      type threshold_total_amount_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::ThresholdTotalAmountPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmountPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::ThresholdTotalAmountPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::ThresholdTotalAmountPrice::Item,
          maximum: Orb::Models::Price::ThresholdTotalAmountPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::ThresholdTotalAmountPrice::Minimum?,
          minimum_amount: String?,
          model_type: :threshold_total_amount,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmountPrice::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::DimensionalPriceConfiguration?
        }

      class ThresholdTotalAmountPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::ThresholdTotalAmountPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ThresholdTotalAmountPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::ThresholdTotalAmountPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::ThresholdTotalAmountPrice::Item

        attr_accessor maximum: Orb::Models::Price::ThresholdTotalAmountPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::ThresholdTotalAmountPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :threshold_total_amount

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ThresholdTotalAmountPrice::price_type

        attr_accessor threshold_total_amount_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::ThresholdTotalAmountPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmountPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::ThresholdTotalAmountPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::ThresholdTotalAmountPrice::Item,
          maximum: Orb::Models::Price::ThresholdTotalAmountPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::ThresholdTotalAmountPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmountPrice::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::ThresholdTotalAmountPrice::DimensionalPriceConfiguration?,
          ?model_type: :threshold_total_amount
        ) -> void

        def to_hash: -> Orb::Models::Price::threshold_total_amount_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmountPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmountPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmountPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmountPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ThresholdTotalAmountPrice::dimensional_price_configuration
        end
      end

      type tiered_package_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::TieredPackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredPackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredPackagePrice::Item,
          maximum: Orb::Models::Price::TieredPackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredPackagePrice::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackagePrice::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::TieredPackagePrice::DimensionalPriceConfiguration?
        }

      class TieredPackagePrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::TieredPackagePrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPackagePrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::TieredPackagePrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::TieredPackagePrice::Item

        attr_accessor maximum: Orb::Models::Price::TieredPackagePrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::TieredPackagePrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPackagePrice::price_type

        attr_accessor tiered_package_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::TieredPackagePrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::TieredPackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredPackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredPackagePrice::Item,
          maximum: Orb::Models::Price::TieredPackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredPackagePrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackagePrice::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::TieredPackagePrice::DimensionalPriceConfiguration?,
          ?model_type: :tiered_package
        ) -> void

        def to_hash: -> Orb::Models::Price::tiered_package_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackagePrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackagePrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackagePrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackagePrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackagePrice::dimensional_price_configuration
        end
      end

      type grouped_tiered_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::GroupedTieredPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedTieredPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedTieredPrice::Item,
          maximum: Orb::Models::Price::GroupedTieredPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedTieredPrice::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::GroupedTieredPrice::DimensionalPriceConfiguration?
        }

      class GroupedTieredPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::GroupedTieredPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedTieredPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::GroupedTieredPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_tiered_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::GroupedTieredPrice::Item

        attr_accessor maximum: Orb::Models::Price::GroupedTieredPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::GroupedTieredPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_tiered

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedTieredPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::GroupedTieredPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::GroupedTieredPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedTieredPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedTieredPrice::Item,
          maximum: Orb::Models::Price::GroupedTieredPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedTieredPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::GroupedTieredPrice::DimensionalPriceConfiguration?,
          ?model_type: :grouped_tiered
        ) -> void

        def to_hash: -> Orb::Models::Price::grouped_tiered_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPrice::dimensional_price_configuration
        end
      end

      type tiered_with_minimum_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::TieredWithMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredWithMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredWithMinimumPrice::Item,
          maximum: Orb::Models::Price::TieredWithMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredWithMinimumPrice::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimumPrice::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::TieredWithMinimumPrice::DimensionalPriceConfiguration?
        }

      class TieredWithMinimumPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::TieredWithMinimumPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredWithMinimumPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::TieredWithMinimumPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::TieredWithMinimumPrice::Item

        attr_accessor maximum: Orb::Models::Price::TieredWithMinimumPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::TieredWithMinimumPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_with_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredWithMinimumPrice::price_type

        attr_accessor tiered_with_minimum_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::TieredWithMinimumPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::TieredWithMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredWithMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredWithMinimumPrice::Item,
          maximum: Orb::Models::Price::TieredWithMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredWithMinimumPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimumPrice::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::TieredWithMinimumPrice::DimensionalPriceConfiguration?,
          ?model_type: :tiered_with_minimum
        ) -> void

        def to_hash: -> Orb::Models::Price::tiered_with_minimum_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimumPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimumPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimumPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimumPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithMinimumPrice::dimensional_price_configuration
        end
      end

      type tiered_package_with_minimum_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::TieredPackageWithMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredPackageWithMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredPackageWithMinimumPrice::Item,
          maximum: Orb::Models::Price::TieredPackageWithMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredPackageWithMinimumPrice::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimumPrice::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::DimensionalPriceConfiguration?
        }

      class TieredPackageWithMinimumPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::TieredPackageWithMinimumPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPackageWithMinimumPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::TieredPackageWithMinimumPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::TieredPackageWithMinimumPrice::Item

        attr_accessor maximum: Orb::Models::Price::TieredPackageWithMinimumPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::TieredPackageWithMinimumPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_package_with_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPackageWithMinimumPrice::price_type

        attr_accessor tiered_package_with_minimum_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::TieredPackageWithMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredPackageWithMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredPackageWithMinimumPrice::Item,
          maximum: Orb::Models::Price::TieredPackageWithMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredPackageWithMinimumPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimumPrice::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::TieredPackageWithMinimumPrice::DimensionalPriceConfiguration?,
          ?model_type: :tiered_package_with_minimum
        ) -> void

        def to_hash: -> Orb::Models::Price::tiered_package_with_minimum_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimumPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimumPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimumPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimumPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredPackageWithMinimumPrice::dimensional_price_configuration
        end
      end

      type package_with_allocation_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::PackageWithAllocationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::PackageWithAllocationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::PackageWithAllocationPrice::Item,
          maximum: Orb::Models::Price::PackageWithAllocationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::PackageWithAllocationPrice::Minimum?,
          minimum_amount: String?,
          model_type: :package_with_allocation,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocationPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::PackageWithAllocationPrice::DimensionalPriceConfiguration?
        }

      class PackageWithAllocationPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::PackageWithAllocationPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::PackageWithAllocationPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::PackageWithAllocationPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::PackageWithAllocationPrice::Item

        attr_accessor maximum: Orb::Models::Price::PackageWithAllocationPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::PackageWithAllocationPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :package_with_allocation

        attr_accessor name: String

        attr_accessor package_with_allocation_config: ::Hash[Symbol, top]

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::PackageWithAllocationPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::PackageWithAllocationPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::PackageWithAllocationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::PackageWithAllocationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::PackageWithAllocationPrice::Item,
          maximum: Orb::Models::Price::PackageWithAllocationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::PackageWithAllocationPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocationPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::PackageWithAllocationPrice::DimensionalPriceConfiguration?,
          ?model_type: :package_with_allocation
        ) -> void

        def to_hash: -> Orb::Models::Price::package_with_allocation_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocationPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocationPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocationPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocationPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::PackageWithAllocationPrice::dimensional_price_configuration
        end
      end

      type unit_with_percent_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::UnitWithPercentPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercentPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::UnitWithPercentPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::UnitWithPercentPrice::Item,
          maximum: Orb::Models::Price::UnitWithPercentPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::UnitWithPercentPrice::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_percent,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercentPrice::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::UnitWithPercentPrice::DimensionalPriceConfiguration?
        }

      class UnitWithPercentPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::UnitWithPercentPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitWithPercentPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::UnitWithPercentPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::UnitWithPercentPrice::Item

        attr_accessor maximum: Orb::Models::Price::UnitWithPercentPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::UnitWithPercentPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit_with_percent

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitWithPercentPrice::price_type

        attr_accessor unit_with_percent_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::UnitWithPercentPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::UnitWithPercentPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercentPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::UnitWithPercentPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::UnitWithPercentPrice::Item,
          maximum: Orb::Models::Price::UnitWithPercentPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::UnitWithPercentPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercentPrice::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::UnitWithPercentPrice::DimensionalPriceConfiguration?,
          ?model_type: :unit_with_percent
        ) -> void

        def to_hash: -> Orb::Models::Price::unit_with_percent_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercentPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercentPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercentPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercentPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithPercentPrice::dimensional_price_configuration
        end
      end

      type matrix_with_allocation_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::MatrixWithAllocationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MatrixWithAllocationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MatrixWithAllocationPrice::Item,
          matrix_with_allocation_config: Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig,
          maximum: Orb::Models::Price::MatrixWithAllocationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MatrixWithAllocationPrice::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocationPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::MatrixWithAllocationPrice::DimensionalPriceConfiguration?
        }

      class MatrixWithAllocationPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::MatrixWithAllocationPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixWithAllocationPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::MatrixWithAllocationPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::MatrixWithAllocationPrice::Item

        attr_accessor matrix_with_allocation_config: Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig

        attr_accessor maximum: Orb::Models::Price::MatrixWithAllocationPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::MatrixWithAllocationPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix_with_allocation

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixWithAllocationPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::MatrixWithAllocationPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::MatrixWithAllocationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MatrixWithAllocationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MatrixWithAllocationPrice::Item,
          matrix_with_allocation_config: Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig,
          maximum: Orb::Models::Price::MatrixWithAllocationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MatrixWithAllocationPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocationPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::MatrixWithAllocationPrice::DimensionalPriceConfiguration?,
          ?model_type: :matrix_with_allocation
        ) -> void

        def to_hash: -> Orb::Models::Price::matrix_with_allocation_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocationPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocationPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocationPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::item
        end

        type matrix_with_allocation_config =
          {
            allocation: Float,
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig::MatrixValue]
          }

        class MatrixWithAllocationConfig < Orb::BaseModel
          attr_accessor allocation: Float

          attr_accessor default_unit_amount: String

          attr_accessor dimensions: ::Array[String?]

          attr_accessor matrix_values: ::Array[Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig::MatrixValue]

          def initialize: (
            allocation: Float,
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig::MatrixValue]
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::matrix_with_allocation_config

          type matrix_value =
            { dimension_values: ::Array[String?], unit_amount: String }

          class MatrixValue < Orb::BaseModel
            attr_accessor dimension_values: ::Array[String?]

            attr_accessor unit_amount: String

            def initialize: (
              dimension_values: ::Array[String?],
              unit_amount: String
            ) -> void

            def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::MatrixWithAllocationConfig::matrix_value
          end
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocationPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithAllocationPrice::dimensional_price_configuration
        end
      end

      type tiered_with_proration_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::TieredWithProrationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProrationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredWithProrationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredWithProrationPrice::Item,
          maximum: Orb::Models::Price::TieredWithProrationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredWithProrationPrice::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProrationPrice::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::TieredWithProrationPrice::DimensionalPriceConfiguration?
        }

      class TieredWithProrationPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::TieredWithProrationPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredWithProrationPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::TieredWithProrationPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::TieredWithProrationPrice::Item

        attr_accessor maximum: Orb::Models::Price::TieredWithProrationPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::TieredWithProrationPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredWithProrationPrice::price_type

        attr_accessor tiered_with_proration_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::TieredWithProrationPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::TieredWithProrationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProrationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::TieredWithProrationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::TieredWithProrationPrice::Item,
          maximum: Orb::Models::Price::TieredWithProrationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::TieredWithProrationPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProrationPrice::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::TieredWithProrationPrice::DimensionalPriceConfiguration?,
          ?model_type: :tiered_with_proration
        ) -> void

        def to_hash: -> Orb::Models::Price::tiered_with_proration_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithProrationPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithProrationPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithProrationPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithProrationPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::TieredWithProrationPrice::dimensional_price_configuration
        end
      end

      type unit_with_proration_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::UnitWithProrationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProrationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::UnitWithProrationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::UnitWithProrationPrice::Item,
          maximum: Orb::Models::Price::UnitWithProrationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::UnitWithProrationPrice::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProrationPrice::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::UnitWithProrationPrice::DimensionalPriceConfiguration?
        }

      class UnitWithProrationPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::UnitWithProrationPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitWithProrationPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::UnitWithProrationPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::UnitWithProrationPrice::Item

        attr_accessor maximum: Orb::Models::Price::UnitWithProrationPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::UnitWithProrationPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitWithProrationPrice::price_type

        attr_accessor unit_with_proration_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::UnitWithProrationPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::UnitWithProrationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProrationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::UnitWithProrationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::UnitWithProrationPrice::Item,
          maximum: Orb::Models::Price::UnitWithProrationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::UnitWithProrationPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProrationPrice::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::UnitWithProrationPrice::DimensionalPriceConfiguration?,
          ?model_type: :unit_with_proration
        ) -> void

        def to_hash: -> Orb::Models::Price::unit_with_proration_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithProrationPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithProrationPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithProrationPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithProrationPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::UnitWithProrationPrice::dimensional_price_configuration
        end
      end

      type grouped_allocation_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::GroupedAllocationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedAllocationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedAllocationPrice::Item,
          maximum: Orb::Models::Price::GroupedAllocationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedAllocationPrice::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocationPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::GroupedAllocationPrice::DimensionalPriceConfiguration?
        }

      class GroupedAllocationPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::GroupedAllocationPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedAllocationPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::GroupedAllocationPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_allocation_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::GroupedAllocationPrice::Item

        attr_accessor maximum: Orb::Models::Price::GroupedAllocationPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::GroupedAllocationPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_allocation

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedAllocationPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::GroupedAllocationPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::GroupedAllocationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedAllocationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedAllocationPrice::Item,
          maximum: Orb::Models::Price::GroupedAllocationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedAllocationPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocationPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::GroupedAllocationPrice::DimensionalPriceConfiguration?,
          ?model_type: :grouped_allocation
        ) -> void

        def to_hash: -> Orb::Models::Price::grouped_allocation_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocationPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocationPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocationPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocationPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedAllocationPrice::dimensional_price_configuration
        end
      end

      type grouped_with_prorated_minimum_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedWithProratedMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedWithProratedMinimumPrice::Item,
          maximum: Orb::Models::Price::GroupedWithProratedMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedWithProratedMinimumPrice::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_prorated_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimumPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::DimensionalPriceConfiguration?
        }

      class GroupedWithProratedMinimumPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedWithProratedMinimumPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::GroupedWithProratedMinimumPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_with_prorated_minimum_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::GroupedWithProratedMinimumPrice::Item

        attr_accessor maximum: Orb::Models::Price::GroupedWithProratedMinimumPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::GroupedWithProratedMinimumPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_with_prorated_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedWithProratedMinimumPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedWithProratedMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedWithProratedMinimumPrice::Item,
          maximum: Orb::Models::Price::GroupedWithProratedMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedWithProratedMinimumPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimumPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::GroupedWithProratedMinimumPrice::DimensionalPriceConfiguration?,
          ?model_type: :grouped_with_prorated_minimum
        ) -> void

        def to_hash: -> Orb::Models::Price::grouped_with_prorated_minimum_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimumPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimumPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimumPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimumPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithProratedMinimumPrice::dimensional_price_configuration
        end
      end

      type grouped_with_metered_minimum_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedWithMeteredMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Item,
          maximum: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_metered_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimumPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::DimensionalPriceConfiguration?
        }

      class GroupedWithMeteredMinimumPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedWithMeteredMinimumPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::GroupedWithMeteredMinimumPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_with_metered_minimum_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Item

        attr_accessor maximum: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_with_metered_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedWithMeteredMinimumPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimumPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedWithMeteredMinimumPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Item,
          maximum: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedWithMeteredMinimumPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimumPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::GroupedWithMeteredMinimumPrice::DimensionalPriceConfiguration?,
          ?model_type: :grouped_with_metered_minimum
        ) -> void

        def to_hash: -> Orb::Models::Price::grouped_with_metered_minimum_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimumPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimumPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimumPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimumPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedWithMeteredMinimumPrice::dimensional_price_configuration
        end
      end

      type matrix_with_display_name_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::MatrixWithDisplayNamePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayNamePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MatrixWithDisplayNamePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MatrixWithDisplayNamePrice::Item,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Models::Price::MatrixWithDisplayNamePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MatrixWithDisplayNamePrice::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_display_name,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayNamePrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::DimensionalPriceConfiguration?
        }

      class MatrixWithDisplayNamePrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::MatrixWithDisplayNamePrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixWithDisplayNamePrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::MatrixWithDisplayNamePrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::MatrixWithDisplayNamePrice::Item

        attr_accessor matrix_with_display_name_config: ::Hash[Symbol, top]

        attr_accessor maximum: Orb::Models::Price::MatrixWithDisplayNamePrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::MatrixWithDisplayNamePrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix_with_display_name

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixWithDisplayNamePrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::MatrixWithDisplayNamePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayNamePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MatrixWithDisplayNamePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MatrixWithDisplayNamePrice::Item,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Models::Price::MatrixWithDisplayNamePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MatrixWithDisplayNamePrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayNamePrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::MatrixWithDisplayNamePrice::DimensionalPriceConfiguration?,
          ?model_type: :matrix_with_display_name
        ) -> void

        def to_hash: -> Orb::Models::Price::matrix_with_display_name_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayNamePrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayNamePrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayNamePrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayNamePrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MatrixWithDisplayNamePrice::dimensional_price_configuration
        end
      end

      type bulk_with_proration_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::BulkWithProrationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProrationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BulkWithProrationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BulkWithProrationPrice::Item,
          maximum: Orb::Models::Price::BulkWithProrationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BulkWithProrationPrice::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProrationPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::BulkWithProrationPrice::DimensionalPriceConfiguration?
        }

      class BulkWithProrationPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::BulkWithProrationPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration

        attr_accessor bulk_with_proration_config: ::Hash[Symbol, top]

        attr_accessor cadence: Orb::Models::Price::BulkWithProrationPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::BulkWithProrationPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::BulkWithProrationPrice::Item

        attr_accessor maximum: Orb::Models::Price::BulkWithProrationPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::BulkWithProrationPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkWithProrationPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::BulkWithProrationPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::BulkWithProrationPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProrationPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::BulkWithProrationPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::BulkWithProrationPrice::Item,
          maximum: Orb::Models::Price::BulkWithProrationPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::BulkWithProrationPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProrationPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::BulkWithProrationPrice::DimensionalPriceConfiguration?,
          ?model_type: :bulk_with_proration
        ) -> void

        def to_hash: -> Orb::Models::Price::bulk_with_proration_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkWithProrationPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkWithProrationPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkWithProrationPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkWithProrationPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::BulkWithProrationPrice::dimensional_price_configuration
        end
      end

      type grouped_tiered_package_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::GroupedTieredPackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedTieredPackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedTieredPackagePrice::Item,
          maximum: Orb::Models::Price::GroupedTieredPackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedTieredPackagePrice::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackagePrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::GroupedTieredPackagePrice::DimensionalPriceConfiguration?
        }

      class GroupedTieredPackagePrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::GroupedTieredPackagePrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedTieredPackagePrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::GroupedTieredPackagePrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_tiered_package_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::GroupedTieredPackagePrice::Item

        attr_accessor maximum: Orb::Models::Price::GroupedTieredPackagePrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::GroupedTieredPackagePrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedTieredPackagePrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::GroupedTieredPackagePrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::GroupedTieredPackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::GroupedTieredPackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::GroupedTieredPackagePrice::Item,
          maximum: Orb::Models::Price::GroupedTieredPackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::GroupedTieredPackagePrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackagePrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::GroupedTieredPackagePrice::DimensionalPriceConfiguration?,
          ?model_type: :grouped_tiered_package
        ) -> void

        def to_hash: -> Orb::Models::Price::grouped_tiered_package_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackagePrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackagePrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackagePrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackagePrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::GroupedTieredPackagePrice::dimensional_price_configuration
        end
      end

      type max_group_tiered_package_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::MaxGroupTieredPackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MaxGroupTieredPackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MaxGroupTieredPackagePrice::Item,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Models::Price::MaxGroupTieredPackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MaxGroupTieredPackagePrice::Minimum?,
          minimum_amount: String?,
          model_type: :max_group_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackagePrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::DimensionalPriceConfiguration?
        }

      class MaxGroupTieredPackagePrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::MaxGroupTieredPackagePrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MaxGroupTieredPackagePrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::MaxGroupTieredPackagePrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::MaxGroupTieredPackagePrice::Item

        attr_accessor max_group_tiered_package_config: ::Hash[Symbol, top]

        attr_accessor maximum: Orb::Models::Price::MaxGroupTieredPackagePrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::MaxGroupTieredPackagePrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :max_group_tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MaxGroupTieredPackagePrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::MaxGroupTieredPackagePrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackagePrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::MaxGroupTieredPackagePrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::MaxGroupTieredPackagePrice::Item,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Models::Price::MaxGroupTieredPackagePrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::MaxGroupTieredPackagePrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackagePrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::MaxGroupTieredPackagePrice::DimensionalPriceConfiguration?,
          ?model_type: :max_group_tiered_package
        ) -> void

        def to_hash: -> Orb::Models::Price::max_group_tiered_package_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackagePrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackagePrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackagePrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackagePrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::MaxGroupTieredPackagePrice::dimensional_price_configuration
        end
      end

      type scalable_matrix_with_unit_pricing_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Item,
          maximum: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_unit_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::DimensionalPriceConfiguration?
        }

      class ScalableMatrixWithUnitPricingPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Item

        attr_accessor maximum: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :scalable_matrix_with_unit_pricing

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::price_type

        attr_accessor scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Item,
          maximum: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::DimensionalPriceConfiguration?,
          ?model_type: :scalable_matrix_with_unit_pricing
        ) -> void

        def to_hash: -> Orb::Models::Price::scalable_matrix_with_unit_pricing_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithUnitPricingPrice::dimensional_price_configuration
        end
      end

      type scalable_matrix_with_tiered_pricing_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Item,
          maximum: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_tiered_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::DimensionalPriceConfiguration?
        }

      class ScalableMatrixWithTieredPricingPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Item

        attr_accessor maximum: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :scalable_matrix_with_tiered_pricing

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::price_type

        attr_accessor scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Item,
          maximum: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::DimensionalPriceConfiguration?,
          ?model_type: :scalable_matrix_with_tiered_pricing
        ) -> void

        def to_hash: -> Orb::Models::Price::scalable_matrix_with_tiered_pricing_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::ScalableMatrixWithTieredPricingPrice::dimensional_price_configuration
        end
      end

      type cumulative_grouped_bulk_price =
        {
          id: String,
          billable_metric: Orb::Models::Price::CumulativeGroupedBulkPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulkPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::CumulativeGroupedBulkPrice::CreditAllocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::CumulativeGroupedBulkPrice::Item,
          maximum: Orb::Models::Price::CumulativeGroupedBulkPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::CumulativeGroupedBulkPrice::Minimum?,
          minimum_amount: String?,
          model_type: :cumulative_grouped_bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulkPrice::price_type,
          dimensional_price_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::DimensionalPriceConfiguration?
        }

      class CumulativeGroupedBulkPrice < Orb::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Models::Price::CumulativeGroupedBulkPrice::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::CumulativeGroupedBulkPrice::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Models::Price::CumulativeGroupedBulkPrice::CreditAllocation?

        attr_accessor cumulative_grouped_bulk_config: ::Hash[Symbol, top]

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Models::Price::CumulativeGroupedBulkPrice::Item

        attr_accessor maximum: Orb::Models::Price::CumulativeGroupedBulkPrice::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Models::Price::CumulativeGroupedBulkPrice::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :cumulative_grouped_bulk

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::CumulativeGroupedBulkPrice::price_type

        attr_accessor dimensional_price_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Models::Price::CumulativeGroupedBulkPrice::BillableMetric?,
          billing_cycle_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulkPrice::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Models::Price::CumulativeGroupedBulkPrice::CreditAllocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration?,
          item: Orb::Models::Price::CumulativeGroupedBulkPrice::Item,
          maximum: Orb::Models::Price::CumulativeGroupedBulkPrice::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Models::Price::CumulativeGroupedBulkPrice::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulkPrice::price_type,
          ?dimensional_price_configuration: Orb::Models::Price::CumulativeGroupedBulkPrice::DimensionalPriceConfiguration?,
          ?model_type: :cumulative_grouped_bulk
        ) -> void

        def to_hash: -> Orb::Models::Price::cumulative_grouped_bulk_price

        type billable_metric = { id: String }

        class BillableMetric < Orb::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::billable_metric
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::billing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulkPrice::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulkPrice::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::credit_allocation
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::invoicing_cycle_configuration

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulkPrice::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::item
        end

        type maximum =
          { applies_to_price_ids: ::Array[String], maximum_amount: String }

        class Maximum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            maximum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::maximum
        end

        type minimum =
          { applies_to_price_ids: ::Array[String], minimum_amount: String }

        class Minimum < Orb::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            minimum_amount: String
          ) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::minimum
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulkPrice::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> Orb::Models::Price::CumulativeGroupedBulkPrice::dimensional_price_configuration
        end
      end

      def self?.variants: -> [Orb::Models::Price::UnitPrice, Orb::Models::Price::PackagePrice, Orb::Models::Price::MatrixPrice, Orb::Models::Price::TieredPrice, Orb::Models::Price::TieredBpsPrice, Orb::Models::Price::BpsPrice, Orb::Models::Price::BulkBpsPrice, Orb::Models::Price::BulkPrice, Orb::Models::Price::ThresholdTotalAmountPrice, Orb::Models::Price::TieredPackagePrice, Orb::Models::Price::GroupedTieredPrice, Orb::Models::Price::TieredWithMinimumPrice, Orb::Models::Price::TieredPackageWithMinimumPrice, Orb::Models::Price::PackageWithAllocationPrice, Orb::Models::Price::UnitWithPercentPrice, Orb::Models::Price::MatrixWithAllocationPrice, Orb::Models::Price::TieredWithProrationPrice, Orb::Models::Price::UnitWithProrationPrice, Orb::Models::Price::GroupedAllocationPrice, Orb::Models::Price::GroupedWithProratedMinimumPrice, Orb::Models::Price::GroupedWithMeteredMinimumPrice, Orb::Models::Price::MatrixWithDisplayNamePrice, Orb::Models::Price::BulkWithProrationPrice, Orb::Models::Price::GroupedTieredPackagePrice, Orb::Models::Price::MaxGroupTieredPackagePrice, Orb::Models::Price::ScalableMatrixWithUnitPricingPrice, Orb::Models::Price::ScalableMatrixWithTieredPricingPrice, Orb::Models::Price::CumulativeGroupedBulkPrice]
    end
  end
end
