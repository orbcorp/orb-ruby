module Orb
  module Models
    type price =
      Orb::Price::Unit
      | Orb::Price::Package
      | Orb::Price::Matrix
      | Orb::Price::Tiered
      | Orb::Price::TieredBps
      | Orb::Price::Bps
      | Orb::Price::BulkBps
      | Orb::Price::Bulk
      | Orb::Price::ThresholdTotalAmount
      | Orb::Price::TieredPackage
      | Orb::Price::GroupedTiered
      | Orb::Price::TieredWithMinimum
      | Orb::Price::TieredPackageWithMinimum
      | Orb::Price::PackageWithAllocation
      | Orb::Price::UnitWithPercent
      | Orb::Price::MatrixWithAllocation
      | Orb::Price::TieredWithProration
      | Orb::Price::UnitWithProration
      | Orb::Price::GroupedAllocation
      | Orb::Price::GroupedWithProratedMinimum
      | Orb::Price::GroupedWithMeteredMinimum
      | Orb::Price::MatrixWithDisplayName
      | Orb::Price::BulkWithProration
      | Orb::Price::GroupedTieredPackage
      | Orb::Price::MaxGroupTieredPackage
      | Orb::Price::ScalableMatrixWithUnitPricing
      | Orb::Price::ScalableMatrixWithTieredPricing
      | Orb::Price::CumulativeGroupedBulk

    module Price
      extend Orb::Internal::Type::Union

      type unit =
        {
          id: String,
          billable_metric: Orb::Price::Unit::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Unit::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Unit::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Unit::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Unit::InvoicingCycleConfiguration?,
          item: Orb::Price::Unit::Item,
          maximum: Orb::Price::Unit::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Unit::Minimum?,
          minimum_amount: String?,
          model_type: :unit,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Unit::price_type,
          unit_config: Orb::Price::Unit::UnitConfig,
          dimensional_price_configuration: Orb::Price::Unit::DimensionalPriceConfiguration?
        }

      class Unit < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::Unit::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::Unit::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Unit::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::Unit::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::Unit::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::Unit::Item

        attr_accessor maximum: Orb::Price::Unit::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::Unit::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Unit::price_type

        attr_accessor unit_config: Orb::Price::Unit::UnitConfig

        attr_accessor dimensional_price_configuration: Orb::Price::Unit::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::Unit::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Unit::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Unit::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Unit::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Unit::InvoicingCycleConfiguration?,
          item: Orb::Price::Unit::Item,
          maximum: Orb::Price::Unit::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Unit::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Unit::price_type,
          unit_config: Orb::Price::Unit::UnitConfig,
          ?dimensional_price_configuration: Orb::Price::Unit::DimensionalPriceConfiguration?,
          ?model_type: :unit
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::Unit::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Unit::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Unit::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Unit::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Unit::InvoicingCycleConfiguration?,
          item: Orb::Price::Unit::Item,
          maximum: Orb::Price::Unit::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Unit::Minimum?,
          minimum_amount: String?,
          model_type: :unit,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Unit::price_type,
          unit_config: Orb::Price::Unit::UnitConfig,
          dimensional_price_configuration: Orb::Price::Unit::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Unit::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Unit::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Unit::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Unit::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Unit::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Unit::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Unit::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Unit::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Unit::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Unit::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Unit::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Unit::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Unit::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Unit::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Unit::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Unit::Maximum::Filter::field,
              operator: Orb::Models::Price::Unit::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Unit::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::Unit::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Unit::Maximum::Filter::field,
              operator: Orb::Models::Price::Unit::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Unit::Maximum::Filter::field,
              operator: Orb::Models::Price::Unit::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Unit::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Unit::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Unit::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Unit::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Unit::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Unit::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Unit::Minimum::Filter::field,
              operator: Orb::Models::Price::Unit::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Unit::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::Unit::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Unit::Minimum::Filter::field,
              operator: Orb::Models::Price::Unit::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Unit::Minimum::Filter::field,
              operator: Orb::Models::Price::Unit::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Unit::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Unit::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Unit::price_type]
        end

        type unit_config = { unit_amount: String }

        class UnitConfig < Orb::Internal::Type::BaseModel
          attr_accessor unit_amount: String

          def initialize: (unit_amount: String) -> void

          def to_hash: -> { unit_amount: String }
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type package =
        {
          id: String,
          billable_metric: Orb::Price::Package::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Package::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Package::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Package::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Package::InvoicingCycleConfiguration?,
          item: Orb::Price::Package::Item,
          maximum: Orb::Price::Package::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Package::Minimum?,
          minimum_amount: String?,
          model_type: :package,
          name: String,
          package_config: Orb::Price::Package::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Package::price_type,
          dimensional_price_configuration: Orb::Price::Package::DimensionalPriceConfiguration?
        }

      class Package < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::Package::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::Package::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Package::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::Package::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::Package::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::Package::Item

        attr_accessor maximum: Orb::Price::Package::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::Package::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :package

        attr_accessor name: String

        attr_accessor package_config: Orb::Price::Package::PackageConfig

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Package::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::Package::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::Package::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Package::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Package::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Package::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Package::InvoicingCycleConfiguration?,
          item: Orb::Price::Package::Item,
          maximum: Orb::Price::Package::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Package::Minimum?,
          minimum_amount: String?,
          name: String,
          package_config: Orb::Price::Package::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Package::price_type,
          ?dimensional_price_configuration: Orb::Price::Package::DimensionalPriceConfiguration?,
          ?model_type: :package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::Package::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Package::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Package::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Package::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Package::InvoicingCycleConfiguration?,
          item: Orb::Price::Package::Item,
          maximum: Orb::Price::Package::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Package::Minimum?,
          minimum_amount: String?,
          model_type: :package,
          name: String,
          package_config: Orb::Price::Package::PackageConfig,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Package::price_type,
          dimensional_price_configuration: Orb::Price::Package::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Package::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Package::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Package::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Package::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Package::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Package::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Package::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Package::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Package::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Package::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Package::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Package::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Package::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Package::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Package::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Package::Maximum::Filter::field,
              operator: Orb::Models::Price::Package::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Package::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::Package::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Package::Maximum::Filter::field,
              operator: Orb::Models::Price::Package::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Package::Maximum::Filter::field,
              operator: Orb::Models::Price::Package::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Package::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Package::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Package::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Package::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Package::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Package::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Package::Minimum::Filter::field,
              operator: Orb::Models::Price::Package::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Package::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::Package::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Package::Minimum::Filter::field,
              operator: Orb::Models::Price::Package::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Package::Minimum::Filter::field,
              operator: Orb::Models::Price::Package::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Package::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Package::Minimum::Filter::operator]
            end
          end
        end

        type package_config = { package_amount: String, package_size: Integer }

        class PackageConfig < Orb::Internal::Type::BaseModel
          attr_accessor package_amount: String

          attr_accessor package_size: Integer

          def initialize: (
            package_amount: String,
            package_size: Integer
          ) -> void

          def to_hash: -> { package_amount: String, package_size: Integer }
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Package::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type matrix =
        {
          id: String,
          billable_metric: Orb::Price::Matrix::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Matrix::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Matrix::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Matrix::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Matrix::InvoicingCycleConfiguration?,
          item: Orb::Price::Matrix::Item,
          matrix_config: Orb::Price::Matrix::MatrixConfig,
          maximum: Orb::Price::Matrix::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Matrix::Minimum?,
          minimum_amount: String?,
          model_type: :matrix,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Matrix::price_type,
          dimensional_price_configuration: Orb::Price::Matrix::DimensionalPriceConfiguration?
        }

      class Matrix < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::Matrix::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::Matrix::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Matrix::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::Matrix::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::Matrix::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::Matrix::Item

        attr_accessor matrix_config: Orb::Price::Matrix::MatrixConfig

        attr_accessor maximum: Orb::Price::Matrix::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::Matrix::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Matrix::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::Matrix::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::Matrix::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Matrix::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Matrix::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Matrix::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Matrix::InvoicingCycleConfiguration?,
          item: Orb::Price::Matrix::Item,
          matrix_config: Orb::Price::Matrix::MatrixConfig,
          maximum: Orb::Price::Matrix::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Matrix::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Matrix::price_type,
          ?dimensional_price_configuration: Orb::Price::Matrix::DimensionalPriceConfiguration?,
          ?model_type: :matrix
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::Matrix::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Matrix::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Matrix::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Matrix::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Matrix::InvoicingCycleConfiguration?,
          item: Orb::Price::Matrix::Item,
          matrix_config: Orb::Price::Matrix::MatrixConfig,
          maximum: Orb::Price::Matrix::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Matrix::Minimum?,
          minimum_amount: String?,
          model_type: :matrix,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Matrix::price_type,
          dimensional_price_configuration: Orb::Price::Matrix::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Matrix::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Matrix::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Matrix::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Matrix::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Matrix::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Matrix::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Matrix::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Matrix::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Matrix::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Matrix::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Matrix::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type matrix_config =
          {
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Price::Matrix::MatrixConfig::MatrixValue]
          }

        class MatrixConfig < Orb::Internal::Type::BaseModel
          attr_accessor default_unit_amount: String

          attr_accessor dimensions: ::Array[String?]

          attr_accessor matrix_values: ::Array[Orb::Price::Matrix::MatrixConfig::MatrixValue]

          def initialize: (
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Price::Matrix::MatrixConfig::MatrixValue]
          ) -> void

          def to_hash: -> {
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Price::Matrix::MatrixConfig::MatrixValue]
          }

          type matrix_value =
            { dimension_values: ::Array[String?], unit_amount: String }

          class MatrixValue < Orb::Internal::Type::BaseModel
            attr_accessor dimension_values: ::Array[String?]

            attr_accessor unit_amount: String

            def initialize: (
              dimension_values: ::Array[String?],
              unit_amount: String
            ) -> void

            def to_hash: -> {
              dimension_values: ::Array[String?],
              unit_amount: String
            }
          end
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Matrix::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Matrix::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Matrix::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Matrix::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Matrix::Maximum::Filter::field,
              operator: Orb::Models::Price::Matrix::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Matrix::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::Matrix::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Matrix::Maximum::Filter::field,
              operator: Orb::Models::Price::Matrix::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Matrix::Maximum::Filter::field,
              operator: Orb::Models::Price::Matrix::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Matrix::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Matrix::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Matrix::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Matrix::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Matrix::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Matrix::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Matrix::Minimum::Filter::field,
              operator: Orb::Models::Price::Matrix::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Matrix::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::Matrix::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Matrix::Minimum::Filter::field,
              operator: Orb::Models::Price::Matrix::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Matrix::Minimum::Filter::field,
              operator: Orb::Models::Price::Matrix::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Matrix::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Matrix::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Matrix::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type tiered =
        {
          id: String,
          billable_metric: Orb::Price::Tiered::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Tiered::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Tiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Tiered::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Tiered::InvoicingCycleConfiguration?,
          item: Orb::Price::Tiered::Item,
          maximum: Orb::Price::Tiered::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Tiered::Minimum?,
          minimum_amount: String?,
          model_type: :tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Tiered::price_type,
          tiered_config: Orb::Price::Tiered::TieredConfig,
          dimensional_price_configuration: Orb::Price::Tiered::DimensionalPriceConfiguration?
        }

      class Tiered < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::Tiered::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::Tiered::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::Tiered::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::Tiered::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::Tiered::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::Tiered::Item

        attr_accessor maximum: Orb::Price::Tiered::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::Tiered::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Tiered::price_type

        attr_accessor tiered_config: Orb::Price::Tiered::TieredConfig

        attr_accessor dimensional_price_configuration: Orb::Price::Tiered::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::Tiered::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Tiered::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Tiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Tiered::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Tiered::InvoicingCycleConfiguration?,
          item: Orb::Price::Tiered::Item,
          maximum: Orb::Price::Tiered::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Tiered::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Tiered::price_type,
          tiered_config: Orb::Price::Tiered::TieredConfig,
          ?dimensional_price_configuration: Orb::Price::Tiered::DimensionalPriceConfiguration?,
          ?model_type: :tiered
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::Tiered::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Tiered::BillingCycleConfiguration,
          cadence: Orb::Models::Price::Tiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Tiered::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Tiered::InvoicingCycleConfiguration?,
          item: Orb::Price::Tiered::Item,
          maximum: Orb::Price::Tiered::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Tiered::Minimum?,
          minimum_amount: String?,
          model_type: :tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Tiered::price_type,
          tiered_config: Orb::Price::Tiered::TieredConfig,
          dimensional_price_configuration: Orb::Price::Tiered::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Tiered::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Tiered::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Tiered::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Tiered::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Tiered::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Tiered::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Tiered::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Tiered::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Tiered::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Tiered::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Tiered::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Tiered::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Tiered::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Tiered::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Tiered::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Tiered::Maximum::Filter::field,
              operator: Orb::Models::Price::Tiered::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Tiered::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::Tiered::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Tiered::Maximum::Filter::field,
              operator: Orb::Models::Price::Tiered::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Tiered::Maximum::Filter::field,
              operator: Orb::Models::Price::Tiered::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Tiered::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Tiered::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Tiered::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Tiered::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Tiered::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Tiered::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Tiered::Minimum::Filter::field,
              operator: Orb::Models::Price::Tiered::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Tiered::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::Tiered::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Tiered::Minimum::Filter::field,
              operator: Orb::Models::Price::Tiered::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Tiered::Minimum::Filter::field,
              operator: Orb::Models::Price::Tiered::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Tiered::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Tiered::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Tiered::price_type]
        end

        type tiered_config =
          { tiers: ::Array[Orb::Price::Tiered::TieredConfig::Tier] }

        class TieredConfig < Orb::Internal::Type::BaseModel
          attr_accessor tiers: ::Array[Orb::Price::Tiered::TieredConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Price::Tiered::TieredConfig::Tier]
          ) -> void

          def to_hash: -> {
            tiers: ::Array[Orb::Price::Tiered::TieredConfig::Tier]
          }

          type tier =
            { first_unit: Float, unit_amount: String, last_unit: Float? }

          class Tier < Orb::Internal::Type::BaseModel
            attr_accessor first_unit: Float

            attr_accessor unit_amount: String

            attr_accessor last_unit: Float?

            def initialize: (
              first_unit: Float,
              unit_amount: String,
              ?last_unit: Float?
            ) -> void

            def to_hash: -> {
              first_unit: Float,
              unit_amount: String,
              last_unit: Float?
            }
          end
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type tiered_bps =
        {
          id: String,
          billable_metric: Orb::Price::TieredBps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredBps::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredBps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredBps::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredBps::Item,
          maximum: Orb::Price::TieredBps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredBps::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBps::price_type,
          tiered_bps_config: Orb::Price::TieredBps::TieredBpsConfig,
          dimensional_price_configuration: Orb::Price::TieredBps::DimensionalPriceConfiguration?
        }

      class TieredBps < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::TieredBps::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::TieredBps::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredBps::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::TieredBps::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::TieredBps::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::TieredBps::Item

        attr_accessor maximum: Orb::Price::TieredBps::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::TieredBps::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredBps::price_type

        attr_accessor tiered_bps_config: Orb::Price::TieredBps::TieredBpsConfig

        attr_accessor dimensional_price_configuration: Orb::Price::TieredBps::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::TieredBps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredBps::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredBps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredBps::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredBps::Item,
          maximum: Orb::Price::TieredBps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredBps::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBps::price_type,
          tiered_bps_config: Orb::Price::TieredBps::TieredBpsConfig,
          ?dimensional_price_configuration: Orb::Price::TieredBps::DimensionalPriceConfiguration?,
          ?model_type: :tiered_bps
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::TieredBps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredBps::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredBps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredBps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredBps::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredBps::Item,
          maximum: Orb::Price::TieredBps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredBps::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredBps::price_type,
          tiered_bps_config: Orb::Price::TieredBps::TieredBpsConfig,
          dimensional_price_configuration: Orb::Price::TieredBps::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBps::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredBps::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBps::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBps::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredBps::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredBps::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBps::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredBps::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBps::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredBps::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredBps::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredBps::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredBps::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredBps::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredBps::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredBps::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredBps::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredBps::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredBps::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredBps::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredBps::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredBps::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredBps::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredBps::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredBps::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredBps::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredBps::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredBps::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredBps::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredBps::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredBps::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredBps::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredBps::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredBps::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredBps::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredBps::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredBps::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredBps::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredBps::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredBps::price_type]
        end

        type tiered_bps_config =
          { tiers: ::Array[Orb::Price::TieredBps::TieredBpsConfig::Tier] }

        class TieredBpsConfig < Orb::Internal::Type::BaseModel
          attr_accessor tiers: ::Array[Orb::Price::TieredBps::TieredBpsConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Price::TieredBps::TieredBpsConfig::Tier]
          ) -> void

          def to_hash: -> {
            tiers: ::Array[Orb::Price::TieredBps::TieredBpsConfig::Tier]
          }

          type tier =
            {
              bps: Float,
              minimum_amount: String,
              maximum_amount: String?,
              per_unit_maximum: String?
            }

          class Tier < Orb::Internal::Type::BaseModel
            attr_accessor bps: Float

            attr_accessor minimum_amount: String

            attr_accessor maximum_amount: String?

            attr_accessor per_unit_maximum: String?

            def initialize: (
              bps: Float,
              minimum_amount: String,
              ?maximum_amount: String?,
              ?per_unit_maximum: String?
            ) -> void

            def to_hash: -> {
              bps: Float,
              minimum_amount: String,
              maximum_amount: String?,
              per_unit_maximum: String?
            }
          end
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type bps =
        {
          id: String,
          billable_metric: Orb::Price::Bps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Bps::BillingCycleConfiguration,
          bps_config: Orb::Price::Bps::BpsConfig,
          cadence: Orb::Models::Price::Bps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Bps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Bps::InvoicingCycleConfiguration?,
          item: Orb::Price::Bps::Item,
          maximum: Orb::Price::Bps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Bps::Minimum?,
          minimum_amount: String?,
          model_type: :bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bps::price_type,
          dimensional_price_configuration: Orb::Price::Bps::DimensionalPriceConfiguration?
        }

      class Bps < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::Bps::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::Bps::BillingCycleConfiguration

        attr_accessor bps_config: Orb::Price::Bps::BpsConfig

        attr_accessor cadence: Orb::Models::Price::Bps::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::Bps::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::Bps::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::Bps::Item

        attr_accessor maximum: Orb::Price::Bps::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::Bps::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Bps::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::Bps::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::Bps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Bps::BillingCycleConfiguration,
          bps_config: Orb::Price::Bps::BpsConfig,
          cadence: Orb::Models::Price::Bps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Bps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Bps::InvoicingCycleConfiguration?,
          item: Orb::Price::Bps::Item,
          maximum: Orb::Price::Bps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Bps::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bps::price_type,
          ?dimensional_price_configuration: Orb::Price::Bps::DimensionalPriceConfiguration?,
          ?model_type: :bps
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::Bps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Bps::BillingCycleConfiguration,
          bps_config: Orb::Price::Bps::BpsConfig,
          cadence: Orb::Models::Price::Bps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Bps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Bps::InvoicingCycleConfiguration?,
          item: Orb::Price::Bps::Item,
          maximum: Orb::Price::Bps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Bps::Minimum?,
          minimum_amount: String?,
          model_type: :bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bps::price_type,
          dimensional_price_configuration: Orb::Price::Bps::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bps::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Bps::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Bps::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bps::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Bps::BillingCycleConfiguration::duration_unit]
          end
        end

        type bps_config = { bps: Float, per_unit_maximum: String? }

        class BpsConfig < Orb::Internal::Type::BaseModel
          attr_accessor bps: Float

          attr_accessor per_unit_maximum: String?

          def initialize: (bps: Float, ?per_unit_maximum: String?) -> void

          def to_hash: -> { bps: Float, per_unit_maximum: String? }
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Bps::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bps::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Bps::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Bps::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bps::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Bps::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bps::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Bps::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bps::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bps::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Bps::Maximum::Filter::field,
              operator: Orb::Models::Price::Bps::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Bps::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::Bps::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Bps::Maximum::Filter::field,
              operator: Orb::Models::Price::Bps::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Bps::Maximum::Filter::field,
              operator: Orb::Models::Price::Bps::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Bps::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Bps::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bps::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Bps::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bps::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bps::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Bps::Minimum::Filter::field,
              operator: Orb::Models::Price::Bps::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Bps::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::Bps::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Bps::Minimum::Filter::field,
              operator: Orb::Models::Price::Bps::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Bps::Minimum::Filter::field,
              operator: Orb::Models::Price::Bps::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Bps::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Bps::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Bps::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type bulk_bps =
        {
          id: String,
          billable_metric: Orb::Price::BulkBps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::BulkBps::BillingCycleConfiguration,
          bulk_bps_config: Orb::Price::BulkBps::BulkBpsConfig,
          cadence: Orb::Models::Price::BulkBps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::BulkBps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::BulkBps::InvoicingCycleConfiguration?,
          item: Orb::Price::BulkBps::Item,
          maximum: Orb::Price::BulkBps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::BulkBps::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBps::price_type,
          dimensional_price_configuration: Orb::Price::BulkBps::DimensionalPriceConfiguration?
        }

      class BulkBps < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::BulkBps::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::BulkBps::BillingCycleConfiguration

        attr_accessor bulk_bps_config: Orb::Price::BulkBps::BulkBpsConfig

        attr_accessor cadence: Orb::Models::Price::BulkBps::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::BulkBps::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::BulkBps::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::BulkBps::Item

        attr_accessor maximum: Orb::Price::BulkBps::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::BulkBps::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk_bps

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkBps::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::BulkBps::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::BulkBps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::BulkBps::BillingCycleConfiguration,
          bulk_bps_config: Orb::Price::BulkBps::BulkBpsConfig,
          cadence: Orb::Models::Price::BulkBps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::BulkBps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::BulkBps::InvoicingCycleConfiguration?,
          item: Orb::Price::BulkBps::Item,
          maximum: Orb::Price::BulkBps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::BulkBps::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBps::price_type,
          ?dimensional_price_configuration: Orb::Price::BulkBps::DimensionalPriceConfiguration?,
          ?model_type: :bulk_bps
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::BulkBps::BillableMetric?,
          billing_cycle_configuration: Orb::Price::BulkBps::BillingCycleConfiguration,
          bulk_bps_config: Orb::Price::BulkBps::BulkBpsConfig,
          cadence: Orb::Models::Price::BulkBps::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::BulkBps::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::BulkBps::InvoicingCycleConfiguration?,
          item: Orb::Price::BulkBps::Item,
          maximum: Orb::Price::BulkBps::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::BulkBps::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_bps,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkBps::price_type,
          dimensional_price_configuration: Orb::Price::BulkBps::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBps::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkBps::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBps::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBps::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkBps::BillingCycleConfiguration::duration_unit]
          end
        end

        type bulk_bps_config =
          { tiers: ::Array[Orb::Price::BulkBps::BulkBpsConfig::Tier] }

        class BulkBpsConfig < Orb::Internal::Type::BaseModel
          attr_accessor tiers: ::Array[Orb::Price::BulkBps::BulkBpsConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Price::BulkBps::BulkBpsConfig::Tier]
          ) -> void

          def to_hash: -> {
            tiers: ::Array[Orb::Price::BulkBps::BulkBpsConfig::Tier]
          }

          type tier =
            { bps: Float, maximum_amount: String?, per_unit_maximum: String? }

          class Tier < Orb::Internal::Type::BaseModel
            attr_accessor bps: Float

            attr_accessor maximum_amount: String?

            attr_accessor per_unit_maximum: String?

            def initialize: (
              bps: Float,
              ?maximum_amount: String?,
              ?per_unit_maximum: String?
            ) -> void

            def to_hash: -> {
              bps: Float,
              maximum_amount: String?,
              per_unit_maximum: String?
            }
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkBps::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBps::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkBps::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBps::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkBps::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkBps::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkBps::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::BulkBps::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkBps::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkBps::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::BulkBps::Maximum::Filter::field,
              operator: Orb::Models::Price::BulkBps::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::BulkBps::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::BulkBps::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::BulkBps::Maximum::Filter::field,
              operator: Orb::Models::Price::BulkBps::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::BulkBps::Maximum::Filter::field,
              operator: Orb::Models::Price::BulkBps::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::BulkBps::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::BulkBps::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkBps::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::BulkBps::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkBps::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkBps::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::BulkBps::Minimum::Filter::field,
              operator: Orb::Models::Price::BulkBps::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::BulkBps::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::BulkBps::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::BulkBps::Minimum::Filter::field,
              operator: Orb::Models::Price::BulkBps::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::BulkBps::Minimum::Filter::field,
              operator: Orb::Models::Price::BulkBps::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::BulkBps::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::BulkBps::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkBps::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type bulk =
        {
          id: String,
          billable_metric: Orb::Price::Bulk::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Bulk::BillingCycleConfiguration,
          bulk_config: Orb::Price::Bulk::BulkConfig,
          cadence: Orb::Models::Price::Bulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Bulk::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Bulk::InvoicingCycleConfiguration?,
          item: Orb::Price::Bulk::Item,
          maximum: Orb::Price::Bulk::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Bulk::Minimum?,
          minimum_amount: String?,
          model_type: :bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bulk::price_type,
          dimensional_price_configuration: Orb::Price::Bulk::DimensionalPriceConfiguration?
        }

      class Bulk < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::Bulk::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::Bulk::BillingCycleConfiguration

        attr_accessor bulk_config: Orb::Price::Bulk::BulkConfig

        attr_accessor cadence: Orb::Models::Price::Bulk::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::Bulk::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::Bulk::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::Bulk::Item

        attr_accessor maximum: Orb::Price::Bulk::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::Bulk::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::Bulk::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::Bulk::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::Bulk::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Bulk::BillingCycleConfiguration,
          bulk_config: Orb::Price::Bulk::BulkConfig,
          cadence: Orb::Models::Price::Bulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Bulk::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Bulk::InvoicingCycleConfiguration?,
          item: Orb::Price::Bulk::Item,
          maximum: Orb::Price::Bulk::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Bulk::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bulk::price_type,
          ?dimensional_price_configuration: Orb::Price::Bulk::DimensionalPriceConfiguration?,
          ?model_type: :bulk
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::Bulk::BillableMetric?,
          billing_cycle_configuration: Orb::Price::Bulk::BillingCycleConfiguration,
          bulk_config: Orb::Price::Bulk::BulkConfig,
          cadence: Orb::Models::Price::Bulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::Bulk::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::Bulk::InvoicingCycleConfiguration?,
          item: Orb::Price::Bulk::Item,
          maximum: Orb::Price::Bulk::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::Bulk::Minimum?,
          minimum_amount: String?,
          model_type: :bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::Bulk::price_type,
          dimensional_price_configuration: Orb::Price::Bulk::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bulk::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Bulk::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Bulk::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bulk::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Bulk::BillingCycleConfiguration::duration_unit]
          end
        end

        type bulk_config =
          { tiers: ::Array[Orb::Price::Bulk::BulkConfig::Tier] }

        class BulkConfig < Orb::Internal::Type::BaseModel
          attr_accessor tiers: ::Array[Orb::Price::Bulk::BulkConfig::Tier]

          def initialize: (
            tiers: ::Array[Orb::Price::Bulk::BulkConfig::Tier]
          ) -> void

          def to_hash: -> { tiers: ::Array[Orb::Price::Bulk::BulkConfig::Tier] }

          type tier = { unit_amount: String, maximum_units: Float? }

          class Tier < Orb::Internal::Type::BaseModel
            attr_accessor unit_amount: String

            attr_accessor maximum_units: Float?

            def initialize: (
              unit_amount: String,
              ?maximum_units: Float?
            ) -> void

            def to_hash: -> { unit_amount: String, maximum_units: Float? }
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::Bulk::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bulk::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::Bulk::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::Bulk::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::Bulk::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::Bulk::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bulk::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Bulk::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bulk::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bulk::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Bulk::Maximum::Filter::field,
              operator: Orb::Models::Price::Bulk::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Bulk::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::Bulk::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Bulk::Maximum::Filter::field,
              operator: Orb::Models::Price::Bulk::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Bulk::Maximum::Filter::field,
              operator: Orb::Models::Price::Bulk::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Bulk::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Bulk::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bulk::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::Bulk::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bulk::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::Bulk::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::Bulk::Minimum::Filter::field,
              operator: Orb::Models::Price::Bulk::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::Bulk::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::Bulk::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::Bulk::Minimum::Filter::field,
              operator: Orb::Models::Price::Bulk::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::Bulk::Minimum::Filter::field,
              operator: Orb::Models::Price::Bulk::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::Bulk::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::Bulk::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::Bulk::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type threshold_total_amount =
        {
          id: String,
          billable_metric: Orb::Price::ThresholdTotalAmount::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ThresholdTotalAmount::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmount::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ThresholdTotalAmount::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ThresholdTotalAmount::InvoicingCycleConfiguration?,
          item: Orb::Price::ThresholdTotalAmount::Item,
          maximum: Orb::Price::ThresholdTotalAmount::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ThresholdTotalAmount::Minimum?,
          minimum_amount: String?,
          model_type: :threshold_total_amount,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmount::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::ThresholdTotalAmount::DimensionalPriceConfiguration?
        }

      class ThresholdTotalAmount < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::ThresholdTotalAmount::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::ThresholdTotalAmount::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ThresholdTotalAmount::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::ThresholdTotalAmount::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::ThresholdTotalAmount::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::ThresholdTotalAmount::Item

        attr_accessor maximum: Orb::Price::ThresholdTotalAmount::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::ThresholdTotalAmount::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :threshold_total_amount

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ThresholdTotalAmount::price_type

        attr_accessor threshold_total_amount_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::ThresholdTotalAmount::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::ThresholdTotalAmount::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ThresholdTotalAmount::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmount::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ThresholdTotalAmount::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ThresholdTotalAmount::InvoicingCycleConfiguration?,
          item: Orb::Price::ThresholdTotalAmount::Item,
          maximum: Orb::Price::ThresholdTotalAmount::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ThresholdTotalAmount::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmount::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::ThresholdTotalAmount::DimensionalPriceConfiguration?,
          ?model_type: :threshold_total_amount
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::ThresholdTotalAmount::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ThresholdTotalAmount::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ThresholdTotalAmount::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ThresholdTotalAmount::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ThresholdTotalAmount::InvoicingCycleConfiguration?,
          item: Orb::Price::ThresholdTotalAmount::Item,
          maximum: Orb::Price::ThresholdTotalAmount::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ThresholdTotalAmount::Minimum?,
          minimum_amount: String?,
          model_type: :threshold_total_amount,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ThresholdTotalAmount::price_type,
          threshold_total_amount_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::ThresholdTotalAmount::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmount::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ThresholdTotalAmount::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmount::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmount::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmount::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ThresholdTotalAmount::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmount::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::ThresholdTotalAmount::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ThresholdTotalAmount::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::ThresholdTotalAmount::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ThresholdTotalAmount::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ThresholdTotalAmount::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::field,
              operator: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::field,
              operator: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::field,
              operator: Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ThresholdTotalAmount::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::ThresholdTotalAmount::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ThresholdTotalAmount::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ThresholdTotalAmount::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::field,
              operator: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::field,
              operator: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::field,
              operator: Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ThresholdTotalAmount::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type tiered_package =
        {
          id: String,
          billable_metric: Orb::Price::TieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredPackage::Item,
          maximum: Orb::Price::TieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredPackage::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackage::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredPackage::DimensionalPriceConfiguration?
        }

      class TieredPackage < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::TieredPackage::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::TieredPackage::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPackage::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::TieredPackage::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::TieredPackage::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::TieredPackage::Item

        attr_accessor maximum: Orb::Price::TieredPackage::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::TieredPackage::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPackage::price_type

        attr_accessor tiered_package_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::TieredPackage::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::TieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredPackage::Item,
          maximum: Orb::Price::TieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredPackage::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackage::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::TieredPackage::DimensionalPriceConfiguration?,
          ?model_type: :tiered_package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::TieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredPackage::Item,
          maximum: Orb::Price::TieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredPackage::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackage::price_type,
          tiered_package_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredPackage::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackage::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackage::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackage::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackage::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackage::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackage::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackage::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackage::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackage::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredPackage::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackage::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackage::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredPackage::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredPackage::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackage::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredPackage::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackage::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackage::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredPackage::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredPackage::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackage::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type grouped_tiered =
        {
          id: String,
          billable_metric: Orb::Price::GroupedTiered::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedTiered::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedTiered::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedTiered::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedTiered::Item,
          maximum: Orb::Price::GroupedTiered::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedTiered::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTiered::price_type,
          dimensional_price_configuration: Orb::Price::GroupedTiered::DimensionalPriceConfiguration?
        }

      class GroupedTiered < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::GroupedTiered::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::GroupedTiered::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedTiered::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::GroupedTiered::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_tiered_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Price::GroupedTiered::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::GroupedTiered::Item

        attr_accessor maximum: Orb::Price::GroupedTiered::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::GroupedTiered::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_tiered

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedTiered::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::GroupedTiered::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::GroupedTiered::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedTiered::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedTiered::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedTiered::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedTiered::Item,
          maximum: Orb::Price::GroupedTiered::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedTiered::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTiered::price_type,
          ?dimensional_price_configuration: Orb::Price::GroupedTiered::DimensionalPriceConfiguration?,
          ?model_type: :grouped_tiered
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::GroupedTiered::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedTiered::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTiered::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedTiered::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedTiered::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedTiered::Item,
          maximum: Orb::Price::GroupedTiered::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedTiered::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTiered::price_type,
          dimensional_price_configuration: Orb::Price::GroupedTiered::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTiered::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTiered::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTiered::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTiered::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTiered::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTiered::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTiered::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTiered::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTiered::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedTiered::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTiered::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTiered::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedTiered::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedTiered::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedTiered::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedTiered::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedTiered::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedTiered::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedTiered::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedTiered::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTiered::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedTiered::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTiered::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTiered::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedTiered::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedTiered::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedTiered::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedTiered::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedTiered::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedTiered::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedTiered::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedTiered::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTiered::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type tiered_with_minimum =
        {
          id: String,
          billable_metric: Orb::Price::TieredWithMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredWithMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredWithMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredWithMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredWithMinimum::Item,
          maximum: Orb::Price::TieredWithMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredWithMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimum::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredWithMinimum::DimensionalPriceConfiguration?
        }

      class TieredWithMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::TieredWithMinimum::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::TieredWithMinimum::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredWithMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::TieredWithMinimum::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::TieredWithMinimum::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::TieredWithMinimum::Item

        attr_accessor maximum: Orb::Price::TieredWithMinimum::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::TieredWithMinimum::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_with_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredWithMinimum::price_type

        attr_accessor tiered_with_minimum_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::TieredWithMinimum::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::TieredWithMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredWithMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredWithMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredWithMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredWithMinimum::Item,
          maximum: Orb::Price::TieredWithMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredWithMinimum::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimum::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::TieredWithMinimum::DimensionalPriceConfiguration?,
          ?model_type: :tiered_with_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::TieredWithMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredWithMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredWithMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredWithMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredWithMinimum::Item,
          maximum: Orb::Price::TieredWithMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredWithMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithMinimum::price_type,
          tiered_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredWithMinimum::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimum::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithMinimum::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimum::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimum::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimum::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithMinimum::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimum::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithMinimum::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithMinimum::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredWithMinimum::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithMinimum::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithMinimum::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredWithMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithMinimum::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredWithMinimum::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithMinimum::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithMinimum::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredWithMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithMinimum::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type tiered_package_with_minimum =
        {
          id: String,
          billable_metric: Orb::Price::TieredPackageWithMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredPackageWithMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredPackageWithMinimum::Item,
          maximum: Orb::Price::TieredPackageWithMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredPackageWithMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredPackageWithMinimum::DimensionalPriceConfiguration?
        }

      class TieredPackageWithMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::TieredPackageWithMinimum::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::TieredPackageWithMinimum::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::TieredPackageWithMinimum::Item

        attr_accessor maximum: Orb::Price::TieredPackageWithMinimum::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::TieredPackageWithMinimum::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_package_with_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type

        attr_accessor tiered_package_with_minimum_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::TieredPackageWithMinimum::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::TieredPackageWithMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredPackageWithMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredPackageWithMinimum::Item,
          maximum: Orb::Price::TieredPackageWithMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredPackageWithMinimum::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::TieredPackageWithMinimum::DimensionalPriceConfiguration?,
          ?model_type: :tiered_package_with_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::TieredPackageWithMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredPackageWithMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredPackageWithMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredPackageWithMinimum::Item,
          maximum: Orb::Price::TieredPackageWithMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredPackageWithMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_package_with_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredPackageWithMinimum::price_type,
          tiered_package_with_minimum_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredPackageWithMinimum::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimum::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackageWithMinimum::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimum::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimum::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackageWithMinimum::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredPackageWithMinimum::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackageWithMinimum::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackageWithMinimum::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackageWithMinimum::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredPackageWithMinimum::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackageWithMinimum::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredPackageWithMinimum::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredPackageWithMinimum::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type package_with_allocation =
        {
          id: String,
          billable_metric: Orb::Price::PackageWithAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::PackageWithAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::PackageWithAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::PackageWithAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::PackageWithAllocation::Item,
          maximum: Orb::Price::PackageWithAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::PackageWithAllocation::Minimum?,
          minimum_amount: String?,
          model_type: :package_with_allocation,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocation::price_type,
          dimensional_price_configuration: Orb::Price::PackageWithAllocation::DimensionalPriceConfiguration?
        }

      class PackageWithAllocation < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::PackageWithAllocation::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::PackageWithAllocation::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::PackageWithAllocation::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::PackageWithAllocation::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::PackageWithAllocation::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::PackageWithAllocation::Item

        attr_accessor maximum: Orb::Price::PackageWithAllocation::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::PackageWithAllocation::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :package_with_allocation

        attr_accessor name: String

        attr_accessor package_with_allocation_config: ::Hash[Symbol, top]

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::PackageWithAllocation::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::PackageWithAllocation::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::PackageWithAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::PackageWithAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::PackageWithAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::PackageWithAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::PackageWithAllocation::Item,
          maximum: Orb::Price::PackageWithAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::PackageWithAllocation::Minimum?,
          minimum_amount: String?,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocation::price_type,
          ?dimensional_price_configuration: Orb::Price::PackageWithAllocation::DimensionalPriceConfiguration?,
          ?model_type: :package_with_allocation
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::PackageWithAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::PackageWithAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::PackageWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::PackageWithAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::PackageWithAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::PackageWithAllocation::Item,
          maximum: Orb::Price::PackageWithAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::PackageWithAllocation::Minimum?,
          minimum_amount: String?,
          model_type: :package_with_allocation,
          name: String,
          package_with_allocation_config: ::Hash[Symbol, top],
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::PackageWithAllocation::price_type,
          dimensional_price_configuration: Orb::Price::PackageWithAllocation::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocation::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::PackageWithAllocation::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocation::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocation::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocation::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::PackageWithAllocation::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocation::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::PackageWithAllocation::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::PackageWithAllocation::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::PackageWithAllocation::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::PackageWithAllocation::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::PackageWithAllocation::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::PackageWithAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::PackageWithAllocation::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::PackageWithAllocation::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::PackageWithAllocation::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::PackageWithAllocation::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::PackageWithAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::PackageWithAllocation::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type unit_with_percent =
        {
          id: String,
          billable_metric: Orb::Price::UnitWithPercent::BillableMetric?,
          billing_cycle_configuration: Orb::Price::UnitWithPercent::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercent::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::UnitWithPercent::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::UnitWithPercent::InvoicingCycleConfiguration?,
          item: Orb::Price::UnitWithPercent::Item,
          maximum: Orb::Price::UnitWithPercent::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::UnitWithPercent::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_percent,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercent::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::UnitWithPercent::DimensionalPriceConfiguration?
        }

      class UnitWithPercent < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::UnitWithPercent::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::UnitWithPercent::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitWithPercent::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::UnitWithPercent::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::UnitWithPercent::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::UnitWithPercent::Item

        attr_accessor maximum: Orb::Price::UnitWithPercent::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::UnitWithPercent::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit_with_percent

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitWithPercent::price_type

        attr_accessor unit_with_percent_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::UnitWithPercent::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::UnitWithPercent::BillableMetric?,
          billing_cycle_configuration: Orb::Price::UnitWithPercent::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercent::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::UnitWithPercent::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::UnitWithPercent::InvoicingCycleConfiguration?,
          item: Orb::Price::UnitWithPercent::Item,
          maximum: Orb::Price::UnitWithPercent::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::UnitWithPercent::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercent::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::UnitWithPercent::DimensionalPriceConfiguration?,
          ?model_type: :unit_with_percent
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::UnitWithPercent::BillableMetric?,
          billing_cycle_configuration: Orb::Price::UnitWithPercent::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithPercent::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::UnitWithPercent::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::UnitWithPercent::InvoicingCycleConfiguration?,
          item: Orb::Price::UnitWithPercent::Item,
          maximum: Orb::Price::UnitWithPercent::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::UnitWithPercent::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_percent,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithPercent::price_type,
          unit_with_percent_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::UnitWithPercent::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercent::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithPercent::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercent::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercent::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercent::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithPercent::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercent::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithPercent::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithPercent::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::UnitWithPercent::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithPercent::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithPercent::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::UnitWithPercent::Maximum::Filter::field,
              operator: Orb::Models::Price::UnitWithPercent::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::UnitWithPercent::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::UnitWithPercent::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::UnitWithPercent::Maximum::Filter::field,
              operator: Orb::Models::Price::UnitWithPercent::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::UnitWithPercent::Maximum::Filter::field,
              operator: Orb::Models::Price::UnitWithPercent::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithPercent::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::UnitWithPercent::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithPercent::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithPercent::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::UnitWithPercent::Minimum::Filter::field,
              operator: Orb::Models::Price::UnitWithPercent::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::UnitWithPercent::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::UnitWithPercent::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::UnitWithPercent::Minimum::Filter::field,
              operator: Orb::Models::Price::UnitWithPercent::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::UnitWithPercent::Minimum::Filter::field,
              operator: Orb::Models::Price::UnitWithPercent::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithPercent::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type matrix_with_allocation =
        {
          id: String,
          billable_metric: Orb::Price::MatrixWithAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MatrixWithAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MatrixWithAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MatrixWithAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::MatrixWithAllocation::Item,
          matrix_with_allocation_config: Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig,
          maximum: Orb::Price::MatrixWithAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MatrixWithAllocation::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocation::price_type,
          dimensional_price_configuration: Orb::Price::MatrixWithAllocation::DimensionalPriceConfiguration?
        }

      class MatrixWithAllocation < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::MatrixWithAllocation::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::MatrixWithAllocation::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixWithAllocation::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::MatrixWithAllocation::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::MatrixWithAllocation::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::MatrixWithAllocation::Item

        attr_accessor matrix_with_allocation_config: Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig

        attr_accessor maximum: Orb::Price::MatrixWithAllocation::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::MatrixWithAllocation::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix_with_allocation

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixWithAllocation::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::MatrixWithAllocation::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::MatrixWithAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MatrixWithAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MatrixWithAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MatrixWithAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::MatrixWithAllocation::Item,
          matrix_with_allocation_config: Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig,
          maximum: Orb::Price::MatrixWithAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MatrixWithAllocation::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocation::price_type,
          ?dimensional_price_configuration: Orb::Price::MatrixWithAllocation::DimensionalPriceConfiguration?,
          ?model_type: :matrix_with_allocation
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::MatrixWithAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MatrixWithAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MatrixWithAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MatrixWithAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::MatrixWithAllocation::Item,
          matrix_with_allocation_config: Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig,
          maximum: Orb::Price::MatrixWithAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MatrixWithAllocation::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithAllocation::price_type,
          dimensional_price_configuration: Orb::Price::MatrixWithAllocation::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocation::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithAllocation::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocation::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocation::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocation::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithAllocation::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocation::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithAllocation::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type matrix_with_allocation_config =
          {
            allocation: Float,
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig::MatrixValue]
          }

        class MatrixWithAllocationConfig < Orb::Internal::Type::BaseModel
          attr_accessor allocation: Float

          attr_accessor default_unit_amount: String

          attr_accessor dimensions: ::Array[String?]

          attr_accessor matrix_values: ::Array[Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig::MatrixValue]

          def initialize: (
            allocation: Float,
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig::MatrixValue]
          ) -> void

          def to_hash: -> {
            allocation: Float,
            default_unit_amount: String,
            dimensions: ::Array[String?],
            matrix_values: ::Array[Orb::Price::MatrixWithAllocation::MatrixWithAllocationConfig::MatrixValue]
          }

          type matrix_value =
            { dimension_values: ::Array[String?], unit_amount: String }

          class MatrixValue < Orb::Internal::Type::BaseModel
            attr_accessor dimension_values: ::Array[String?]

            attr_accessor unit_amount: String

            def initialize: (
              dimension_values: ::Array[String?],
              unit_amount: String
            ) -> void

            def to_hash: -> {
              dimension_values: ::Array[String?],
              unit_amount: String
            }
          end
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithAllocation::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::MatrixWithAllocation::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithAllocation::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithAllocation::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithAllocation::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::MatrixWithAllocation::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithAllocation::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithAllocation::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithAllocation::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type tiered_with_proration =
        {
          id: String,
          billable_metric: Orb::Price::TieredWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredWithProration::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredWithProration::Item,
          maximum: Orb::Price::TieredWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredWithProration::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProration::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredWithProration::DimensionalPriceConfiguration?
        }

      class TieredWithProration < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::TieredWithProration::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::TieredWithProration::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::TieredWithProration::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::TieredWithProration::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::TieredWithProration::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::TieredWithProration::Item

        attr_accessor maximum: Orb::Price::TieredWithProration::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::TieredWithProration::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :tiered_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::TieredWithProration::price_type

        attr_accessor tiered_with_proration_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::TieredWithProration::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::TieredWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredWithProration::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredWithProration::Item,
          maximum: Orb::Price::TieredWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredWithProration::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProration::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::TieredWithProration::DimensionalPriceConfiguration?,
          ?model_type: :tiered_with_proration
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::TieredWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::TieredWithProration::BillingCycleConfiguration,
          cadence: Orb::Models::Price::TieredWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::TieredWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::TieredWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::TieredWithProration::Item,
          maximum: Orb::Price::TieredWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::TieredWithProration::Minimum?,
          minimum_amount: String?,
          model_type: :tiered_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::TieredWithProration::price_type,
          tiered_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::TieredWithProration::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProration::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithProration::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProration::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProration::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProration::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::TieredWithProration::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProration::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::TieredWithProration::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithProration::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredWithProration::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithProration::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithProration::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredWithProration::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredWithProration::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::TieredWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithProration::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::TieredWithProration::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithProration::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::TieredWithProration::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::TieredWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::TieredWithProration::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::TieredWithProration::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::TieredWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::TieredWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::TieredWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::TieredWithProration::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type unit_with_proration =
        {
          id: String,
          billable_metric: Orb::Price::UnitWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::UnitWithProration::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::UnitWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::UnitWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::UnitWithProration::Item,
          maximum: Orb::Price::UnitWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::UnitWithProration::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProration::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::UnitWithProration::DimensionalPriceConfiguration?
        }

      class UnitWithProration < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::UnitWithProration::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::UnitWithProration::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::UnitWithProration::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::UnitWithProration::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::UnitWithProration::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::UnitWithProration::Item

        attr_accessor maximum: Orb::Price::UnitWithProration::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::UnitWithProration::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :unit_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::UnitWithProration::price_type

        attr_accessor unit_with_proration_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::UnitWithProration::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::UnitWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::UnitWithProration::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::UnitWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::UnitWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::UnitWithProration::Item,
          maximum: Orb::Price::UnitWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::UnitWithProration::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProration::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::UnitWithProration::DimensionalPriceConfiguration?,
          ?model_type: :unit_with_proration
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::UnitWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::UnitWithProration::BillingCycleConfiguration,
          cadence: Orb::Models::Price::UnitWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::UnitWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::UnitWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::UnitWithProration::Item,
          maximum: Orb::Price::UnitWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::UnitWithProration::Minimum?,
          minimum_amount: String?,
          model_type: :unit_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::UnitWithProration::price_type,
          unit_with_proration_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::UnitWithProration::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProration::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithProration::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProration::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProration::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProration::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::UnitWithProration::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProration::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::UnitWithProration::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithProration::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::UnitWithProration::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithProration::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithProration::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::UnitWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::UnitWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::UnitWithProration::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::UnitWithProration::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::UnitWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::UnitWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::UnitWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::UnitWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithProration::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::UnitWithProration::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithProration::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::UnitWithProration::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::UnitWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::UnitWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::UnitWithProration::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::UnitWithProration::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::UnitWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::UnitWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::UnitWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::UnitWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::UnitWithProration::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type grouped_allocation =
        {
          id: String,
          billable_metric: Orb::Price::GroupedAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedAllocation::Item,
          maximum: Orb::Price::GroupedAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedAllocation::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocation::price_type,
          dimensional_price_configuration: Orb::Price::GroupedAllocation::DimensionalPriceConfiguration?
        }

      class GroupedAllocation < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::GroupedAllocation::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::GroupedAllocation::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedAllocation::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::GroupedAllocation::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_allocation_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Price::GroupedAllocation::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::GroupedAllocation::Item

        attr_accessor maximum: Orb::Price::GroupedAllocation::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::GroupedAllocation::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_allocation

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedAllocation::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::GroupedAllocation::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::GroupedAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedAllocation::Item,
          maximum: Orb::Price::GroupedAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedAllocation::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocation::price_type,
          ?dimensional_price_configuration: Orb::Price::GroupedAllocation::DimensionalPriceConfiguration?,
          ?model_type: :grouped_allocation
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::GroupedAllocation::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedAllocation::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedAllocation::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedAllocation::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_allocation_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedAllocation::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedAllocation::Item,
          maximum: Orb::Price::GroupedAllocation::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedAllocation::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_allocation,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedAllocation::price_type,
          dimensional_price_configuration: Orb::Price::GroupedAllocation::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocation::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedAllocation::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocation::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocation::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocation::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedAllocation::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocation::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedAllocation::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedAllocation::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedAllocation::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedAllocation::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedAllocation::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedAllocation::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedAllocation::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedAllocation::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedAllocation::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedAllocation::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedAllocation::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedAllocation::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedAllocation::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedAllocation::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedAllocation::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedAllocation::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedAllocation::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedAllocation::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type grouped_with_prorated_minimum =
        {
          id: String,
          billable_metric: Orb::Price::GroupedWithProratedMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedWithProratedMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedWithProratedMinimum::Item,
          maximum: Orb::Price::GroupedWithProratedMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedWithProratedMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_prorated_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type,
          dimensional_price_configuration: Orb::Price::GroupedWithProratedMinimum::DimensionalPriceConfiguration?
        }

      class GroupedWithProratedMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::GroupedWithProratedMinimum::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::GroupedWithProratedMinimum::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_with_prorated_minimum_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::GroupedWithProratedMinimum::Item

        attr_accessor maximum: Orb::Price::GroupedWithProratedMinimum::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::GroupedWithProratedMinimum::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_with_prorated_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::GroupedWithProratedMinimum::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::GroupedWithProratedMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedWithProratedMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedWithProratedMinimum::Item,
          maximum: Orb::Price::GroupedWithProratedMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedWithProratedMinimum::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type,
          ?dimensional_price_configuration: Orb::Price::GroupedWithProratedMinimum::DimensionalPriceConfiguration?,
          ?model_type: :grouped_with_prorated_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::GroupedWithProratedMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithProratedMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedWithProratedMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_prorated_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedWithProratedMinimum::Item,
          maximum: Orb::Price::GroupedWithProratedMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedWithProratedMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_prorated_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithProratedMinimum::price_type,
          dimensional_price_configuration: Orb::Price::GroupedWithProratedMinimum::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithProratedMinimum::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithProratedMinimum::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type grouped_with_metered_minimum =
        {
          id: String,
          billable_metric: Orb::Price::GroupedWithMeteredMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedWithMeteredMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedWithMeteredMinimum::Item,
          maximum: Orb::Price::GroupedWithMeteredMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedWithMeteredMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_metered_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type,
          dimensional_price_configuration: Orb::Price::GroupedWithMeteredMinimum::DimensionalPriceConfiguration?
        }

      class GroupedWithMeteredMinimum < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::GroupedWithMeteredMinimum::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::GroupedWithMeteredMinimum::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_with_metered_minimum_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::GroupedWithMeteredMinimum::Item

        attr_accessor maximum: Orb::Price::GroupedWithMeteredMinimum::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::GroupedWithMeteredMinimum::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_with_metered_minimum

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::GroupedWithMeteredMinimum::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::GroupedWithMeteredMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedWithMeteredMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedWithMeteredMinimum::Item,
          maximum: Orb::Price::GroupedWithMeteredMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedWithMeteredMinimum::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type,
          ?dimensional_price_configuration: Orb::Price::GroupedWithMeteredMinimum::DimensionalPriceConfiguration?,
          ?model_type: :grouped_with_metered_minimum
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::GroupedWithMeteredMinimum::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedWithMeteredMinimum::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedWithMeteredMinimum::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_with_metered_minimum_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedWithMeteredMinimum::Item,
          maximum: Orb::Price::GroupedWithMeteredMinimum::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedWithMeteredMinimum::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_with_metered_minimum,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedWithMeteredMinimum::price_type,
          dimensional_price_configuration: Orb::Price::GroupedWithMeteredMinimum::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedWithMeteredMinimum::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedWithMeteredMinimum::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type matrix_with_display_name =
        {
          id: String,
          billable_metric: Orb::Price::MatrixWithDisplayName::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MatrixWithDisplayName::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayName::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MatrixWithDisplayName::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MatrixWithDisplayName::InvoicingCycleConfiguration?,
          item: Orb::Price::MatrixWithDisplayName::Item,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Price::MatrixWithDisplayName::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MatrixWithDisplayName::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_display_name,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayName::price_type,
          dimensional_price_configuration: Orb::Price::MatrixWithDisplayName::DimensionalPriceConfiguration?
        }

      class MatrixWithDisplayName < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::MatrixWithDisplayName::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::MatrixWithDisplayName::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MatrixWithDisplayName::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::MatrixWithDisplayName::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::MatrixWithDisplayName::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::MatrixWithDisplayName::Item

        attr_accessor matrix_with_display_name_config: ::Hash[Symbol, top]

        attr_accessor maximum: Orb::Price::MatrixWithDisplayName::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::MatrixWithDisplayName::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :matrix_with_display_name

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MatrixWithDisplayName::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::MatrixWithDisplayName::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::MatrixWithDisplayName::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MatrixWithDisplayName::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayName::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MatrixWithDisplayName::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MatrixWithDisplayName::InvoicingCycleConfiguration?,
          item: Orb::Price::MatrixWithDisplayName::Item,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Price::MatrixWithDisplayName::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MatrixWithDisplayName::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayName::price_type,
          ?dimensional_price_configuration: Orb::Price::MatrixWithDisplayName::DimensionalPriceConfiguration?,
          ?model_type: :matrix_with_display_name
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::MatrixWithDisplayName::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MatrixWithDisplayName::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MatrixWithDisplayName::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MatrixWithDisplayName::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MatrixWithDisplayName::InvoicingCycleConfiguration?,
          item: Orb::Price::MatrixWithDisplayName::Item,
          matrix_with_display_name_config: ::Hash[Symbol, top],
          maximum: Orb::Price::MatrixWithDisplayName::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MatrixWithDisplayName::Minimum?,
          minimum_amount: String?,
          model_type: :matrix_with_display_name,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MatrixWithDisplayName::price_type,
          dimensional_price_configuration: Orb::Price::MatrixWithDisplayName::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayName::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithDisplayName::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayName::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayName::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayName::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MatrixWithDisplayName::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayName::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::MatrixWithDisplayName::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithDisplayName::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::MatrixWithDisplayName::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithDisplayName::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithDisplayName::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::field,
              operator: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::field,
              operator: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::field,
              operator: Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithDisplayName::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::MatrixWithDisplayName::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithDisplayName::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MatrixWithDisplayName::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::field,
              operator: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::field,
              operator: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::field,
              operator: Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MatrixWithDisplayName::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type bulk_with_proration =
        {
          id: String,
          billable_metric: Orb::Price::BulkWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::BulkWithProration::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::BulkWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::BulkWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::BulkWithProration::Item,
          maximum: Orb::Price::BulkWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::BulkWithProration::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProration::price_type,
          dimensional_price_configuration: Orb::Price::BulkWithProration::DimensionalPriceConfiguration?
        }

      class BulkWithProration < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::BulkWithProration::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::BulkWithProration::BillingCycleConfiguration

        attr_accessor bulk_with_proration_config: ::Hash[Symbol, top]

        attr_accessor cadence: Orb::Models::Price::BulkWithProration::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::BulkWithProration::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::BulkWithProration::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::BulkWithProration::Item

        attr_accessor maximum: Orb::Price::BulkWithProration::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::BulkWithProration::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :bulk_with_proration

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::BulkWithProration::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::BulkWithProration::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::BulkWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::BulkWithProration::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::BulkWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::BulkWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::BulkWithProration::Item,
          maximum: Orb::Price::BulkWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::BulkWithProration::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProration::price_type,
          ?dimensional_price_configuration: Orb::Price::BulkWithProration::DimensionalPriceConfiguration?,
          ?model_type: :bulk_with_proration
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::BulkWithProration::BillableMetric?,
          billing_cycle_configuration: Orb::Price::BulkWithProration::BillingCycleConfiguration,
          bulk_with_proration_config: ::Hash[Symbol, top],
          cadence: Orb::Models::Price::BulkWithProration::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::BulkWithProration::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::BulkWithProration::InvoicingCycleConfiguration?,
          item: Orb::Price::BulkWithProration::Item,
          maximum: Orb::Price::BulkWithProration::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::BulkWithProration::Minimum?,
          minimum_amount: String?,
          model_type: :bulk_with_proration,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::BulkWithProration::price_type,
          dimensional_price_configuration: Orb::Price::BulkWithProration::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProration::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkWithProration::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProration::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProration::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProration::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::BulkWithProration::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProration::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::BulkWithProration::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkWithProration::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::BulkWithProration::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkWithProration::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkWithProration::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::BulkWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::BulkWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::BulkWithProration::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::BulkWithProration::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::BulkWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::BulkWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::BulkWithProration::Maximum::Filter::field,
              operator: Orb::Models::Price::BulkWithProration::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkWithProration::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::BulkWithProration::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkWithProration::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::BulkWithProration::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::BulkWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::BulkWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::BulkWithProration::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::BulkWithProration::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::BulkWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::BulkWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::BulkWithProration::Minimum::Filter::field,
              operator: Orb::Models::Price::BulkWithProration::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::BulkWithProration::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type grouped_tiered_package =
        {
          id: String,
          billable_metric: Orb::Price::GroupedTieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedTieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedTieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedTieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedTieredPackage::Item,
          maximum: Orb::Price::GroupedTieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedTieredPackage::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackage::price_type,
          dimensional_price_configuration: Orb::Price::GroupedTieredPackage::DimensionalPriceConfiguration?
        }

      class GroupedTieredPackage < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::GroupedTieredPackage::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::GroupedTieredPackage::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::GroupedTieredPackage::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::GroupedTieredPackage::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor grouped_tiered_package_config: ::Hash[Symbol, top]

        attr_accessor invoicing_cycle_configuration: Orb::Price::GroupedTieredPackage::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::GroupedTieredPackage::Item

        attr_accessor maximum: Orb::Price::GroupedTieredPackage::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::GroupedTieredPackage::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :grouped_tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::GroupedTieredPackage::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::GroupedTieredPackage::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::GroupedTieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedTieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedTieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedTieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedTieredPackage::Item,
          maximum: Orb::Price::GroupedTieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedTieredPackage::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackage::price_type,
          ?dimensional_price_configuration: Orb::Price::GroupedTieredPackage::DimensionalPriceConfiguration?,
          ?model_type: :grouped_tiered_package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::GroupedTieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::GroupedTieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::GroupedTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::GroupedTieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          grouped_tiered_package_config: ::Hash[Symbol, top],
          invoicing_cycle_configuration: Orb::Price::GroupedTieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::GroupedTieredPackage::Item,
          maximum: Orb::Price::GroupedTieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::GroupedTieredPackage::Minimum?,
          minimum_amount: String?,
          model_type: :grouped_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::GroupedTieredPackage::price_type,
          dimensional_price_configuration: Orb::Price::GroupedTieredPackage::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackage::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTieredPackage::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackage::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackage::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackage::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::GroupedTieredPackage::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackage::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::GroupedTieredPackage::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTieredPackage::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedTieredPackage::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTieredPackage::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTieredPackage::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTieredPackage::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::GroupedTieredPackage::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTieredPackage::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::GroupedTieredPackage::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::GroupedTieredPackage::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type max_group_tiered_package =
        {
          id: String,
          billable_metric: Orb::Price::MaxGroupTieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MaxGroupTieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::MaxGroupTieredPackage::Item,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Price::MaxGroupTieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MaxGroupTieredPackage::Minimum?,
          minimum_amount: String?,
          model_type: :max_group_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type,
          dimensional_price_configuration: Orb::Price::MaxGroupTieredPackage::DimensionalPriceConfiguration?
        }

      class MaxGroupTieredPackage < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::MaxGroupTieredPackage::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::MaxGroupTieredPackage::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::MaxGroupTieredPackage::Item

        attr_accessor max_group_tiered_package_config: ::Hash[Symbol, top]

        attr_accessor maximum: Orb::Price::MaxGroupTieredPackage::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::MaxGroupTieredPackage::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :max_group_tiered_package

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::MaxGroupTieredPackage::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::MaxGroupTieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MaxGroupTieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::MaxGroupTieredPackage::Item,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Price::MaxGroupTieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MaxGroupTieredPackage::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type,
          ?dimensional_price_configuration: Orb::Price::MaxGroupTieredPackage::DimensionalPriceConfiguration?,
          ?model_type: :max_group_tiered_package
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::MaxGroupTieredPackage::BillableMetric?,
          billing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::BillingCycleConfiguration,
          cadence: Orb::Models::Price::MaxGroupTieredPackage::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::MaxGroupTieredPackage::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration?,
          item: Orb::Price::MaxGroupTieredPackage::Item,
          max_group_tiered_package_config: ::Hash[Symbol, top],
          maximum: Orb::Price::MaxGroupTieredPackage::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::MaxGroupTieredPackage::Minimum?,
          minimum_amount: String?,
          model_type: :max_group_tiered_package,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::MaxGroupTieredPackage::price_type,
          dimensional_price_configuration: Orb::Price::MaxGroupTieredPackage::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackage::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MaxGroupTieredPackage::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackage::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackage::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MaxGroupTieredPackage::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::MaxGroupTieredPackage::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MaxGroupTieredPackage::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MaxGroupTieredPackage::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::field,
              operator: Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MaxGroupTieredPackage::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::MaxGroupTieredPackage::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MaxGroupTieredPackage::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::MaxGroupTieredPackage::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::field,
              operator: Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::MaxGroupTieredPackage::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type scalable_matrix_with_unit_pricing =
        {
          id: String,
          billable_metric: Orb::Price::ScalableMatrixWithUnitPricing::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ScalableMatrixWithUnitPricing::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration?,
          item: Orb::Price::ScalableMatrixWithUnitPricing::Item,
          maximum: Orb::Price::ScalableMatrixWithUnitPricing::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ScalableMatrixWithUnitPricing::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_unit_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::ScalableMatrixWithUnitPricing::DimensionalPriceConfiguration?
        }

      class ScalableMatrixWithUnitPricing < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::ScalableMatrixWithUnitPricing::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::ScalableMatrixWithUnitPricing::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::ScalableMatrixWithUnitPricing::Item

        attr_accessor maximum: Orb::Price::ScalableMatrixWithUnitPricing::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::ScalableMatrixWithUnitPricing::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :scalable_matrix_with_unit_pricing

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type

        attr_accessor scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::ScalableMatrixWithUnitPricing::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::ScalableMatrixWithUnitPricing::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ScalableMatrixWithUnitPricing::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration?,
          item: Orb::Price::ScalableMatrixWithUnitPricing::Item,
          maximum: Orb::Price::ScalableMatrixWithUnitPricing::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ScalableMatrixWithUnitPricing::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::ScalableMatrixWithUnitPricing::DimensionalPriceConfiguration?,
          ?model_type: :scalable_matrix_with_unit_pricing
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::ScalableMatrixWithUnitPricing::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ScalableMatrixWithUnitPricing::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration?,
          item: Orb::Price::ScalableMatrixWithUnitPricing::Item,
          maximum: Orb::Price::ScalableMatrixWithUnitPricing::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ScalableMatrixWithUnitPricing::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_unit_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type,
          scalable_matrix_with_unit_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::ScalableMatrixWithUnitPricing::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithUnitPricing::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithUnitPricing::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type scalable_matrix_with_tiered_pricing =
        {
          id: String,
          billable_metric: Orb::Price::ScalableMatrixWithTieredPricing::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ScalableMatrixWithTieredPricing::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration?,
          item: Orb::Price::ScalableMatrixWithTieredPricing::Item,
          maximum: Orb::Price::ScalableMatrixWithTieredPricing::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ScalableMatrixWithTieredPricing::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_tiered_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::ScalableMatrixWithTieredPricing::DimensionalPriceConfiguration?
        }

      class ScalableMatrixWithTieredPricing < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::ScalableMatrixWithTieredPricing::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::ScalableMatrixWithTieredPricing::CreditAllocation?

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::ScalableMatrixWithTieredPricing::Item

        attr_accessor maximum: Orb::Price::ScalableMatrixWithTieredPricing::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::ScalableMatrixWithTieredPricing::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :scalable_matrix_with_tiered_pricing

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type

        attr_accessor scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top]

        attr_accessor dimensional_price_configuration: Orb::Price::ScalableMatrixWithTieredPricing::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::ScalableMatrixWithTieredPricing::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ScalableMatrixWithTieredPricing::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration?,
          item: Orb::Price::ScalableMatrixWithTieredPricing::Item,
          maximum: Orb::Price::ScalableMatrixWithTieredPricing::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ScalableMatrixWithTieredPricing::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          ?dimensional_price_configuration: Orb::Price::ScalableMatrixWithTieredPricing::DimensionalPriceConfiguration?,
          ?model_type: :scalable_matrix_with_tiered_pricing
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::ScalableMatrixWithTieredPricing::BillableMetric?,
          billing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration,
          cadence: Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::ScalableMatrixWithTieredPricing::CreditAllocation?,
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration?,
          item: Orb::Price::ScalableMatrixWithTieredPricing::Item,
          maximum: Orb::Price::ScalableMatrixWithTieredPricing::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::ScalableMatrixWithTieredPricing::Minimum?,
          minimum_amount: String?,
          model_type: :scalable_matrix_with_tiered_pricing,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type,
          scalable_matrix_with_tiered_pricing_config: ::Hash[Symbol, top],
          dimensional_price_configuration: Orb::Price::ScalableMatrixWithTieredPricing::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::ScalableMatrixWithTieredPricing::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::field,
              operator: Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::ScalableMatrixWithTieredPricing::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      type cumulative_grouped_bulk =
        {
          id: String,
          billable_metric: Orb::Price::CumulativeGroupedBulk::BillableMetric?,
          billing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::CumulativeGroupedBulk::CreditAllocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration?,
          item: Orb::Price::CumulativeGroupedBulk::Item,
          maximum: Orb::Price::CumulativeGroupedBulk::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::CumulativeGroupedBulk::Minimum?,
          minimum_amount: String?,
          model_type: :cumulative_grouped_bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type,
          dimensional_price_configuration: Orb::Price::CumulativeGroupedBulk::DimensionalPriceConfiguration?
        }

      class CumulativeGroupedBulk < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billable_metric: Orb::Price::CumulativeGroupedBulk::BillableMetric?

        attr_accessor billing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::BillingCycleConfiguration

        attr_accessor cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence

        attr_accessor conversion_rate: Float?

        attr_accessor created_at: Time

        attr_accessor credit_allocation: Orb::Price::CumulativeGroupedBulk::CreditAllocation?

        attr_accessor cumulative_grouped_bulk_config: ::Hash[Symbol, top]

        attr_accessor currency: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor invoicing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration?

        attr_accessor item: Orb::Price::CumulativeGroupedBulk::Item

        attr_accessor maximum: Orb::Price::CumulativeGroupedBulk::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor metadata: ::Hash[Symbol, String]

        attr_accessor minimum: Orb::Price::CumulativeGroupedBulk::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor model_type: :cumulative_grouped_bulk

        attr_accessor name: String

        attr_accessor plan_phase_order: Integer?

        attr_accessor price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type

        attr_accessor dimensional_price_configuration: Orb::Price::CumulativeGroupedBulk::DimensionalPriceConfiguration?

        def initialize: (
          id: String,
          billable_metric: Orb::Price::CumulativeGroupedBulk::BillableMetric?,
          billing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::CumulativeGroupedBulk::CreditAllocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration?,
          item: Orb::Price::CumulativeGroupedBulk::Item,
          maximum: Orb::Price::CumulativeGroupedBulk::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::CumulativeGroupedBulk::Minimum?,
          minimum_amount: String?,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type,
          ?dimensional_price_configuration: Orb::Price::CumulativeGroupedBulk::DimensionalPriceConfiguration?,
          ?model_type: :cumulative_grouped_bulk
        ) -> void

        def to_hash: -> {
          id: String,
          billable_metric: Orb::Price::CumulativeGroupedBulk::BillableMetric?,
          billing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::BillingCycleConfiguration,
          cadence: Orb::Models::Price::CumulativeGroupedBulk::cadence,
          conversion_rate: Float?,
          created_at: Time,
          credit_allocation: Orb::Price::CumulativeGroupedBulk::CreditAllocation?,
          cumulative_grouped_bulk_config: ::Hash[Symbol, top],
          currency: String,
          discount: Orb::Models::discount?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          invoicing_cycle_configuration: Orb::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration?,
          item: Orb::Price::CumulativeGroupedBulk::Item,
          maximum: Orb::Price::CumulativeGroupedBulk::Maximum?,
          maximum_amount: String?,
          metadata: ::Hash[Symbol, String],
          minimum: Orb::Price::CumulativeGroupedBulk::Minimum?,
          minimum_amount: String?,
          model_type: :cumulative_grouped_bulk,
          name: String,
          plan_phase_order: Integer?,
          price_type: Orb::Models::Price::CumulativeGroupedBulk::price_type,
          dimensional_price_configuration: Orb::Price::CumulativeGroupedBulk::DimensionalPriceConfiguration?
        }

        type billable_metric = { id: String }

        class BillableMetric < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type billing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulk::BillingCycleConfiguration::duration_unit
          }

        class BillingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::CumulativeGroupedBulk::BillingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulk::BillingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulk::BillingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::BillingCycleConfiguration::duration_unit]
          end
        end

        type cadence =
          :one_time | :monthly | :quarterly | :semi_annual | :annual | :custom

        module Cadence
          extend Orb::Internal::Type::Enum

          ONE_TIME: :one_time
          MONTHLY: :monthly
          QUARTERLY: :quarterly
          SEMI_ANNUAL: :semi_annual
          ANNUAL: :annual
          CUSTOM: :custom

          def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::cadence]
        end

        type credit_allocation = { allows_rollover: bool, currency: String }

        class CreditAllocation < Orb::Internal::Type::BaseModel
          attr_accessor allows_rollover: bool

          attr_accessor currency: String

          def initialize: (allows_rollover: bool, currency: String) -> void

          def to_hash: -> { allows_rollover: bool, currency: String }
        end

        type invoicing_cycle_configuration =
          {
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration::duration_unit
          }

        class InvoicingCycleConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor duration: Integer

          attr_accessor duration_unit: Orb::Models::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration::duration_unit

          def initialize: (
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration::duration_unit
          ) -> void

          def to_hash: -> {
            duration: Integer,
            duration_unit: Orb::Models::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration::duration_unit
          }

          type duration_unit = :day | :month

          module DurationUnit
            extend Orb::Internal::Type::Enum

            DAY: :day
            MONTH: :month

            def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::InvoicingCycleConfiguration::duration_unit]
          end
        end

        type item = { id: String, name: String }

        class Item < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          def initialize: (id: String, name: String) -> void

          def to_hash: -> { id: String, name: String }
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::CumulativeGroupedBulk::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::CumulativeGroupedBulk::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::CumulativeGroupedBulk::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::CumulativeGroupedBulk::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::field,
              operator: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::field,
              operator: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::field,
              operator: Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::CumulativeGroupedBulk::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Price::CumulativeGroupedBulk::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::CumulativeGroupedBulk::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Price::CumulativeGroupedBulk::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::field,
              operator: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::field,
              operator: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::field,
              operator: Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::Minimum::Filter::operator]
            end
          end
        end

        type price_type = :usage_price | :fixed_price

        module PriceType
          extend Orb::Internal::Type::Enum

          USAGE_PRICE: :usage_price
          FIXED_PRICE: :fixed_price

          def self?.values: -> ::Array[Orb::Models::Price::CumulativeGroupedBulk::price_type]
        end

        type dimensional_price_configuration =
          {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }

        class DimensionalPriceConfiguration < Orb::Internal::Type::BaseModel
          attr_accessor dimension_values: ::Array[String]

          attr_accessor dimensional_price_group_id: String

          def initialize: (
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          ) -> void

          def to_hash: -> {
            dimension_values: ::Array[String],
            dimensional_price_group_id: String
          }
        end
      end

      def self?.variants: -> ::Array[Orb::Models::price]
    end
  end
end
