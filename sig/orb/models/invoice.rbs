module Orb
  module Models
    type invoice =
      {
        id: String,
        amount_due: String,
        auto_collection: Orb::Invoice::AutoCollection,
        billing_address: Orb::Invoice::BillingAddress?,
        created_at: Time,
        credit_notes: ::Array[Orb::Invoice::CreditNote],
        currency: String,
        customer: Orb::Invoice::Customer,
        customer_balance_transactions: ::Array[Orb::Invoice::CustomerBalanceTransaction],
        customer_tax_id: Orb::Invoice::CustomerTaxID?,
        discount: top,
        discounts: ::Array[Orb::Models::invoice_level_discount],
        due_date: Time?,
        eligible_to_issue_at: Time?,
        hosted_invoice_url: String?,
        invoice_date: Time,
        invoice_number: String,
        invoice_pdf: String?,
        invoice_source: Orb::Models::Invoice::invoice_source,
        issue_failed_at: Time?,
        issued_at: Time?,
        line_items: ::Array[Orb::Invoice::LineItem],
        maximum: Orb::Invoice::Maximum?,
        maximum_amount: String?,
        memo: String?,
        metadata: ::Hash[Symbol, String],
        minimum: Orb::Invoice::Minimum?,
        minimum_amount: String?,
        paid_at: Time?,
        payment_attempts: ::Array[Orb::Invoice::PaymentAttempt],
        payment_failed_at: Time?,
        payment_started_at: Time?,
        scheduled_issue_at: Time?,
        shipping_address: Orb::Invoice::ShippingAddress?,
        status: Orb::Models::Invoice::status,
        subscription: Orb::Invoice::Subscription?,
        subtotal: String,
        sync_failed_at: Time?,
        total: String,
        voided_at: Time?,
        will_auto_issue: bool
      }

    class Invoice < Orb::Internal::Type::BaseModel
      attr_accessor id: String

      attr_accessor amount_due: String

      attr_accessor auto_collection: Orb::Invoice::AutoCollection

      attr_accessor billing_address: Orb::Invoice::BillingAddress?

      attr_accessor created_at: Time

      attr_accessor credit_notes: ::Array[Orb::Invoice::CreditNote]

      attr_accessor currency: String

      attr_accessor customer: Orb::Invoice::Customer

      attr_accessor customer_balance_transactions: ::Array[Orb::Invoice::CustomerBalanceTransaction]

      attr_accessor customer_tax_id: Orb::Invoice::CustomerTaxID?

      attr_accessor discount: top

      attr_accessor discounts: ::Array[Orb::Models::invoice_level_discount]

      attr_accessor due_date: Time?

      attr_accessor eligible_to_issue_at: Time?

      attr_accessor hosted_invoice_url: String?

      attr_accessor invoice_date: Time

      attr_accessor invoice_number: String

      attr_accessor invoice_pdf: String?

      attr_accessor invoice_source: Orb::Models::Invoice::invoice_source

      attr_accessor issue_failed_at: Time?

      attr_accessor issued_at: Time?

      attr_accessor line_items: ::Array[Orb::Invoice::LineItem]

      attr_accessor maximum: Orb::Invoice::Maximum?

      attr_accessor maximum_amount: String?

      attr_accessor memo: String?

      attr_accessor metadata: ::Hash[Symbol, String]

      attr_accessor minimum: Orb::Invoice::Minimum?

      attr_accessor minimum_amount: String?

      attr_accessor paid_at: Time?

      attr_accessor payment_attempts: ::Array[Orb::Invoice::PaymentAttempt]

      attr_accessor payment_failed_at: Time?

      attr_accessor payment_started_at: Time?

      attr_accessor scheduled_issue_at: Time?

      attr_accessor shipping_address: Orb::Invoice::ShippingAddress?

      attr_accessor status: Orb::Models::Invoice::status

      attr_accessor subscription: Orb::Invoice::Subscription?

      attr_accessor subtotal: String

      attr_accessor sync_failed_at: Time?

      attr_accessor total: String

      attr_accessor voided_at: Time?

      attr_accessor will_auto_issue: bool

      def initialize: (
        id: String,
        amount_due: String,
        auto_collection: Orb::Invoice::AutoCollection,
        billing_address: Orb::Invoice::BillingAddress?,
        created_at: Time,
        credit_notes: ::Array[Orb::Invoice::CreditNote],
        currency: String,
        customer: Orb::Invoice::Customer,
        customer_balance_transactions: ::Array[Orb::Invoice::CustomerBalanceTransaction],
        customer_tax_id: Orb::Invoice::CustomerTaxID?,
        discount: top,
        discounts: ::Array[Orb::Models::invoice_level_discount],
        due_date: Time?,
        eligible_to_issue_at: Time?,
        hosted_invoice_url: String?,
        invoice_date: Time,
        invoice_number: String,
        invoice_pdf: String?,
        invoice_source: Orb::Models::Invoice::invoice_source,
        issue_failed_at: Time?,
        issued_at: Time?,
        line_items: ::Array[Orb::Invoice::LineItem],
        maximum: Orb::Invoice::Maximum?,
        maximum_amount: String?,
        memo: String?,
        metadata: ::Hash[Symbol, String],
        minimum: Orb::Invoice::Minimum?,
        minimum_amount: String?,
        paid_at: Time?,
        payment_attempts: ::Array[Orb::Invoice::PaymentAttempt],
        payment_failed_at: Time?,
        payment_started_at: Time?,
        scheduled_issue_at: Time?,
        shipping_address: Orb::Invoice::ShippingAddress?,
        status: Orb::Models::Invoice::status,
        subscription: Orb::Invoice::Subscription?,
        subtotal: String,
        sync_failed_at: Time?,
        total: String,
        voided_at: Time?,
        will_auto_issue: bool
      ) -> void

      def to_hash: -> {
        id: String,
        amount_due: String,
        auto_collection: Orb::Invoice::AutoCollection,
        billing_address: Orb::Invoice::BillingAddress?,
        created_at: Time,
        credit_notes: ::Array[Orb::Invoice::CreditNote],
        currency: String,
        customer: Orb::Invoice::Customer,
        customer_balance_transactions: ::Array[Orb::Invoice::CustomerBalanceTransaction],
        customer_tax_id: Orb::Invoice::CustomerTaxID?,
        discount: top,
        discounts: ::Array[Orb::Models::invoice_level_discount],
        due_date: Time?,
        eligible_to_issue_at: Time?,
        hosted_invoice_url: String?,
        invoice_date: Time,
        invoice_number: String,
        invoice_pdf: String?,
        invoice_source: Orb::Models::Invoice::invoice_source,
        issue_failed_at: Time?,
        issued_at: Time?,
        line_items: ::Array[Orb::Invoice::LineItem],
        maximum: Orb::Invoice::Maximum?,
        maximum_amount: String?,
        memo: String?,
        metadata: ::Hash[Symbol, String],
        minimum: Orb::Invoice::Minimum?,
        minimum_amount: String?,
        paid_at: Time?,
        payment_attempts: ::Array[Orb::Invoice::PaymentAttempt],
        payment_failed_at: Time?,
        payment_started_at: Time?,
        scheduled_issue_at: Time?,
        shipping_address: Orb::Invoice::ShippingAddress?,
        status: Orb::Models::Invoice::status,
        subscription: Orb::Invoice::Subscription?,
        subtotal: String,
        sync_failed_at: Time?,
        total: String,
        voided_at: Time?,
        will_auto_issue: bool
      }

      type auto_collection =
        {
          enabled: bool?,
          next_attempt_at: Time?,
          num_attempts: Integer?,
          previously_attempted_at: Time?
        }

      class AutoCollection < Orb::Internal::Type::BaseModel
        attr_accessor enabled: bool?

        attr_accessor next_attempt_at: Time?

        attr_accessor num_attempts: Integer?

        attr_accessor previously_attempted_at: Time?

        def initialize: (
          enabled: bool?,
          next_attempt_at: Time?,
          num_attempts: Integer?,
          previously_attempted_at: Time?
        ) -> void

        def to_hash: -> {
          enabled: bool?,
          next_attempt_at: Time?,
          num_attempts: Integer?,
          previously_attempted_at: Time?
        }
      end

      type billing_address =
        {
          city: String?,
          country: String?,
          :line1 => String?,
          :line2 => String?,
          postal_code: String?,
          state: String?
        }

      class BillingAddress < Orb::Internal::Type::BaseModel
        attr_accessor city: String?

        attr_accessor country: String?

        attr_accessor line1: String?

        attr_accessor line2: String?

        attr_accessor postal_code: String?

        attr_accessor state: String?

        def initialize: (
          city: String?,
          country: String?,
          line1: String?,
          line2: String?,
          postal_code: String?,
          state: String?
        ) -> void

        def to_hash: -> {
          city: String?,
          country: String?,
          :line1 => String?,
          :line2 => String?,
          postal_code: String?,
          state: String?
        }
      end

      type credit_note =
        {
          id: String,
          credit_note_number: String,
          memo: String?,
          reason: String,
          total: String,
          type: String,
          voided_at: Time?
        }

      class CreditNote < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor credit_note_number: String

        attr_accessor memo: String?

        attr_accessor reason: String

        attr_accessor total: String

        attr_accessor type: String

        attr_accessor voided_at: Time?

        def initialize: (
          id: String,
          credit_note_number: String,
          memo: String?,
          reason: String,
          total: String,
          type: String,
          voided_at: Time?
        ) -> void

        def to_hash: -> {
          id: String,
          credit_note_number: String,
          memo: String?,
          reason: String,
          total: String,
          type: String,
          voided_at: Time?
        }
      end

      type customer = { id: String, external_customer_id: String? }

      class Customer < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor external_customer_id: String?

        def initialize: (id: String, external_customer_id: String?) -> void

        def to_hash: -> { id: String, external_customer_id: String? }
      end

      type customer_balance_transaction =
        {
          id: String,
          action: Orb::Models::Invoice::CustomerBalanceTransaction::action,
          amount: String,
          created_at: Time,
          credit_note: Orb::Invoice::CustomerBalanceTransaction::CreditNote?,
          description: String?,
          ending_balance: String,
          invoice: Orb::Invoice::CustomerBalanceTransaction::Invoice?,
          starting_balance: String,
          type: Orb::Models::Invoice::CustomerBalanceTransaction::type_
        }

      class CustomerBalanceTransaction < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor action: Orb::Models::Invoice::CustomerBalanceTransaction::action

        attr_accessor amount: String

        attr_accessor created_at: Time

        attr_accessor credit_note: Orb::Invoice::CustomerBalanceTransaction::CreditNote?

        attr_accessor description: String?

        attr_accessor ending_balance: String

        attr_accessor invoice: Orb::Invoice::CustomerBalanceTransaction::Invoice?

        attr_accessor starting_balance: String

        attr_accessor type: Orb::Models::Invoice::CustomerBalanceTransaction::type_

        def initialize: (
          id: String,
          action: Orb::Models::Invoice::CustomerBalanceTransaction::action,
          amount: String,
          created_at: Time,
          credit_note: Orb::Invoice::CustomerBalanceTransaction::CreditNote?,
          description: String?,
          ending_balance: String,
          invoice: Orb::Invoice::CustomerBalanceTransaction::Invoice?,
          starting_balance: String,
          type: Orb::Models::Invoice::CustomerBalanceTransaction::type_
        ) -> void

        def to_hash: -> {
          id: String,
          action: Orb::Models::Invoice::CustomerBalanceTransaction::action,
          amount: String,
          created_at: Time,
          credit_note: Orb::Invoice::CustomerBalanceTransaction::CreditNote?,
          description: String?,
          ending_balance: String,
          invoice: Orb::Invoice::CustomerBalanceTransaction::Invoice?,
          starting_balance: String,
          type: Orb::Models::Invoice::CustomerBalanceTransaction::type_
        }

        type action =
          :applied_to_invoice
          | :manual_adjustment
          | :prorated_refund
          | :revert_prorated_refund
          | :return_from_voiding
          | :credit_note_applied
          | :credit_note_voided
          | :overpayment_refund
          | :external_payment

        module Action
          extend Orb::Internal::Type::Enum

          APPLIED_TO_INVOICE: :applied_to_invoice
          MANUAL_ADJUSTMENT: :manual_adjustment
          PRORATED_REFUND: :prorated_refund
          REVERT_PRORATED_REFUND: :revert_prorated_refund
          RETURN_FROM_VOIDING: :return_from_voiding
          CREDIT_NOTE_APPLIED: :credit_note_applied
          CREDIT_NOTE_VOIDED: :credit_note_voided
          OVERPAYMENT_REFUND: :overpayment_refund
          EXTERNAL_PAYMENT: :external_payment

          def self?.values: -> ::Array[Orb::Models::Invoice::CustomerBalanceTransaction::action]
        end

        type credit_note = { id: String }

        class CreditNote < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type invoice = { id: String }

        class Invoice < Orb::Internal::Type::BaseModel
          attr_accessor id: String

          def initialize: (id: String) -> void

          def to_hash: -> { id: String }
        end

        type type_ = :increment | :decrement

        module Type
          extend Orb::Internal::Type::Enum

          INCREMENT: :increment
          DECREMENT: :decrement

          def self?.values: -> ::Array[Orb::Models::Invoice::CustomerBalanceTransaction::type_]
        end
      end

      type customer_tax_id =
        {
          country: Orb::Models::Invoice::CustomerTaxID::country,
          type: Orb::Models::Invoice::CustomerTaxID::type_,
          value: String
        }

      class CustomerTaxID < Orb::Internal::Type::BaseModel
        attr_accessor country: Orb::Models::Invoice::CustomerTaxID::country

        attr_accessor type: Orb::Models::Invoice::CustomerTaxID::type_

        attr_accessor value: String

        def initialize: (
          country: Orb::Models::Invoice::CustomerTaxID::country,
          type: Orb::Models::Invoice::CustomerTaxID::type_,
          value: String
        ) -> void

        def to_hash: -> {
          country: Orb::Models::Invoice::CustomerTaxID::country,
          type: Orb::Models::Invoice::CustomerTaxID::type_,
          value: String
        }

        type country =
          :AD
          | :AE
          | :AR
          | :AT
          | :AU
          | :BE
          | :BG
          | :BH
          | :BO
          | :BR
          | :CA
          | :CH
          | :CL
          | :CN
          | :CO
          | :CR
          | :CY
          | :CZ
          | :DE
          | :DK
          | :EE
          | :DO
          | :EC
          | :EG
          | :ES
          | :EU
          | :FI
          | :FR
          | :GB
          | :GE
          | :GR
          | :HK
          | :HR
          | :HU
          | :ID
          | :IE
          | :IL
          | :IN
          | :IS
          | :IT
          | :JP
          | :KE
          | :KR
          | :KZ
          | :LI
          | :LT
          | :LU
          | :LV
          | :MT
          | :MX
          | :MY
          | :NG
          | :NL
          | :NO
          | :NZ
          | :OM
          | :PE
          | :PH
          | :PL
          | :PT
          | :RO
          | :RS
          | :RU
          | :SA
          | :SE
          | :SG
          | :SI
          | :SK
          | :SV
          | :TH
          | :TR
          | :TW
          | :UA
          | :US
          | :UY
          | :VE
          | :VN
          | :ZA

        module Country
          extend Orb::Internal::Type::Enum

          AD: :AD
          AE: :AE
          AR: :AR
          AT: :AT
          AU: :AU
          BE: :BE
          BG: :BG
          BH: :BH
          BO: :BO
          BR: :BR
          CA: :CA
          CH: :CH
          CL: :CL
          CN: :CN
          CO: :CO
          CR: :CR
          CY: :CY
          CZ: :CZ
          DE: :DE
          DK: :DK
          EE: :EE
          DO: :DO
          EC: :EC
          EG: :EG
          ES: :ES
          EU: :EU
          FI: :FI
          FR: :FR
          GB: :GB
          GE: :GE
          GR: :GR
          HK: :HK
          HR: :HR
          HU: :HU
          ID: :ID
          IE: :IE
          IL: :IL
          IN: :IN
          IS: :IS
          IT: :IT
          JP: :JP
          KE: :KE
          KR: :KR
          KZ: :KZ
          LI: :LI
          LT: :LT
          LU: :LU
          LV: :LV
          MT: :MT
          MX: :MX
          MY: :MY
          NG: :NG
          NL: :NL
          NO: :NO
          NZ: :NZ
          OM: :OM
          PE: :PE
          PH: :PH
          PL: :PL
          PT: :PT
          RO: :RO
          RS: :RS
          RU: :RU
          SA: :SA
          SE: :SE
          SG: :SG
          SI: :SI
          SK: :SK
          SV: :SV
          TH: :TH
          TR: :TR
          TW: :TW
          UA: :UA
          US: :US
          UY: :UY
          VE: :VE
          VN: :VN
          ZA: :ZA

          def self?.values: -> ::Array[Orb::Models::Invoice::CustomerTaxID::country]
        end

        type type_ =
          :ad_nrt
          | :ae_trn
          | :ar_cuit
          | :eu_vat
          | :au_abn
          | :au_arn
          | :bg_uic
          | :bh_vat
          | :bo_tin
          | :br_cnpj
          | :br_cpf
          | :ca_bn
          | :ca_gst_hst
          | :ca_pst_bc
          | :ca_pst_mb
          | :ca_pst_sk
          | :ca_qst
          | :ch_vat
          | :cl_tin
          | :cn_tin
          | :co_nit
          | :cr_tin
          | :do_rcn
          | :ec_ruc
          | :eg_tin
          | :es_cif
          | :eu_oss_vat
          | :gb_vat
          | :ge_vat
          | :hk_br
          | :hu_tin
          | :id_npwp
          | :il_vat
          | :in_gst
          | :is_vat
          | :jp_cn
          | :jp_rn
          | :jp_trn
          | :ke_pin
          | :kr_brn
          | :kz_bin
          | :li_uid
          | :mx_rfc
          | :my_frp
          | :my_itn
          | :my_sst
          | :ng_tin
          | :no_vat
          | :no_voec
          | :nz_gst
          | :om_vat
          | :pe_ruc
          | :ph_tin
          | :ro_tin
          | :rs_pib
          | :ru_inn
          | :ru_kpp
          | :sa_vat
          | :sg_gst
          | :sg_uen
          | :si_tin
          | :sv_nit
          | :th_vat
          | :tr_tin
          | :tw_vat
          | :ua_vat
          | :us_ein
          | :uy_ruc
          | :ve_rif
          | :vn_tin
          | :za_vat

        module Type
          extend Orb::Internal::Type::Enum

          AD_NRT: :ad_nrt
          AE_TRN: :ae_trn
          AR_CUIT: :ar_cuit
          EU_VAT: :eu_vat
          AU_ABN: :au_abn
          AU_ARN: :au_arn
          BG_UIC: :bg_uic
          BH_VAT: :bh_vat
          BO_TIN: :bo_tin
          BR_CNPJ: :br_cnpj
          BR_CPF: :br_cpf
          CA_BN: :ca_bn
          CA_GST_HST: :ca_gst_hst
          CA_PST_BC: :ca_pst_bc
          CA_PST_MB: :ca_pst_mb
          CA_PST_SK: :ca_pst_sk
          CA_QST: :ca_qst
          CH_VAT: :ch_vat
          CL_TIN: :cl_tin
          CN_TIN: :cn_tin
          CO_NIT: :co_nit
          CR_TIN: :cr_tin
          DO_RCN: :do_rcn
          EC_RUC: :ec_ruc
          EG_TIN: :eg_tin
          ES_CIF: :es_cif
          EU_OSS_VAT: :eu_oss_vat
          GB_VAT: :gb_vat
          GE_VAT: :ge_vat
          HK_BR: :hk_br
          HU_TIN: :hu_tin
          ID_NPWP: :id_npwp
          IL_VAT: :il_vat
          IN_GST: :in_gst
          IS_VAT: :is_vat
          JP_CN: :jp_cn
          JP_RN: :jp_rn
          JP_TRN: :jp_trn
          KE_PIN: :ke_pin
          KR_BRN: :kr_brn
          KZ_BIN: :kz_bin
          LI_UID: :li_uid
          MX_RFC: :mx_rfc
          MY_FRP: :my_frp
          MY_ITN: :my_itn
          MY_SST: :my_sst
          NG_TIN: :ng_tin
          NO_VAT: :no_vat
          NO_VOEC: :no_voec
          NZ_GST: :nz_gst
          OM_VAT: :om_vat
          PE_RUC: :pe_ruc
          PH_TIN: :ph_tin
          RO_TIN: :ro_tin
          RS_PIB: :rs_pib
          RU_INN: :ru_inn
          RU_KPP: :ru_kpp
          SA_VAT: :sa_vat
          SG_GST: :sg_gst
          SG_UEN: :sg_uen
          SI_TIN: :si_tin
          SV_NIT: :sv_nit
          TH_VAT: :th_vat
          TR_TIN: :tr_tin
          TW_VAT: :tw_vat
          UA_VAT: :ua_vat
          US_EIN: :us_ein
          UY_RUC: :uy_ruc
          VE_RIF: :ve_rif
          VN_TIN: :vn_tin
          ZA_VAT: :za_vat

          def self?.values: -> ::Array[Orb::Models::Invoice::CustomerTaxID::type_]
        end
      end

      type invoice_source = :subscription | :partial | :one_off

      module InvoiceSource
        extend Orb::Internal::Type::Enum

        SUBSCRIPTION: :subscription
        PARTIAL: :partial
        ONE_OFF: :one_off

        def self?.values: -> ::Array[Orb::Models::Invoice::invoice_source]
      end

      type line_item =
        {
          id: String,
          adjusted_subtotal: String,
          adjustments: ::Array[Orb::Models::Invoice::LineItem::adjustment],
          amount: String,
          credits_applied: String,
          discount: Orb::Models::discount?,
          end_date: Time,
          filter: String?,
          grouping: String?,
          maximum: Orb::Invoice::LineItem::Maximum?,
          maximum_amount: String?,
          minimum: Orb::Invoice::LineItem::Minimum?,
          minimum_amount: String?,
          name: String,
          partially_invoiced_amount: String,
          price: Orb::Models::price,
          quantity: Float,
          start_date: Time,
          sub_line_items: ::Array[Orb::Models::Invoice::LineItem::sub_line_item],
          subtotal: String,
          tax_amounts: ::Array[Orb::Invoice::LineItem::TaxAmount],
          usage_customer_ids: ::Array[String]?
        }

      class LineItem < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor adjusted_subtotal: String

        attr_accessor adjustments: ::Array[Orb::Models::Invoice::LineItem::adjustment]

        attr_accessor amount: String

        attr_accessor credits_applied: String

        attr_accessor discount: Orb::Models::discount?

        attr_accessor end_date: Time

        attr_accessor filter: String?

        attr_accessor grouping: String?

        attr_accessor maximum: Orb::Invoice::LineItem::Maximum?

        attr_accessor maximum_amount: String?

        attr_accessor minimum: Orb::Invoice::LineItem::Minimum?

        attr_accessor minimum_amount: String?

        attr_accessor name: String

        attr_accessor partially_invoiced_amount: String

        attr_accessor price: Orb::Models::price

        attr_accessor quantity: Float

        attr_accessor start_date: Time

        attr_accessor sub_line_items: ::Array[Orb::Models::Invoice::LineItem::sub_line_item]

        attr_accessor subtotal: String

        attr_accessor tax_amounts: ::Array[Orb::Invoice::LineItem::TaxAmount]

        attr_accessor usage_customer_ids: ::Array[String]?

        def initialize: (
          id: String,
          adjusted_subtotal: String,
          adjustments: ::Array[Orb::Models::Invoice::LineItem::adjustment],
          amount: String,
          credits_applied: String,
          discount: Orb::Models::discount?,
          end_date: Time,
          filter: String?,
          grouping: String?,
          maximum: Orb::Invoice::LineItem::Maximum?,
          maximum_amount: String?,
          minimum: Orb::Invoice::LineItem::Minimum?,
          minimum_amount: String?,
          name: String,
          partially_invoiced_amount: String,
          price: Orb::Models::price,
          quantity: Float,
          start_date: Time,
          sub_line_items: ::Array[Orb::Models::Invoice::LineItem::sub_line_item],
          subtotal: String,
          tax_amounts: ::Array[Orb::Invoice::LineItem::TaxAmount],
          usage_customer_ids: ::Array[String]?
        ) -> void

        def to_hash: -> {
          id: String,
          adjusted_subtotal: String,
          adjustments: ::Array[Orb::Models::Invoice::LineItem::adjustment],
          amount: String,
          credits_applied: String,
          discount: Orb::Models::discount?,
          end_date: Time,
          filter: String?,
          grouping: String?,
          maximum: Orb::Invoice::LineItem::Maximum?,
          maximum_amount: String?,
          minimum: Orb::Invoice::LineItem::Minimum?,
          minimum_amount: String?,
          name: String,
          partially_invoiced_amount: String,
          price: Orb::Models::price,
          quantity: Float,
          start_date: Time,
          sub_line_items: ::Array[Orb::Models::Invoice::LineItem::sub_line_item],
          subtotal: String,
          tax_amounts: ::Array[Orb::Invoice::LineItem::TaxAmount],
          usage_customer_ids: ::Array[String]?
        }

        type adjustment =
          Orb::Invoice::LineItem::Adjustment::UsageDiscount
          | Orb::Invoice::LineItem::Adjustment::AmountDiscount
          | Orb::Invoice::LineItem::Adjustment::PercentageDiscount
          | Orb::Invoice::LineItem::Adjustment::Minimum
          | Orb::Invoice::LineItem::Adjustment::Maximum

        module Adjustment
          extend Orb::Internal::Type::Union

          type usage_discount =
            {
              id: String,
              adjustment_type: :usage_discount,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::UsageDiscount::Filter],
              is_invoice_level: bool,
              reason: String?,
              usage_discount: Float
            }

          class UsageDiscount < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :usage_discount

            attr_accessor amount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor filters: ::Array[Orb::Invoice::LineItem::Adjustment::UsageDiscount::Filter]

            attr_accessor is_invoice_level: bool

            attr_accessor reason: String?

            attr_accessor usage_discount: Float

            def initialize: (
              id: String,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::UsageDiscount::Filter],
              is_invoice_level: bool,
              reason: String?,
              usage_discount: Float,
              ?adjustment_type: :usage_discount
            ) -> void

            def to_hash: -> {
              id: String,
              adjustment_type: :usage_discount,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::UsageDiscount::Filter],
              is_invoice_level: bool,
              reason: String?,
              usage_discount: Float
            }

            type filter =
              {
                field: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::field

              attr_accessor operator: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::UsageDiscount::Filter::operator]
              end
            end
          end

          type amount_discount =
            {
              id: String,
              adjustment_type: :amount_discount,
              amount: String,
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::AmountDiscount::Filter],
              is_invoice_level: bool,
              reason: String?
            }

          class AmountDiscount < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :amount_discount

            attr_accessor amount: String

            attr_accessor amount_discount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor filters: ::Array[Orb::Invoice::LineItem::Adjustment::AmountDiscount::Filter]

            attr_accessor is_invoice_level: bool

            attr_accessor reason: String?

            def initialize: (
              id: String,
              amount: String,
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::AmountDiscount::Filter],
              is_invoice_level: bool,
              reason: String?,
              ?adjustment_type: :amount_discount
            ) -> void

            def to_hash: -> {
              id: String,
              adjustment_type: :amount_discount,
              amount: String,
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::AmountDiscount::Filter],
              is_invoice_level: bool,
              reason: String?
            }

            type filter =
              {
                field: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::field

              attr_accessor operator: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::AmountDiscount::Filter::operator]
              end
            end
          end

          type percentage_discount =
            {
              id: String,
              adjustment_type: :percentage_discount,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::PercentageDiscount::Filter],
              is_invoice_level: bool,
              percentage_discount: Float,
              reason: String?
            }

          class PercentageDiscount < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :percentage_discount

            attr_accessor amount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor filters: ::Array[Orb::Invoice::LineItem::Adjustment::PercentageDiscount::Filter]

            attr_accessor is_invoice_level: bool

            attr_accessor percentage_discount: Float

            attr_accessor reason: String?

            def initialize: (
              id: String,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::PercentageDiscount::Filter],
              is_invoice_level: bool,
              percentage_discount: Float,
              reason: String?,
              ?adjustment_type: :percentage_discount
            ) -> void

            def to_hash: -> {
              id: String,
              adjustment_type: :percentage_discount,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::PercentageDiscount::Filter],
              is_invoice_level: bool,
              percentage_discount: Float,
              reason: String?
            }

            type filter =
              {
                field: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::field

              attr_accessor operator: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::PercentageDiscount::Filter::operator]
              end
            end
          end

          type minimum =
            {
              id: String,
              adjustment_type: :minimum,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::Minimum::Filter],
              is_invoice_level: bool,
              item_id: String,
              minimum_amount: String,
              reason: String?
            }

          class Minimum < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :minimum

            attr_accessor amount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor filters: ::Array[Orb::Invoice::LineItem::Adjustment::Minimum::Filter]

            attr_accessor is_invoice_level: bool

            attr_accessor item_id: String

            attr_accessor minimum_amount: String

            attr_accessor reason: String?

            def initialize: (
              id: String,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::Minimum::Filter],
              is_invoice_level: bool,
              item_id: String,
              minimum_amount: String,
              reason: String?,
              ?adjustment_type: :minimum
            ) -> void

            def to_hash: -> {
              id: String,
              adjustment_type: :minimum,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::Minimum::Filter],
              is_invoice_level: bool,
              item_id: String,
              minimum_amount: String,
              reason: String?
            }

            type filter =
              {
                field: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::field

              attr_accessor operator: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::Minimum::Filter::operator]
              end
            end
          end

          type maximum =
            {
              id: String,
              adjustment_type: :maximum,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::Maximum::Filter],
              is_invoice_level: bool,
              maximum_amount: String,
              reason: String?
            }

          class Maximum < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :maximum

            attr_accessor amount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor filters: ::Array[Orb::Invoice::LineItem::Adjustment::Maximum::Filter]

            attr_accessor is_invoice_level: bool

            attr_accessor maximum_amount: String

            attr_accessor reason: String?

            def initialize: (
              id: String,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::Maximum::Filter],
              is_invoice_level: bool,
              maximum_amount: String,
              reason: String?,
              ?adjustment_type: :maximum
            ) -> void

            def to_hash: -> {
              id: String,
              adjustment_type: :maximum,
              amount: String,
              applies_to_price_ids: ::Array[String],
              filters: ::Array[Orb::Invoice::LineItem::Adjustment::Maximum::Filter],
              is_invoice_level: bool,
              maximum_amount: String,
              reason: String?
            }

            type filter =
              {
                field: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::operator,
                values: ::Array[String]
              }

            class Filter < Orb::Internal::Type::BaseModel
              attr_accessor field: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::field

              attr_accessor operator: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::operator

              attr_accessor values: ::Array[String]

              def initialize: (
                field: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::operator,
                values: ::Array[String]
              ) -> void

              def to_hash: -> {
                field: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::field,
                operator: Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::operator,
                values: ::Array[String]
              }

              type field =
                :price_id
                | :item_id
                | :price_type
                | :currency
                | :pricing_unit_id

              module Field
                extend Orb::Internal::Type::Enum

                PRICE_ID: :price_id
                ITEM_ID: :item_id
                PRICE_TYPE: :price_type
                CURRENCY: :currency
                PRICING_UNIT_ID: :pricing_unit_id

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::field]
              end

              type operator = :includes | :excludes

              module Operator
                extend Orb::Internal::Type::Enum

                INCLUDES: :includes
                EXCLUDES: :excludes

                def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Adjustment::Maximum::Filter::operator]
              end
            end
          end

          def self?.variants: -> ::Array[Orb::Models::Invoice::LineItem::adjustment]
        end

        type maximum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Invoice::LineItem::Maximum::Filter],
            maximum_amount: String
          }

        class Maximum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Invoice::LineItem::Maximum::Filter]

          attr_accessor maximum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Invoice::LineItem::Maximum::Filter],
            maximum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Invoice::LineItem::Maximum::Filter],
            maximum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Invoice::LineItem::Maximum::Filter::field,
              operator: Orb::Models::Invoice::LineItem::Maximum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Invoice::LineItem::Maximum::Filter::field

            attr_accessor operator: Orb::Models::Invoice::LineItem::Maximum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Invoice::LineItem::Maximum::Filter::field,
              operator: Orb::Models::Invoice::LineItem::Maximum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Invoice::LineItem::Maximum::Filter::field,
              operator: Orb::Models::Invoice::LineItem::Maximum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Maximum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Maximum::Filter::operator]
            end
          end
        end

        type minimum =
          {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Invoice::LineItem::Minimum::Filter],
            minimum_amount: String
          }

        class Minimum < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor filters: ::Array[Orb::Invoice::LineItem::Minimum::Filter]

          attr_accessor minimum_amount: String

          def initialize: (
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Invoice::LineItem::Minimum::Filter],
            minimum_amount: String
          ) -> void

          def to_hash: -> {
            applies_to_price_ids: ::Array[String],
            filters: ::Array[Orb::Invoice::LineItem::Minimum::Filter],
            minimum_amount: String
          }

          type filter =
            {
              field: Orb::Models::Invoice::LineItem::Minimum::Filter::field,
              operator: Orb::Models::Invoice::LineItem::Minimum::Filter::operator,
              values: ::Array[String]
            }

          class Filter < Orb::Internal::Type::BaseModel
            attr_accessor field: Orb::Models::Invoice::LineItem::Minimum::Filter::field

            attr_accessor operator: Orb::Models::Invoice::LineItem::Minimum::Filter::operator

            attr_accessor values: ::Array[String]

            def initialize: (
              field: Orb::Models::Invoice::LineItem::Minimum::Filter::field,
              operator: Orb::Models::Invoice::LineItem::Minimum::Filter::operator,
              values: ::Array[String]
            ) -> void

            def to_hash: -> {
              field: Orb::Models::Invoice::LineItem::Minimum::Filter::field,
              operator: Orb::Models::Invoice::LineItem::Minimum::Filter::operator,
              values: ::Array[String]
            }

            type field =
              :price_id | :item_id | :price_type | :currency | :pricing_unit_id

            module Field
              extend Orb::Internal::Type::Enum

              PRICE_ID: :price_id
              ITEM_ID: :item_id
              PRICE_TYPE: :price_type
              CURRENCY: :currency
              PRICING_UNIT_ID: :pricing_unit_id

              def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Minimum::Filter::field]
            end

            type operator = :includes | :excludes

            module Operator
              extend Orb::Internal::Type::Enum

              INCLUDES: :includes
              EXCLUDES: :excludes

              def self?.values: -> ::Array[Orb::Models::Invoice::LineItem::Minimum::Filter::operator]
            end
          end
        end

        type sub_line_item =
          Orb::Invoice::LineItem::SubLineItem::Matrix
          | Orb::Invoice::LineItem::SubLineItem::Tier
          | Orb::Invoice::LineItem::SubLineItem::Null

        module SubLineItem
          extend Orb::Internal::Type::Union

          type matrix =
            {
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Matrix::Grouping?,
              matrix_config: Orb::Invoice::LineItem::SubLineItem::Matrix::MatrixConfig,
              name: String,
              quantity: Float,
              type: :matrix
            }

          class Matrix < Orb::Internal::Type::BaseModel
            attr_accessor amount: String

            attr_accessor grouping: Orb::Invoice::LineItem::SubLineItem::Matrix::Grouping?

            attr_accessor matrix_config: Orb::Invoice::LineItem::SubLineItem::Matrix::MatrixConfig

            attr_accessor name: String

            attr_accessor quantity: Float

            attr_accessor type: :matrix

            def initialize: (
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Matrix::Grouping?,
              matrix_config: Orb::Invoice::LineItem::SubLineItem::Matrix::MatrixConfig,
              name: String,
              quantity: Float,
              ?type: :matrix
            ) -> void

            def to_hash: -> {
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Matrix::Grouping?,
              matrix_config: Orb::Invoice::LineItem::SubLineItem::Matrix::MatrixConfig,
              name: String,
              quantity: Float,
              type: :matrix
            }

            type grouping = { key: String, value: String? }

            class Grouping < Orb::Internal::Type::BaseModel
              attr_accessor key: String

              attr_accessor value: String?

              def initialize: (key: String, value: String?) -> void

              def to_hash: -> { key: String, value: String? }
            end

            type matrix_config = { dimension_values: ::Array[String?] }

            class MatrixConfig < Orb::Internal::Type::BaseModel
              attr_accessor dimension_values: ::Array[String?]

              def initialize: (dimension_values: ::Array[String?]) -> void

              def to_hash: -> { dimension_values: ::Array[String?] }
            end
          end

          type tier =
            {
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Tier::Grouping?,
              name: String,
              quantity: Float,
              tier_config: Orb::Invoice::LineItem::SubLineItem::Tier::TierConfig,
              type: :tier
            }

          class Tier < Orb::Internal::Type::BaseModel
            attr_accessor amount: String

            attr_accessor grouping: Orb::Invoice::LineItem::SubLineItem::Tier::Grouping?

            attr_accessor name: String

            attr_accessor quantity: Float

            attr_accessor tier_config: Orb::Invoice::LineItem::SubLineItem::Tier::TierConfig

            attr_accessor type: :tier

            def initialize: (
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Tier::Grouping?,
              name: String,
              quantity: Float,
              tier_config: Orb::Invoice::LineItem::SubLineItem::Tier::TierConfig,
              ?type: :tier
            ) -> void

            def to_hash: -> {
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Tier::Grouping?,
              name: String,
              quantity: Float,
              tier_config: Orb::Invoice::LineItem::SubLineItem::Tier::TierConfig,
              type: :tier
            }

            type grouping = { key: String, value: String? }

            class Grouping < Orb::Internal::Type::BaseModel
              attr_accessor key: String

              attr_accessor value: String?

              def initialize: (key: String, value: String?) -> void

              def to_hash: -> { key: String, value: String? }
            end

            type tier_config =
              { first_unit: Float, last_unit: Float?, unit_amount: String }

            class TierConfig < Orb::Internal::Type::BaseModel
              attr_accessor first_unit: Float

              attr_accessor last_unit: Float?

              attr_accessor unit_amount: String

              def initialize: (
                first_unit: Float,
                last_unit: Float?,
                unit_amount: String
              ) -> void

              def to_hash: -> {
                first_unit: Float,
                last_unit: Float?,
                unit_amount: String
              }
            end
          end

          type null =
            {
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Null::Grouping?,
              name: String,
              quantity: Float,
              type: :"'null'"
            }

          class Null < Orb::Internal::Type::BaseModel
            attr_accessor amount: String

            attr_accessor grouping: Orb::Invoice::LineItem::SubLineItem::Null::Grouping?

            attr_accessor name: String

            attr_accessor quantity: Float

            attr_accessor type: :"'null'"

            def initialize: (
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Null::Grouping?,
              name: String,
              quantity: Float,
              ?type: :"'null'"
            ) -> void

            def to_hash: -> {
              amount: String,
              grouping: Orb::Invoice::LineItem::SubLineItem::Null::Grouping?,
              name: String,
              quantity: Float,
              type: :"'null'"
            }

            type grouping = { key: String, value: String? }

            class Grouping < Orb::Internal::Type::BaseModel
              attr_accessor key: String

              attr_accessor value: String?

              def initialize: (key: String, value: String?) -> void

              def to_hash: -> { key: String, value: String? }
            end
          end

          def self?.variants: -> ::Array[Orb::Models::Invoice::LineItem::sub_line_item]
        end

        type tax_amount =
          {
            amount: String,
            tax_rate_description: String,
            tax_rate_percentage: String?
          }

        class TaxAmount < Orb::Internal::Type::BaseModel
          attr_accessor amount: String

          attr_accessor tax_rate_description: String

          attr_accessor tax_rate_percentage: String?

          def initialize: (
            amount: String,
            tax_rate_description: String,
            tax_rate_percentage: String?
          ) -> void

          def to_hash: -> {
            amount: String,
            tax_rate_description: String,
            tax_rate_percentage: String?
          }
        end
      end

      type maximum =
        {
          applies_to_price_ids: ::Array[String],
          filters: ::Array[Orb::Invoice::Maximum::Filter],
          maximum_amount: String
        }

      class Maximum < Orb::Internal::Type::BaseModel
        attr_accessor applies_to_price_ids: ::Array[String]

        attr_accessor filters: ::Array[Orb::Invoice::Maximum::Filter]

        attr_accessor maximum_amount: String

        def initialize: (
          applies_to_price_ids: ::Array[String],
          filters: ::Array[Orb::Invoice::Maximum::Filter],
          maximum_amount: String
        ) -> void

        def to_hash: -> {
          applies_to_price_ids: ::Array[String],
          filters: ::Array[Orb::Invoice::Maximum::Filter],
          maximum_amount: String
        }

        type filter =
          {
            field: Orb::Models::Invoice::Maximum::Filter::field,
            operator: Orb::Models::Invoice::Maximum::Filter::operator,
            values: ::Array[String]
          }

        class Filter < Orb::Internal::Type::BaseModel
          attr_accessor field: Orb::Models::Invoice::Maximum::Filter::field

          attr_accessor operator: Orb::Models::Invoice::Maximum::Filter::operator

          attr_accessor values: ::Array[String]

          def initialize: (
            field: Orb::Models::Invoice::Maximum::Filter::field,
            operator: Orb::Models::Invoice::Maximum::Filter::operator,
            values: ::Array[String]
          ) -> void

          def to_hash: -> {
            field: Orb::Models::Invoice::Maximum::Filter::field,
            operator: Orb::Models::Invoice::Maximum::Filter::operator,
            values: ::Array[String]
          }

          type field =
            :price_id | :item_id | :price_type | :currency | :pricing_unit_id

          module Field
            extend Orb::Internal::Type::Enum

            PRICE_ID: :price_id
            ITEM_ID: :item_id
            PRICE_TYPE: :price_type
            CURRENCY: :currency
            PRICING_UNIT_ID: :pricing_unit_id

            def self?.values: -> ::Array[Orb::Models::Invoice::Maximum::Filter::field]
          end

          type operator = :includes | :excludes

          module Operator
            extend Orb::Internal::Type::Enum

            INCLUDES: :includes
            EXCLUDES: :excludes

            def self?.values: -> ::Array[Orb::Models::Invoice::Maximum::Filter::operator]
          end
        end
      end

      type minimum =
        {
          applies_to_price_ids: ::Array[String],
          filters: ::Array[Orb::Invoice::Minimum::Filter],
          minimum_amount: String
        }

      class Minimum < Orb::Internal::Type::BaseModel
        attr_accessor applies_to_price_ids: ::Array[String]

        attr_accessor filters: ::Array[Orb::Invoice::Minimum::Filter]

        attr_accessor minimum_amount: String

        def initialize: (
          applies_to_price_ids: ::Array[String],
          filters: ::Array[Orb::Invoice::Minimum::Filter],
          minimum_amount: String
        ) -> void

        def to_hash: -> {
          applies_to_price_ids: ::Array[String],
          filters: ::Array[Orb::Invoice::Minimum::Filter],
          minimum_amount: String
        }

        type filter =
          {
            field: Orb::Models::Invoice::Minimum::Filter::field,
            operator: Orb::Models::Invoice::Minimum::Filter::operator,
            values: ::Array[String]
          }

        class Filter < Orb::Internal::Type::BaseModel
          attr_accessor field: Orb::Models::Invoice::Minimum::Filter::field

          attr_accessor operator: Orb::Models::Invoice::Minimum::Filter::operator

          attr_accessor values: ::Array[String]

          def initialize: (
            field: Orb::Models::Invoice::Minimum::Filter::field,
            operator: Orb::Models::Invoice::Minimum::Filter::operator,
            values: ::Array[String]
          ) -> void

          def to_hash: -> {
            field: Orb::Models::Invoice::Minimum::Filter::field,
            operator: Orb::Models::Invoice::Minimum::Filter::operator,
            values: ::Array[String]
          }

          type field =
            :price_id | :item_id | :price_type | :currency | :pricing_unit_id

          module Field
            extend Orb::Internal::Type::Enum

            PRICE_ID: :price_id
            ITEM_ID: :item_id
            PRICE_TYPE: :price_type
            CURRENCY: :currency
            PRICING_UNIT_ID: :pricing_unit_id

            def self?.values: -> ::Array[Orb::Models::Invoice::Minimum::Filter::field]
          end

          type operator = :includes | :excludes

          module Operator
            extend Orb::Internal::Type::Enum

            INCLUDES: :includes
            EXCLUDES: :excludes

            def self?.values: -> ::Array[Orb::Models::Invoice::Minimum::Filter::operator]
          end
        end
      end

      type payment_attempt =
        {
          id: String,
          amount: String,
          created_at: Time,
          payment_provider: Orb::Models::Invoice::PaymentAttempt::payment_provider?,
          payment_provider_id: String?,
          succeeded: bool
        }

      class PaymentAttempt < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor amount: String

        attr_accessor created_at: Time

        attr_accessor payment_provider: Orb::Models::Invoice::PaymentAttempt::payment_provider?

        attr_accessor payment_provider_id: String?

        attr_accessor succeeded: bool

        def initialize: (
          id: String,
          amount: String,
          created_at: Time,
          payment_provider: Orb::Models::Invoice::PaymentAttempt::payment_provider?,
          payment_provider_id: String?,
          succeeded: bool
        ) -> void

        def to_hash: -> {
          id: String,
          amount: String,
          created_at: Time,
          payment_provider: Orb::Models::Invoice::PaymentAttempt::payment_provider?,
          payment_provider_id: String?,
          succeeded: bool
        }

        type payment_provider = :stripe

        module PaymentProvider
          extend Orb::Internal::Type::Enum

          STRIPE: :stripe

          def self?.values: -> ::Array[Orb::Models::Invoice::PaymentAttempt::payment_provider]
        end
      end

      type shipping_address =
        {
          city: String?,
          country: String?,
          :line1 => String?,
          :line2 => String?,
          postal_code: String?,
          state: String?
        }

      class ShippingAddress < Orb::Internal::Type::BaseModel
        attr_accessor city: String?

        attr_accessor country: String?

        attr_accessor line1: String?

        attr_accessor line2: String?

        attr_accessor postal_code: String?

        attr_accessor state: String?

        def initialize: (
          city: String?,
          country: String?,
          line1: String?,
          line2: String?,
          postal_code: String?,
          state: String?
        ) -> void

        def to_hash: -> {
          city: String?,
          country: String?,
          :line1 => String?,
          :line2 => String?,
          postal_code: String?,
          state: String?
        }
      end

      type status = :issued | :paid | :synced | :void | :draft

      module Status
        extend Orb::Internal::Type::Enum

        ISSUED: :issued
        PAID: :paid
        SYNCED: :synced
        VOID: :void
        DRAFT: :draft

        def self?.values: -> ::Array[Orb::Models::Invoice::status]
      end

      type subscription = { id: String }

      class Subscription < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        def initialize: (id: String) -> void

        def to_hash: -> { id: String }
      end
    end
  end
end
