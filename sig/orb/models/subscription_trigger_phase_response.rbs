module Orb
  module Models
    type subscription_trigger_phase_response =
      {
        id: String,
        active_plan_phase_order: Integer?,
        adjustment_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval],
        auto_collection: bool?,
        billing_cycle_anchor_configuration: Orb::Models::SubscriptionTriggerPhaseResponse::BillingCycleAnchorConfiguration,
        billing_cycle_day: Integer,
        created_at: Time,
        current_billing_period_end_date: Time?,
        current_billing_period_start_date: Time?,
        customer: Orb::Customer,
        default_invoice_memo: String?,
        discount_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::discount_interval],
        end_date: Time?,
        fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::FixedFeeQuantitySchedule],
        invoicing_threshold: String?,
        maximum_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::MaximumInterval],
        metadata: ::Hash[Symbol, String],
        minimum_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::MinimumInterval],
        net_terms: Integer,
        pending_subscription_change: Orb::Models::SubscriptionTriggerPhaseResponse::PendingSubscriptionChange?,
        plan: Orb::Plan,
        price_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::PriceInterval],
        redeemed_coupon: Orb::Models::SubscriptionTriggerPhaseResponse::RedeemedCoupon?,
        start_date: Time,
        status: Orb::Models::SubscriptionTriggerPhaseResponse::status,
        trial_info: Orb::Models::SubscriptionTriggerPhaseResponse::TrialInfo,
        changed_resources: Orb::Models::SubscriptionTriggerPhaseResponse::ChangedResources?
      }

    class SubscriptionTriggerPhaseResponse < Orb::Internal::Type::BaseModel
      attr_accessor id: String

      attr_accessor active_plan_phase_order: Integer?

      attr_accessor adjustment_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval]

      attr_accessor auto_collection: bool?

      attr_accessor billing_cycle_anchor_configuration: Orb::Models::SubscriptionTriggerPhaseResponse::BillingCycleAnchorConfiguration

      attr_accessor billing_cycle_day: Integer

      attr_accessor created_at: Time

      attr_accessor current_billing_period_end_date: Time?

      attr_accessor current_billing_period_start_date: Time?

      attr_accessor customer: Orb::Customer

      attr_accessor default_invoice_memo: String?

      attr_accessor discount_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::discount_interval]

      attr_accessor end_date: Time?

      attr_accessor fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::FixedFeeQuantitySchedule]

      attr_accessor invoicing_threshold: String?

      attr_accessor maximum_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::MaximumInterval]

      attr_accessor metadata: ::Hash[Symbol, String]

      attr_accessor minimum_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::MinimumInterval]

      attr_accessor net_terms: Integer

      attr_accessor pending_subscription_change: Orb::Models::SubscriptionTriggerPhaseResponse::PendingSubscriptionChange?

      attr_accessor plan: Orb::Plan

      attr_accessor price_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::PriceInterval]

      attr_accessor redeemed_coupon: Orb::Models::SubscriptionTriggerPhaseResponse::RedeemedCoupon?

      attr_accessor start_date: Time

      attr_accessor status: Orb::Models::SubscriptionTriggerPhaseResponse::status

      attr_accessor trial_info: Orb::Models::SubscriptionTriggerPhaseResponse::TrialInfo

      attr_accessor changed_resources: Orb::Models::SubscriptionTriggerPhaseResponse::ChangedResources?

      def initialize: (
        id: String,
        active_plan_phase_order: Integer?,
        adjustment_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval],
        auto_collection: bool?,
        billing_cycle_anchor_configuration: Orb::Models::SubscriptionTriggerPhaseResponse::BillingCycleAnchorConfiguration,
        billing_cycle_day: Integer,
        created_at: Time,
        current_billing_period_end_date: Time?,
        current_billing_period_start_date: Time?,
        customer: Orb::Customer,
        default_invoice_memo: String?,
        discount_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::discount_interval],
        end_date: Time?,
        fixed_fee_quantity_schedule: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::FixedFeeQuantitySchedule],
        invoicing_threshold: String?,
        maximum_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::MaximumInterval],
        metadata: ::Hash[Symbol, String],
        minimum_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::MinimumInterval],
        net_terms: Integer,
        pending_subscription_change: Orb::Models::SubscriptionTriggerPhaseResponse::PendingSubscriptionChange?,
        plan: Orb::Plan,
        price_intervals: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::PriceInterval],
        redeemed_coupon: Orb::Models::SubscriptionTriggerPhaseResponse::RedeemedCoupon?,
        start_date: Time,
        status: Orb::Models::SubscriptionTriggerPhaseResponse::status,
        trial_info: Orb::Models::SubscriptionTriggerPhaseResponse::TrialInfo,
        ?changed_resources: Orb::Models::SubscriptionTriggerPhaseResponse::ChangedResources?
      ) -> void

      type adjustment_interval =
        {
          id: String,
          adjustment: Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::adjustment,
          applies_to_price_interval_ids: ::Array[String],
          end_date: Time?,
          start_date: Time
        }

      class AdjustmentInterval < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor adjustment: Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::adjustment

        attr_accessor applies_to_price_interval_ids: ::Array[String]

        attr_accessor end_date: Time?

        attr_accessor start_date: Time

        def initialize: (
          id: String,
          adjustment: Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::adjustment,
          applies_to_price_interval_ids: ::Array[String],
          end_date: Time?,
          start_date: Time
        ) -> void

        type adjustment =
          Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::Adjustment::UsageDiscount
          | Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::Adjustment::AmountDiscount
          | Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::Adjustment::PercentageDiscount
          | Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::Adjustment::Minimum
          | Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::Adjustment::Maximum

        module Adjustment
          extend Orb::Internal::Type::Union

          type usage_discount =
            {
              id: String,
              adjustment_type: :usage_discount,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              plan_phase_order: Integer?,
              reason: String?,
              usage_discount: Float
            }

          class UsageDiscount < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :usage_discount

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            attr_accessor usage_discount: Float

            def initialize: (
              id: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              plan_phase_order: Integer?,
              reason: String?,
              usage_discount: Float,
              ?adjustment_type: :usage_discount
            ) -> void
          end

          type amount_discount =
            {
              id: String,
              adjustment_type: :amount_discount,
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              plan_phase_order: Integer?,
              reason: String?
            }

          class AmountDiscount < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :amount_discount

            attr_accessor amount_discount: String

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize: (
              id: String,
              amount_discount: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              plan_phase_order: Integer?,
              reason: String?,
              ?adjustment_type: :amount_discount
            ) -> void
          end

          type percentage_discount =
            {
              id: String,
              adjustment_type: :percentage_discount,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              percentage_discount: Float,
              plan_phase_order: Integer?,
              reason: String?
            }

          class PercentageDiscount < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :percentage_discount

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor percentage_discount: Float

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize: (
              id: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              percentage_discount: Float,
              plan_phase_order: Integer?,
              reason: String?,
              ?adjustment_type: :percentage_discount
            ) -> void
          end

          type minimum =
            {
              id: String,
              adjustment_type: :minimum,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              item_id: String,
              minimum_amount: String,
              plan_phase_order: Integer?,
              reason: String?
            }

          class Minimum < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :minimum

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor item_id: String

            attr_accessor minimum_amount: String

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize: (
              id: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              item_id: String,
              minimum_amount: String,
              plan_phase_order: Integer?,
              reason: String?,
              ?adjustment_type: :minimum
            ) -> void
          end

          type maximum =
            {
              id: String,
              adjustment_type: :maximum,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              maximum_amount: String,
              plan_phase_order: Integer?,
              reason: String?
            }

          class Maximum < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor adjustment_type: :maximum

            attr_accessor applies_to_price_ids: ::Array[String]

            attr_accessor is_invoice_level: bool

            attr_accessor maximum_amount: String

            attr_accessor plan_phase_order: Integer?

            attr_accessor reason: String?

            def initialize: (
              id: String,
              applies_to_price_ids: ::Array[String],
              is_invoice_level: bool,
              maximum_amount: String,
              plan_phase_order: Integer?,
              reason: String?,
              ?adjustment_type: :maximum
            ) -> void
          end

          def self?.variants: -> ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::AdjustmentInterval::adjustment]
        end
      end

      type billing_cycle_anchor_configuration =
        { day: Integer, month: Integer?, year: Integer? }

      class BillingCycleAnchorConfiguration < Orb::Internal::Type::BaseModel
        attr_accessor day: Integer

        attr_accessor month: Integer?

        attr_accessor year: Integer?

        def initialize: (
          day: Integer,
          ?month: Integer?,
          ?year: Integer?
        ) -> void
      end

      type discount_interval =
        Orb::Models::SubscriptionTriggerPhaseResponse::DiscountInterval::Amount
        | Orb::Models::SubscriptionTriggerPhaseResponse::DiscountInterval::Percentage
        | Orb::Models::SubscriptionTriggerPhaseResponse::DiscountInterval::Usage

      module DiscountInterval
        extend Orb::Internal::Type::Union

        type amount =
          {
            amount_discount: String,
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            discount_type: :amount,
            end_date: Time?,
            start_date: Time
          }

        class Amount < Orb::Internal::Type::BaseModel
          attr_accessor amount_discount: String

          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor discount_type: :amount

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          def initialize: (
            amount_discount: String,
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time,
            ?discount_type: :amount
          ) -> void
        end

        type percentage =
          {
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            discount_type: :percentage,
            end_date: Time?,
            percentage_discount: Float,
            start_date: Time
          }

        class Percentage < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor discount_type: :percentage

          attr_accessor end_date: Time?

          attr_accessor percentage_discount: Float

          attr_accessor start_date: Time

          def initialize: (
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            percentage_discount: Float,
            start_date: Time,
            ?discount_type: :percentage
          ) -> void
        end

        type usage =
          {
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            discount_type: :usage,
            end_date: Time?,
            start_date: Time,
            usage_discount: Float
          }

        class Usage < Orb::Internal::Type::BaseModel
          attr_accessor applies_to_price_ids: ::Array[String]

          attr_accessor applies_to_price_interval_ids: ::Array[String]

          attr_accessor discount_type: :usage

          attr_accessor end_date: Time?

          attr_accessor start_date: Time

          attr_accessor usage_discount: Float

          def initialize: (
            applies_to_price_ids: ::Array[String],
            applies_to_price_interval_ids: ::Array[String],
            end_date: Time?,
            start_date: Time,
            usage_discount: Float,
            ?discount_type: :usage
          ) -> void
        end

        def self?.variants: -> ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::discount_interval]
      end

      type fixed_fee_quantity_schedule =
        { end_date: Time?, price_id: String, quantity: Float, start_date: Time }

      class FixedFeeQuantitySchedule < Orb::Internal::Type::BaseModel
        attr_accessor end_date: Time?

        attr_accessor price_id: String

        attr_accessor quantity: Float

        attr_accessor start_date: Time

        def initialize: (
          end_date: Time?,
          price_id: String,
          quantity: Float,
          start_date: Time
        ) -> void
      end

      type maximum_interval =
        {
          applies_to_price_ids: ::Array[String],
          applies_to_price_interval_ids: ::Array[String],
          end_date: Time?,
          maximum_amount: String,
          start_date: Time
        }

      class MaximumInterval < Orb::Internal::Type::BaseModel
        attr_accessor applies_to_price_ids: ::Array[String]

        attr_accessor applies_to_price_interval_ids: ::Array[String]

        attr_accessor end_date: Time?

        attr_accessor maximum_amount: String

        attr_accessor start_date: Time

        def initialize: (
          applies_to_price_ids: ::Array[String],
          applies_to_price_interval_ids: ::Array[String],
          end_date: Time?,
          maximum_amount: String,
          start_date: Time
        ) -> void
      end

      type minimum_interval =
        {
          applies_to_price_ids: ::Array[String],
          applies_to_price_interval_ids: ::Array[String],
          end_date: Time?,
          minimum_amount: String,
          start_date: Time
        }

      class MinimumInterval < Orb::Internal::Type::BaseModel
        attr_accessor applies_to_price_ids: ::Array[String]

        attr_accessor applies_to_price_interval_ids: ::Array[String]

        attr_accessor end_date: Time?

        attr_accessor minimum_amount: String

        attr_accessor start_date: Time

        def initialize: (
          applies_to_price_ids: ::Array[String],
          applies_to_price_interval_ids: ::Array[String],
          end_date: Time?,
          minimum_amount: String,
          start_date: Time
        ) -> void
      end

      type pending_subscription_change = { id: String }

      class PendingSubscriptionChange < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        def initialize: (id: String) -> void
      end

      type price_interval =
        {
          id: String,
          billing_cycle_day: Integer,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          end_date: Time?,
          filter: String?,
          fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::PriceInterval::FixedFeeQuantityTransition]?,
          price: Orb::Models::price,
          start_date: Time,
          usage_customer_ids: ::Array[String]?
        }

      class PriceInterval < Orb::Internal::Type::BaseModel
        attr_accessor id: String

        attr_accessor billing_cycle_day: Integer

        attr_accessor current_billing_period_end_date: Time?

        attr_accessor current_billing_period_start_date: Time?

        attr_accessor end_date: Time?

        attr_accessor filter: String?

        attr_accessor fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::PriceInterval::FixedFeeQuantityTransition]?

        attr_accessor price: Orb::Models::price

        attr_accessor start_date: Time

        attr_accessor usage_customer_ids: ::Array[String]?

        def initialize: (
          id: String,
          billing_cycle_day: Integer,
          current_billing_period_end_date: Time?,
          current_billing_period_start_date: Time?,
          end_date: Time?,
          filter: String?,
          fixed_fee_quantity_transitions: ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::PriceInterval::FixedFeeQuantityTransition]?,
          price: Orb::Models::price,
          start_date: Time,
          usage_customer_ids: ::Array[String]?
        ) -> void

        type fixed_fee_quantity_transition =
          { effective_date: Time, price_id: String, quantity: Integer }

        class FixedFeeQuantityTransition < Orb::Internal::Type::BaseModel
          attr_accessor effective_date: Time

          attr_accessor price_id: String

          attr_accessor quantity: Integer

          def initialize: (
            effective_date: Time,
            price_id: String,
            quantity: Integer
          ) -> void
        end
      end

      type redeemed_coupon =
        { coupon_id: String, end_date: Time?, start_date: Time }

      class RedeemedCoupon < Orb::Internal::Type::BaseModel
        attr_accessor coupon_id: String

        attr_accessor end_date: Time?

        attr_accessor start_date: Time

        def initialize: (
          coupon_id: String,
          end_date: Time?,
          start_date: Time
        ) -> void
      end

      type status = :active | :ended | :upcoming

      module Status
        extend Orb::Internal::Type::Enum

        ACTIVE: :active
        ENDED: :ended
        UPCOMING: :upcoming

        def self?.values: -> ::Array[Orb::Models::SubscriptionTriggerPhaseResponse::status]
      end

      type trial_info = { end_date: Time? }

      class TrialInfo < Orb::Internal::Type::BaseModel
        attr_accessor end_date: Time?

        def initialize: (end_date: Time?) -> void
      end

      type changed_resources =
        {
          created_credit_notes: ::Array[Orb::CreditNote],
          created_invoices: ::Array[Orb::Invoice],
          voided_credit_notes: ::Array[Orb::CreditNote],
          voided_invoices: ::Array[Orb::Invoice]
        }

      class ChangedResources < Orb::Internal::Type::BaseModel
        attr_accessor created_credit_notes: ::Array[Orb::CreditNote]

        attr_accessor created_invoices: ::Array[Orb::Invoice]

        attr_accessor voided_credit_notes: ::Array[Orb::CreditNote]

        attr_accessor voided_invoices: ::Array[Orb::Invoice]

        def initialize: (
          created_credit_notes: ::Array[Orb::CreditNote],
          created_invoices: ::Array[Orb::Invoice],
          voided_credit_notes: ::Array[Orb::CreditNote],
          voided_invoices: ::Array[Orb::Invoice]
        ) -> void
      end
    end
  end
end
