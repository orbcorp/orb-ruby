module Orb
  module Models
    module Customers
      module Credits
        type ledger_list_by_external_id_response =
          Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment
          | Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement
          | Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange
          | Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry
          | Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void
          | Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated
          | Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment

        module LedgerListByExternalIDResponse
          extend Orb::Internal::Type::Union

          type increment =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::entry_status,
              entry_type: :increment,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float
            }

          class Increment < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::entry_status

            attr_accessor entry_type: :increment

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor starting_balance: Float

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              ?entry_type: :increment
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::increment

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment::entry_status]
            end
          end

          type decrement =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::entry_status,
              entry_type: :decrement,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              event_id: String?,
              invoice_id: String?,
              price_id: String?
            }

          class Decrement < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::entry_status

            attr_accessor entry_type: :decrement

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor starting_balance: Float

            attr_accessor event_id: String?

            attr_accessor invoice_id: String?

            attr_accessor price_id: String?

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              ?event_id: String?,
              ?invoice_id: String?,
              ?price_id: String?,
              ?entry_type: :decrement
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::decrement

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement::entry_status]
            end
          end

          type expiration_change =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::entry_status,
              entry_type: :expiration_change,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              new_block_expiry_date: Time?,
              starting_balance: Float
            }

          class ExpirationChange < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::entry_status

            attr_accessor entry_type: :expiration_change

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor new_block_expiry_date: Time?

            attr_accessor starting_balance: Float

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              new_block_expiry_date: Time?,
              starting_balance: Float,
              ?entry_type: :expiration_change
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::expiration_change

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange::entry_status]
            end
          end

          type credit_block_expiry =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::entry_status,
              entry_type: :credit_block_expiry,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float
            }

          class CreditBlockExpiry < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::entry_status

            attr_accessor entry_type: :credit_block_expiry

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor starting_balance: Float

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              ?entry_type: :credit_block_expiry
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::credit_block_expiry

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry::entry_status]
            end
          end

          type void_ =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::entry_status,
              entry_type: :void,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              void_amount: Float,
              void_reason: String?
            }

          class Void < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::entry_status

            attr_accessor entry_type: :void

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor starting_balance: Float

            attr_accessor void_amount: Float

            attr_accessor void_reason: String?

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              void_amount: Float,
              void_reason: String?,
              ?entry_type: :void
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::void_

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void::entry_status]
            end
          end

          type void_initiated =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::entry_status,
              entry_type: :void_initiated,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              new_block_expiry_date: Time,
              starting_balance: Float,
              void_amount: Float,
              void_reason: String?
            }

          class VoidInitiated < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::entry_status

            attr_accessor entry_type: :void_initiated

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor new_block_expiry_date: Time

            attr_accessor starting_balance: Float

            attr_accessor void_amount: Float

            attr_accessor void_reason: String?

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              new_block_expiry_date: Time,
              starting_balance: Float,
              void_amount: Float,
              void_reason: String?,
              ?entry_type: :void_initiated
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::void_initiated

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated::entry_status]
            end
          end

          type amendment =
            {
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::entry_status,
              entry_type: :amendment,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float
            }

          class Amendment < Orb::Internal::Type::BaseModel
            attr_accessor id: String

            attr_accessor amount: Float

            attr_accessor created_at: Time

            attr_accessor credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::CreditBlock

            attr_accessor currency: String

            attr_accessor customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::Customer

            attr_accessor description: String?

            attr_accessor ending_balance: Float

            attr_accessor entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::entry_status

            attr_accessor entry_type: :amendment

            attr_accessor ledger_sequence_number: Integer

            attr_accessor metadata: ::Hash[Symbol, String]

            attr_accessor starting_balance: Float

            def initialize: (
              id: String,
              amount: Float,
              created_at: Time,
              credit_block: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::CreditBlock,
              currency: String,
              customer: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::Customer,
              description: String?,
              ending_balance: Float,
              entry_status: Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::entry_status,
              ledger_sequence_number: Integer,
              metadata: ::Hash[Symbol, String],
              starting_balance: Float,
              ?entry_type: :amendment
            ) -> void

            def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::amendment

            type credit_block =
              { id: String, expiry_date: Time?, per_unit_cost_basis: String? }

            class CreditBlock < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor expiry_date: Time?

              attr_accessor per_unit_cost_basis: String?

              def initialize: (
                id: String,
                expiry_date: Time?,
                per_unit_cost_basis: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::credit_block
            end

            type customer = { id: String, external_customer_id: String? }

            class Customer < Orb::Internal::Type::BaseModel
              attr_accessor id: String

              attr_accessor external_customer_id: String?

              def initialize: (
                id: String,
                external_customer_id: String?
              ) -> void

              def to_hash: -> Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::customer
            end

            type entry_status = :committed | :pending

            module EntryStatus
              extend Orb::Internal::Type::Enum

              COMMITTED: :committed
              PENDING: :pending

              def self?.values: -> ::Array[Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment::entry_status]
            end
          end

          def self?.variants: -> [Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Increment, Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Decrement, Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::ExpirationChange, Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::CreditBlockExpiry, Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Void, Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::VoidInitiated, Orb::Models::Customers::Credits::LedgerListByExternalIDResponse::Amendment]
        end
      end
    end
  end
end
