module Orb
  module Models
    type subscription_create_params =
      {
        add_adjustments: ::Array[Orb::SubscriptionCreateParams::AddAdjustment]?,
        add_prices: ::Array[Orb::SubscriptionCreateParams::AddPrice]?,
        align_billing_with_subscription_start_date: bool,
        auto_collection: bool?,
        aws_region: String?,
        billing_cycle_anchor_configuration: Orb::BillingCycleAnchorConfiguration?,
        coupon_redemption_code: String?,
        credits_overage_rate: Float?,
        currency: String?,
        customer_id: String?,
        default_invoice_memo: String?,
        end_date: Time?,
        external_customer_id: String?,
        external_marketplace: Orb::Models::SubscriptionCreateParams::external_marketplace?,
        external_marketplace_reporting_id: String?,
        external_plan_id: String?,
        filter: String?,
        initial_phase_order: Integer?,
        invoicing_threshold: String?,
        metadata: ::Hash[Symbol, String?]?,
        name: String?,
        net_terms: Integer?,
        per_credit_overage_amount: Float?,
        plan_id: String?,
        plan_version_number: Integer?,
        price_overrides: ::Array[top]?,
        remove_adjustments: ::Array[Orb::SubscriptionCreateParams::RemoveAdjustment]?,
        remove_prices: ::Array[Orb::SubscriptionCreateParams::RemovePrice]?,
        replace_adjustments: ::Array[Orb::SubscriptionCreateParams::ReplaceAdjustment]?,
        replace_prices: ::Array[Orb::SubscriptionCreateParams::ReplacePrice]?,
        start_date: Time?,
        trial_duration_days: Integer?,
        usage_customer_ids: ::Array[String]?
      }
      & Orb::Internal::Type::request_parameters

    class SubscriptionCreateParams < Orb::Internal::Type::BaseModel
      extend Orb::Internal::Type::RequestParameters::Converter
      include Orb::Internal::Type::RequestParameters

      attr_accessor add_adjustments: ::Array[Orb::SubscriptionCreateParams::AddAdjustment]?

      attr_accessor add_prices: ::Array[Orb::SubscriptionCreateParams::AddPrice]?

      attr_reader align_billing_with_subscription_start_date: bool?

      def align_billing_with_subscription_start_date=: (bool) -> bool

      attr_accessor auto_collection: bool?

      attr_accessor aws_region: String?

      attr_accessor billing_cycle_anchor_configuration: Orb::BillingCycleAnchorConfiguration?

      attr_accessor coupon_redemption_code: String?

      attr_accessor credits_overage_rate: Float?

      attr_accessor currency: String?

      attr_accessor customer_id: String?

      attr_accessor default_invoice_memo: String?

      attr_accessor end_date: Time?

      attr_accessor external_customer_id: String?

      attr_accessor external_marketplace: Orb::Models::SubscriptionCreateParams::external_marketplace?

      attr_accessor external_marketplace_reporting_id: String?

      attr_accessor external_plan_id: String?

      attr_accessor filter: String?

      attr_accessor initial_phase_order: Integer?

      attr_accessor invoicing_threshold: String?

      attr_accessor metadata: ::Hash[Symbol, String?]?

      attr_accessor name: String?

      attr_accessor net_terms: Integer?

      attr_accessor per_credit_overage_amount: Float?

      attr_accessor plan_id: String?

      attr_accessor plan_version_number: Integer?

      attr_accessor price_overrides: ::Array[top]?

      attr_accessor remove_adjustments: ::Array[Orb::SubscriptionCreateParams::RemoveAdjustment]?

      attr_accessor remove_prices: ::Array[Orb::SubscriptionCreateParams::RemovePrice]?

      attr_accessor replace_adjustments: ::Array[Orb::SubscriptionCreateParams::ReplaceAdjustment]?

      attr_accessor replace_prices: ::Array[Orb::SubscriptionCreateParams::ReplacePrice]?

      attr_accessor start_date: Time?

      attr_accessor trial_duration_days: Integer?

      attr_accessor usage_customer_ids: ::Array[String]?

      def initialize: (
        ?add_adjustments: ::Array[Orb::SubscriptionCreateParams::AddAdjustment]?,
        ?add_prices: ::Array[Orb::SubscriptionCreateParams::AddPrice]?,
        ?align_billing_with_subscription_start_date: bool,
        ?auto_collection: bool?,
        ?aws_region: String?,
        ?billing_cycle_anchor_configuration: Orb::BillingCycleAnchorConfiguration?,
        ?coupon_redemption_code: String?,
        ?credits_overage_rate: Float?,
        ?currency: String?,
        ?customer_id: String?,
        ?default_invoice_memo: String?,
        ?end_date: Time?,
        ?external_customer_id: String?,
        ?external_marketplace: Orb::Models::SubscriptionCreateParams::external_marketplace?,
        ?external_marketplace_reporting_id: String?,
        ?external_plan_id: String?,
        ?filter: String?,
        ?initial_phase_order: Integer?,
        ?invoicing_threshold: String?,
        ?metadata: ::Hash[Symbol, String?]?,
        ?name: String?,
        ?net_terms: Integer?,
        ?per_credit_overage_amount: Float?,
        ?plan_id: String?,
        ?plan_version_number: Integer?,
        ?price_overrides: ::Array[top]?,
        ?remove_adjustments: ::Array[Orb::SubscriptionCreateParams::RemoveAdjustment]?,
        ?remove_prices: ::Array[Orb::SubscriptionCreateParams::RemovePrice]?,
        ?replace_adjustments: ::Array[Orb::SubscriptionCreateParams::ReplaceAdjustment]?,
        ?replace_prices: ::Array[Orb::SubscriptionCreateParams::ReplacePrice]?,
        ?start_date: Time?,
        ?trial_duration_days: Integer?,
        ?usage_customer_ids: ::Array[String]?,
        ?request_options: Orb::request_opts
      ) -> void

      def to_hash: -> {
        add_adjustments: ::Array[Orb::SubscriptionCreateParams::AddAdjustment]?,
        add_prices: ::Array[Orb::SubscriptionCreateParams::AddPrice]?,
        align_billing_with_subscription_start_date: bool,
        auto_collection: bool?,
        aws_region: String?,
        billing_cycle_anchor_configuration: Orb::BillingCycleAnchorConfiguration?,
        coupon_redemption_code: String?,
        credits_overage_rate: Float?,
        currency: String?,
        customer_id: String?,
        default_invoice_memo: String?,
        end_date: Time?,
        external_customer_id: String?,
        external_marketplace: Orb::Models::SubscriptionCreateParams::external_marketplace?,
        external_marketplace_reporting_id: String?,
        external_plan_id: String?,
        filter: String?,
        initial_phase_order: Integer?,
        invoicing_threshold: String?,
        metadata: ::Hash[Symbol, String?]?,
        name: String?,
        net_terms: Integer?,
        per_credit_overage_amount: Float?,
        plan_id: String?,
        plan_version_number: Integer?,
        price_overrides: ::Array[top]?,
        remove_adjustments: ::Array[Orb::SubscriptionCreateParams::RemoveAdjustment]?,
        remove_prices: ::Array[Orb::SubscriptionCreateParams::RemovePrice]?,
        replace_adjustments: ::Array[Orb::SubscriptionCreateParams::ReplaceAdjustment]?,
        replace_prices: ::Array[Orb::SubscriptionCreateParams::ReplacePrice]?,
        start_date: Time?,
        trial_duration_days: Integer?,
        usage_customer_ids: ::Array[String]?,
        request_options: Orb::RequestOptions
      }

      type add_adjustment =
        {
          adjustment: Orb::Models::SubscriptionCreateParams::AddAdjustment::adjustment,
          end_date: Time?,
          plan_phase_order: Integer?,
          start_date: Time?
        }

      class AddAdjustment < Orb::Internal::Type::BaseModel
        attr_accessor adjustment: Orb::Models::SubscriptionCreateParams::AddAdjustment::adjustment

        attr_accessor end_date: Time?

        attr_accessor plan_phase_order: Integer?

        attr_accessor start_date: Time?

        def initialize: (
          adjustment: Orb::Models::SubscriptionCreateParams::AddAdjustment::adjustment,
          ?end_date: Time?,
          ?plan_phase_order: Integer?,
          ?start_date: Time?
        ) -> void

        def to_hash: -> {
          adjustment: Orb::Models::SubscriptionCreateParams::AddAdjustment::adjustment,
          end_date: Time?,
          plan_phase_order: Integer?,
          start_date: Time?
        }

        type adjustment =
          Orb::NewPercentageDiscount
          | Orb::NewUsageDiscount
          | Orb::NewAmountDiscount
          | Orb::NewMinimum
          | Orb::NewMaximum

        module Adjustment
          extend Orb::Internal::Type::Union

          def self?.variants: -> ::Array[Orb::Models::SubscriptionCreateParams::AddAdjustment::adjustment]
        end
      end

      type add_price =
        {
          allocation_price: Orb::NewAllocationPrice?,
          discounts: ::Array[Orb::DiscountOverride]?,
          end_date: Time?,
          external_price_id: String?,
          maximum_amount: String?,
          minimum_amount: String?,
          plan_phase_order: Integer?,
          price: Orb::Models::SubscriptionCreateParams::AddPrice::price?,
          price_id: String?,
          start_date: Time?
        }

      class AddPrice < Orb::Internal::Type::BaseModel
        attr_accessor allocation_price: Orb::NewAllocationPrice?

        attr_accessor discounts: ::Array[Orb::DiscountOverride]?

        attr_accessor end_date: Time?

        attr_accessor external_price_id: String?

        attr_accessor maximum_amount: String?

        attr_accessor minimum_amount: String?

        attr_accessor plan_phase_order: Integer?

        attr_accessor price: Orb::Models::SubscriptionCreateParams::AddPrice::price?

        attr_accessor price_id: String?

        attr_accessor start_date: Time?

        def initialize: (
          ?allocation_price: Orb::NewAllocationPrice?,
          ?discounts: ::Array[Orb::DiscountOverride]?,
          ?end_date: Time?,
          ?external_price_id: String?,
          ?maximum_amount: String?,
          ?minimum_amount: String?,
          ?plan_phase_order: Integer?,
          ?price: Orb::Models::SubscriptionCreateParams::AddPrice::price?,
          ?price_id: String?,
          ?start_date: Time?
        ) -> void

        def to_hash: -> {
          allocation_price: Orb::NewAllocationPrice?,
          discounts: ::Array[Orb::DiscountOverride]?,
          end_date: Time?,
          external_price_id: String?,
          maximum_amount: String?,
          minimum_amount: String?,
          plan_phase_order: Integer?,
          price: Orb::Models::SubscriptionCreateParams::AddPrice::price?,
          price_id: String?,
          start_date: Time?
        }

        type price =
          Orb::NewSubscriptionUnitPrice
          | Orb::NewSubscriptionPackagePrice
          | Orb::NewSubscriptionMatrixPrice
          | Orb::NewSubscriptionTieredPrice
          | Orb::NewSubscriptionTieredBPSPrice
          | Orb::NewSubscriptionBPSPrice
          | Orb::NewSubscriptionBulkBPSPrice
          | Orb::NewSubscriptionBulkPrice
          | Orb::NewSubscriptionThresholdTotalAmountPrice
          | Orb::NewSubscriptionTieredPackagePrice
          | Orb::NewSubscriptionTieredWithMinimumPrice
          | Orb::NewSubscriptionUnitWithPercentPrice
          | Orb::NewSubscriptionPackageWithAllocationPrice
          | Orb::NewSubscriptionTierWithProrationPrice
          | Orb::NewSubscriptionUnitWithProrationPrice
          | Orb::NewSubscriptionGroupedAllocationPrice
          | Orb::NewSubscriptionGroupedWithProratedMinimumPrice
          | Orb::NewSubscriptionBulkWithProrationPrice
          | Orb::NewSubscriptionScalableMatrixWithUnitPricingPrice
          | Orb::NewSubscriptionScalableMatrixWithTieredPricingPrice
          | Orb::NewSubscriptionCumulativeGroupedBulkPrice
          | Orb::NewSubscriptionMaxGroupTieredPackagePrice
          | Orb::NewSubscriptionGroupedWithMeteredMinimumPrice
          | Orb::NewSubscriptionMatrixWithDisplayNamePrice
          | Orb::NewSubscriptionGroupedTieredPackagePrice
          | Orb::NewSubscriptionMatrixWithAllocationPrice
          | Orb::NewSubscriptionTieredPackageWithMinimumPrice
          | Orb::NewSubscriptionGroupedTieredPrice

        module Price
          extend Orb::Internal::Type::Union

          def self?.variants: -> ::Array[Orb::Models::SubscriptionCreateParams::AddPrice::price]
        end
      end

      type external_marketplace = :google | :aws | :azure

      module ExternalMarketplace
        extend Orb::Internal::Type::Enum

        GOOGLE: :google
        AWS: :aws
        AZURE: :azure

        def self?.values: -> ::Array[Orb::Models::SubscriptionCreateParams::external_marketplace]
      end

      type remove_adjustment = { adjustment_id: String }

      class RemoveAdjustment < Orb::Internal::Type::BaseModel
        attr_accessor adjustment_id: String

        def initialize: (adjustment_id: String) -> void

        def to_hash: -> { adjustment_id: String }
      end

      type remove_price = { external_price_id: String?, price_id: String? }

      class RemovePrice < Orb::Internal::Type::BaseModel
        attr_accessor external_price_id: String?

        attr_accessor price_id: String?

        def initialize: (
          ?external_price_id: String?,
          ?price_id: String?
        ) -> void

        def to_hash: -> { external_price_id: String?, price_id: String? }
      end

      type replace_adjustment =
        {
          adjustment: Orb::Models::SubscriptionCreateParams::ReplaceAdjustment::adjustment,
          replaces_adjustment_id: String
        }

      class ReplaceAdjustment < Orb::Internal::Type::BaseModel
        attr_accessor adjustment: Orb::Models::SubscriptionCreateParams::ReplaceAdjustment::adjustment

        attr_accessor replaces_adjustment_id: String

        def initialize: (
          adjustment: Orb::Models::SubscriptionCreateParams::ReplaceAdjustment::adjustment,
          replaces_adjustment_id: String
        ) -> void

        def to_hash: -> {
          adjustment: Orb::Models::SubscriptionCreateParams::ReplaceAdjustment::adjustment,
          replaces_adjustment_id: String
        }

        type adjustment =
          Orb::NewPercentageDiscount
          | Orb::NewUsageDiscount
          | Orb::NewAmountDiscount
          | Orb::NewMinimum
          | Orb::NewMaximum

        module Adjustment
          extend Orb::Internal::Type::Union

          def self?.variants: -> ::Array[Orb::Models::SubscriptionCreateParams::ReplaceAdjustment::adjustment]
        end
      end

      type replace_price =
        {
          replaces_price_id: String,
          allocation_price: Orb::NewAllocationPrice?,
          discounts: ::Array[Orb::DiscountOverride]?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          maximum_amount: String?,
          minimum_amount: String?,
          price: Orb::Models::SubscriptionCreateParams::ReplacePrice::price?,
          price_id: String?
        }

      class ReplacePrice < Orb::Internal::Type::BaseModel
        attr_accessor replaces_price_id: String

        attr_accessor allocation_price: Orb::NewAllocationPrice?

        attr_accessor discounts: ::Array[Orb::DiscountOverride]?

        attr_accessor external_price_id: String?

        attr_accessor fixed_price_quantity: Float?

        attr_accessor maximum_amount: String?

        attr_accessor minimum_amount: String?

        attr_accessor price: Orb::Models::SubscriptionCreateParams::ReplacePrice::price?

        attr_accessor price_id: String?

        def initialize: (
          replaces_price_id: String,
          ?allocation_price: Orb::NewAllocationPrice?,
          ?discounts: ::Array[Orb::DiscountOverride]?,
          ?external_price_id: String?,
          ?fixed_price_quantity: Float?,
          ?maximum_amount: String?,
          ?minimum_amount: String?,
          ?price: Orb::Models::SubscriptionCreateParams::ReplacePrice::price?,
          ?price_id: String?
        ) -> void

        def to_hash: -> {
          replaces_price_id: String,
          allocation_price: Orb::NewAllocationPrice?,
          discounts: ::Array[Orb::DiscountOverride]?,
          external_price_id: String?,
          fixed_price_quantity: Float?,
          maximum_amount: String?,
          minimum_amount: String?,
          price: Orb::Models::SubscriptionCreateParams::ReplacePrice::price?,
          price_id: String?
        }

        type price =
          Orb::NewSubscriptionUnitPrice
          | Orb::NewSubscriptionPackagePrice
          | Orb::NewSubscriptionMatrixPrice
          | Orb::NewSubscriptionTieredPrice
          | Orb::NewSubscriptionTieredBPSPrice
          | Orb::NewSubscriptionBPSPrice
          | Orb::NewSubscriptionBulkBPSPrice
          | Orb::NewSubscriptionBulkPrice
          | Orb::NewSubscriptionThresholdTotalAmountPrice
          | Orb::NewSubscriptionTieredPackagePrice
          | Orb::NewSubscriptionTieredWithMinimumPrice
          | Orb::NewSubscriptionUnitWithPercentPrice
          | Orb::NewSubscriptionPackageWithAllocationPrice
          | Orb::NewSubscriptionTierWithProrationPrice
          | Orb::NewSubscriptionUnitWithProrationPrice
          | Orb::NewSubscriptionGroupedAllocationPrice
          | Orb::NewSubscriptionGroupedWithProratedMinimumPrice
          | Orb::NewSubscriptionBulkWithProrationPrice
          | Orb::NewSubscriptionScalableMatrixWithUnitPricingPrice
          | Orb::NewSubscriptionScalableMatrixWithTieredPricingPrice
          | Orb::NewSubscriptionCumulativeGroupedBulkPrice
          | Orb::NewSubscriptionMaxGroupTieredPackagePrice
          | Orb::NewSubscriptionGroupedWithMeteredMinimumPrice
          | Orb::NewSubscriptionMatrixWithDisplayNamePrice
          | Orb::NewSubscriptionGroupedTieredPackagePrice
          | Orb::NewSubscriptionMatrixWithAllocationPrice
          | Orb::NewSubscriptionTieredPackageWithMinimumPrice
          | Orb::NewSubscriptionGroupedTieredPrice

        module Price
          extend Orb::Internal::Type::Union

          def self?.variants: -> ::Array[Orb::Models::SubscriptionCreateParams::ReplacePrice::price]
        end
      end
    end
  end
end
